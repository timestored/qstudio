[
    {
        "title": "abs",
        "cal": "abs(X)",
        "params": "`X`  is a scalar/pair/vector/matrix.",
        "exp": "Return the element-by-element absolute value(s) of X.",
        "eg": "  \n   $ abs(-2.0);\n   2\n\n   $ abs(-2 -3 4);\n   [2, 3, 4]"
    },
    {
        "title": "accumulate",
        "cal": "accumulate(func, X, [init], [consistent=false])",
        "params": "`func` is a function for iteration.",
        "exp": "The ``accumulate`` template applies *func* to *init* and *X* for accumulating iteration (i.e. the result of an iteration is passed forward to the next). Unlike the template ``reduce`` that returns only the last result, the template ``accumulate`` outputs result of each iteration. ",
        "eg": "*func* is a unary function:\n"
    },
    {
        "title": "acf",
        "cal": "acf(X, maxLag)",
        "params": "`X`  is a vector.",
        "exp": "Calculate the autocorrelation of X from lag=1 to lag=maxLag. Please note that the means of the two time series used in the calculation is the mean of X instead of the means of the two time series.",
        "eg": "\n   $ n=10000\n   $ x=array(double, n, n, NULL)\n   $ x[0]=1\n   $ r=rand(0.05, n)-0.025\n   $ for(i in 0:(n-1)){\n   $    x[i+1]=-0.8*x[i]+r[i]        \n   $ }\n\n   $ acf = acf(x, 20)\n   $ plot(acf,chartType=BAR)"
    },
    {
        "title": "acos",
        "cal": "acos(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "The inverse cosine function. ",
        "eg": "\n   $ acos(1.000000 0.540302 -0.416147);\n   [0,1,2]\n"
    },
    {
        "title": "acosh",
        "cal": "acosh(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "The inverse hyperbolic cosine function.",
        "eg": "\n   $ acosh(1 2 3);\n   [0,1.316958,1.762747]\n"
    },
    {
        "title": "adaBoostClassifier",
        "cal": "adaBoostClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [algorithm='SAMME.R'], [randomSeed])",
        "params": "`ds`  is the data sources to be trained. It can be generated with function  :doc:`../s/sqlDS`.",
        "exp": "Fit an AdaBoost classification model. The result is a dictionary with the following keys: numClasses, minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames, learningRate and algorithm. model is a tuple with the result of the trained trees; modelName is \"AdaBoost Classifier\".",
        "eg": "Fit an AdaBoost classification model with simulated data:\n"
    },
    {
        "title": "adaBoostRegressor",
        "cal": "adaBoostRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=10], [minImpurityDecrease=0.0], [learningRate=0.1], [loss='linear'], [randomSeed])",
        "params": "`ds` is the data sources to be trained. It can be generated with function sqlDS.",
        "exp": "Fit an AdaBoost regression model. The result is a dictionary with the following keys: minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName, xColNames, learningRate and loss. model is a tuple with the result of the trained trees; modelName is \"AdaBoost Regressor\".",
        "eg": "Fit an AdaBoost regression model with simulated data:\n"
    },
    {
        "title": "add",
        "cal": "add(X, Y)",
        "params": "`X` and  `Y` is a scalar/pair/vector/matrix. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size. ",
        "exp": "Return the element-by-element sum of X and Y.",
        "eg": "\n    $ add(3,2)\n    5\n\n    $ 1:2+6\n    7:8\n\n    $ 1:2+3:4\n    4 : 6\n\n    $ 3+1..3\n    [4,5,6]\n\n    $ add(1..3, 4..6)\n    [5,7,9]\n\n    $ (1..3).add(4..6)\n    [5,7,9]          \n\n    $ x=reshape(1..6, 3:2)\n    $ x\n"
    },
    {
        "title": "addAccessControl",
        "cal": "addAccessControl(table)",
        "params": "`table` is a shared table or a streaming engine.",
        "exp": "The current user can add access control to the table created by herself. Other users can access this table only after the administrator grants the privilege.",
        "eg": "Create a user group for access management.\n"
    },
    {
        "title": "addColumn",
        "cal": "addColumn(table, colNames, colTypes)",
        "params": "`table` can be a table of any type, such as an in-memory table, a stream table, a DFS table, or a dimension table.",
        "exp": "Add a column or columns to a table. It is the only way to add a column to a stream table, a DFS table, or a dimension table. SQL update statement is not supported for these cases.",
        "eg": "*Example 1: Add columns to a DFS table.*\n"
    },
    {
        "title": "addFunctionView",
        "cal": "addFunctionView(udfs)",
        "params": "`udfs` is either a user defined function or a tuple containing multiple user defined functions.",
        "exp": "Function view provides a flexible way to control user access to databases and tables. A function view is a user-defined function that encapsulates statements that access databases. Even if a user does not have the privilege to read the data of a database, the user can execute the function view to obtain the desired calculation result.",
        "eg": "In the following example, the user-defined function ``getSpread`` calculates the average bid-ask spread for a specified stock in the table `dfs://TAQ/quotes`. A user (user1) does not have the privilege to read table `dfs://TAQ/quotes`. Now define function ``getSpread`` to be a function view, and grant user1 the priviledge to execute the function view. Although user1 cannot read the raw data of table `dfs://TAQ/quotes`, now she can execute the function view to calculate the average bid-ask spread of any stock in the table.\n\nPlease note that as table `dfs://TAQ/quotes` is a distributed database, the following script needs to be executed by a system administrator. User1 can execute function ``getSpread`` on any data node/compute node.\n"
    },
    {
        "title": "addGroupMember",
        "cal": "addGroupMember(userIds, groupIds)",
        "params": "`userIds` a string scalar/vector indicating a user name or multiple user names.",
        "exp": "Add a user to a group or multiple groups, or add multiple users to a group. This can only be executed by an administrator on the controller.",
        "eg": "\n    $ addGroupMember(`AlexSmith`JoshAllen, `production);"
    },
    {
        "title": "addMetrics",
        "cal": "addMetrics(engine/name, newMetrics, newMetricsSchema, [windowSize])",
        "params": "`engine` is the abstract table object returned by a streaming engine function such as ``createTimeSeriesEngine``. Please note that ``addMetrics`` cannot be used in :doc:`../../FunctionReferences/c/createAnomalyDetectionEngine` and :doc:`../../FunctionReferences/c/createReactiveStateEngine`.",
        "exp": "Dynamically add new measures to a streaming engine.",
        "eg": "Calculate the sum of column x with a streaming engine:\n"
    },
    {
        "title": "addNode",
        "cal": "addNode(host, port, alias, [saveConfig=true], [nodeType='datanode'])",
        "params": "`host` is a string indicating the IP address of the new node.",
        "exp": "Add a new node to a cluster. It will not start the new node. You can start the new node in the cluster management web interface or in the command line.",
        "eg": "\n    $ addNode(\"192.168.1.103\",8900,\"node1\");"
    },
    {
        "title": "addRangePartitions",
        "cal": "addRangePartitions(dbHandle, newRanges, [level=0], [locations])",
        "params": "`dbHandle` is a database handle. ",
        "exp": "Append new values to the partition scheme of a database. This database must be of RANGE domain or of COMPO domain with at least one level of RANGE domain. ",
        "eg": "In the following example, we append (2017.08.12..2017.08.20) to the partition scheme of a database of COMPO domain.\n"
    },
    {
        "title": "addValuePartitions",
        "cal": "addValuePartitions(dbHandle, newValues, [level=0], [locations])",
        "params": "`dbHandle` is a database handle. ",
        "exp": "Append new values to the partition scheme of a database. ",
        "eg": "In the following example, we append (2017.08.12..2017.08.20) to the partition scheme of a database of COMPO domain.\n"
    },
    {
        "title": "addVolumes",
        "cal": "addVolumes(volumes)",
        "params": "`volumes` is a STRING scalar or vector indicating the volume path(s).",
        "exp": "Dynamically add volume(s) without rebooting the cluster.",
        "eg": "\n    $ addVolumes(\"E:/data\")\n"
    },
    {
        "title": "aggrTopN",
        "cal": "aggrTopN(func, funcArgs, sortingCol, top, [ascending=true])",
        "params": "`func` is an aggregate function.",
        "exp": "After sorting *funcArgs* based on *sortingCol*, ``aggrTopN`` applies *func* to the first *top* elements in *funcArgs*. NULL value in *sortingCol* is treated as the minimum value.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "align",
        "cal": "align(left, right, [how='outer'], [byRow], [view=true])",
        "params": "`left` and `right` are both matrices with column and/or row labels.",
        "exp": "Align the left and right matrices based on row labels and/or column labels (specified by *byRow*) using the join method specified by *how*. Return a tuple with 2 aligned matrices.",
        "eg": "Prior to version 1.30.20/2.10.0, matrices must be converted to indexed matrices/series for binary operations. As the matrix/series will be aligned on index (with \"outer\" join), they must be monotonically increasing. \n\nWith the align function, alignment between matrices are more flexible in the following aspects:\n\n- Alignment between non-indexed matrices are supported. The matrices can be aligned on column/row labels which do not have to be monotonically increasing.\n\n- More options for the alignment methods."
    },
    {
        "title": "all",
        "cal": "all(func, args...)",
        "params": "`func`  is a function.",
        "exp": "Apply a function on each element of all arguments. The template runs through each element of a vector, each column of a matrix, and each row of a table. It stops execution and returns a false value as soon as one function call returns a false value. It returns a true value if all function calls return true values.",
        "eg": "Template ``all`` on a vector:\n"
    },
    {
        "title": "and",
        "cal": "and(X, Y)",
        "params": "`X` /  `Y` is a scalar/pair/vector/matrix. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size. ",
        "exp": "Return the element-by-element logical X AND Y. ",
        "eg": "  \n    $ 1 && 3;\n    1\n\n    $ x=1 2 3\n    $ x && 0\n    [0,0,0]\n\n    $ x=1 2 3\n    $ y=0 1 0\n    $ x && y\n    [0,1,0]\n\n    $ t=table(1 2 2 3 as id, 4 5 6 5 as value)\n    $ t\n"
    },
    {
        "title": "anova",
        "cal": "anova(X)",
        "params": "`X`  is a matrix or a table whose columns are all of numeric types.  ",
        "exp": "Conduct one-way analysis of variance (ANOVA). Each column in X is a group. ",
        "eg": "\n    $ a=300 287 301 400 211 399 412 312 390 412\n    $ b=240 259 302 311 210 402 390 298 347 380\n    $ c=210 230 213 210 220 208 290 300 201 201\n    $ m=matrix(a,b,c)\n    $ anova(m);\n\n    pValue->0.000515\n    fValue->10.15459\n    ssBetween->70528.066667\n    dfBetween->2\n    ssWithin->93763.4\n    dfWithin->27\n"
    },
    {
        "title": "any",
        "cal": "any(func, args...)",
        "params": "`func`  is a function.",
        "exp": "Apply a function on each element of all arguments. The template runs through each element of a vector, each column of a matrix, and each row of a table. It stops execution and returns a true value as soon as one function call returns a true value. It returns a false value if all function calls return false values.",
        "eg": "Template ``any`` on a vector:\n"
    },
    {
        "title": "append!",
        "cal": "append!(obj, newData)",
        "params": "`obj` is a local variable, and it must a vector/matrix/table/set.",
        "exp": "Append *newData* to *obj*. The exclamation mark (!) means in-place change in DolphinDB.",
        "eg": "\n    $ x = 1 2 3\n    $ x.append!(4)\n    $ x\n    [1,2,3,4]\n    $ append!(x, 5 6)\n    $ x\n    [1,2,3,4,5,6]\n    $ x.append!(7.2)\n    $ x\n    [1,2,3,4,5,6,7]              \n\n    // converted DOUBLE 7.2 to INT 7\n\n    $ x.append!(`XOM)\n    Incompatible type. Expected: INT, Actual: STRING\n\n    $ x=array(int, 0, 10)\n   // x is an empty vector\n\n    $ x\n    []\n    $ x.append!(1)\n    $ x  \n    []\n    $ x=array(symbol, 0, 100)\n    $ append!(x, `TEST)\n    $ x\n    [\"TEST\"]\n\n    $ x=1..6$3:2\n    $ x  \n    "
    },
    {
        "title": "appendForJoin",
        "cal": "appendForJoin(engine, isLeftTable, data)",
        "params": "`engine`  is a streaming join engine, which is the abstract table object returned by functions ``createAsofJoinEngine``, ``createEqualJoinEngine``, ``createWindowJoinEngine``, or ``createLookupJoinEngine``.",
        "exp": "Insert data into a streaming join engine.",
        "eg": "\n    $ leftTable=table(1:0, `timestamp`sym`price, [TIMESTAMP, SYMBOL, DOUBLE])\n    $ rightTable=table(1:0, `timestamp`sym`val, [TIMESTAMP, SYMBOL, DOUBLE])\n    $ output=table(100:0, `timestamp`sym`price`val`total, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE])\n    $ ajEngine=createAsofJoinEngine(\"test1\", leftTable, rightTable, output, <[price, val, price*val]>, `sym, `timestamp, false, 7)\n\n    $ tmp1=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as price)\n    $ tmp2=table(take(2012.01.01T00:00:00.000+[1, 2, 3, 4, 4, 4, 4, 4, 4, 4], 20) as timestamp, take(`AAPL, 10) join take(`IBM, 10) as sym, double(1..20) as val)\n\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.001))\n    $ appendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.001))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.002))\n    $ appendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.002))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.003))\n    $ appendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.003))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.004))\n    $ appendForJoin(ajEngine, false, (select * from tmp2 where timestamp=2012.01.01T00:00:00.004))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.005))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.006))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.007))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.008))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.009))\n    $ appendForJoin(ajEngine, true, (select * from tmp1 where timestamp=2012.01.01T00:00:00.010))\n\n    $ sleep(5000)\n    $ leftTable.append!(tmp1)\n    $ rightTable.append!(tmp2)"
    },
    {
        "title": "appendMsg",
        "cal": "appendMsg(engine, msgBody, msgId)",
        "params": "`engine` is a built-in streaming engine, i.e., the abstract table object return by functions such as :doc:`../c/createReactiveStateEngine` ",
        "exp": "If snapshot is enabled and RaftGroup is disabled for a streaming engine, the handler parameter of function :doc:`../s/subscribeTable`\\  must be ``appendMsg`` to inject the data into the engine.",
        "eg": "\n    $ share streamTable(10000:0,`time`sym`price, [TIMESTAMP,SYMBOL,DOUBLE]) as trades\n    $ output1 =table(10000:0, `time`sym`avgPrice, [TIMESTAMP,SYMBOL,DOUBLE]);\n\n    $ engine1 = createTimeSeriesEngine(name=`engine1, windowSize=100, step=50, metrics=<avg(price)>, dummyTable=trades, outputTable=output1, timeColumn=`time, keyColumn=`sym, snapshotDir=\"C:/DolphinDB/Data/snapshotDir\", snapshotIntervalInMsgCount=100)\n    $ subscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=appendMsg{engine1}, msgAsTable=true, handlerNeedMsgId=true)\n\n    $ n=500\n    $ timev=2021.03.12T15:00:00.000 + (1..n join 1..n)\n    $ symv = take(`A, n) join take(`B, n)\n    $ pricev = (100+cumsum(rand(1.0,n)-0.5)) join (200+cumsum(rand(1.0,n)-0.5))\n    $ t=table(timev as time, symv as sym, pricev as price).sortBy!(`time)\n    $ trades.append!(t)\n\n    $ select * from output1"
    },
    {
        "title": "array",
        "cal": "array(dataType|template, [initialSize], [capacity], [defaultValue])",
        "params": "`dataType`  is the data type for the vector. ",
        "exp": "Return a vector.",
        "eg": "\n    $ x=array(int, 10, 100, 1)\n    // initial size is 10; capacity is 100; default value is 1\n    $ x\n    [1,1,1,1,1,1,1,1,1,1]\n\n    $ x=array(int, 0)\n    // initialize an empty vector\n    $x\n    []\n    $ x.append!(1..10)                          \n    [1,2,3,4,5,6,7,8,9,10]\n\n    $ y=array(x)\n    $ y\n    [0,0,0,0,0,0,0,0,0,0]\n\n    $ syms=array(symbol, 0, 100)\n    // an empty symbol vector with capacity of 100                \n\n    $ typestr syms\n    FAST SYMBOL VECTOR"
    },
    {
        "title": "arrayVector",
        "cal": "arrayVector(index, value)",
        "params": "`index` is a vector of positive integers, which must be strictly monotonically increasing.",
        "exp": "Convert *value* into an array vector by spliting it based on the elements in *index*. The number of elements in *index* indicates the number of rows of array vector. Each element in *index* corresponds to the position in *value* (starting from 1), which is the last element of each new vector. See how an array vector is converted in the following figure:",
        "eg": "    \n    $ arrayVector(2 3 4, [1,2,3,4])\n    [[1,2],[3],[4]]\n\n    $ arrayVector(1 4 7, [1.0,2.1,4.1,6.8,0.5,2.2,2])\n    [[1],[2.1,4.1,6.8],[0.5,2.2,2]]\n\n    $ value = 2022.01.01 + 0..20\n    $ index = 7 14 21\n    $ arrayVector(index, value)\n    [[2022.01.01,2022.01.02,2022.01.03,2022.01.04,2022.01.05,2022.01.06,2022.01.07],[2022.01.08,2022.01.09,2022.01.10,2022.01.11,2022.01.12,2022.01.13,2022.01.14],[2022.01.15,2022.01.16,2022.01.17,2022.01.18,2022.01.19,2022.01.20,2022.01.21]]\n"
    },
    {
        "title": "asFreq",
        "cal": "asfreq(X, rule, [closed], [label], [origin='start_day'])",
        "params": "`X`  is an indexed matrix or indexed series. The index must be of temporal type. ",
        "exp": "Convert X to specified frequency. Different from :doc:`../r/resample`, aggregate functions cannot be used in ``asfreq``.",
        "eg": "\n    $ index = [2000.01.01, 2000.01.31, 2000.02.15, 2000.02.20, 2000.03.31, 2000.04.16, 2000.05.06, 2000.08.31]\n    $ s = indexedSeries(index, 1..8)\n    $ s\n"
    },
    {
        "title": "asin",
        "cal": "asin(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The inverse sine (arcsine) function.",
        "eg": "\n   $ asin(0 0.5 1);\n   [0,0.523599,1.570796]\n"
    },
    {
        "title": "asinh",
        "cal": "asinh(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The inverse hyperbolic sine function.",
        "eg": "\n   $ asinh(0.841471 0.909297 0.141120);\n   [0.764725,0.815761,0.140656]\n"
    },
    {
        "title": "asis",
        "cal": "asis(X)",
        "params": "`X` can be of any data type.",
        "exp": "Return a shallow copy of X.",
        "eg": "  \n   $ a = 1 2 3\n   $ b = asis(a)\n   $ a[0] = 0\n   $ b\n   [0, 2, 3]\n   $ b[1] = 4\n   a;\n   [0, 4, 3]\n"
    },
    {
        "title": "asof",
        "cal": "asof(X, Y)",
        "params": "`X` must be a vector/indexed series/indexed matrix sorted in ascending order.",
        "exp": "For each element y in Y, return the index of the last element in X that is no greater than y. If nothing is found, return -1. ",
        "eg": "\n    $ asof(1..100, 60 200 -10)\n    [59,99,-1]\n\n    $ 0 0 0 1 1 1 1 2 2 3 asof 1\n    6"
    },
    {
        "title": "at",
        "cal": "at(X, [index])",
        "params": "If only 1 parameter is specified:  `X` is a Boolean expression or a vector.",
        "exp": "In the first case, return the indexes of the elements of X that are true.",
        "eg": "\n    $ x=5 7 0 4 2 3\n    $ at(x>3)\n    [0,1,3]                        \n    // at position 0, 1, and 3, x>3 is true.\n\n    // compare with x>3:\n    $ x>3;\n    [1,1,0,1,0,0]\n\n    $ x[x>3]\n    [5,7,4]\n    $ x at x>3\n    [5,7,4]\n\n    $ x=5 7 0 0 0 3\n    $ at(x==0)\n    [2,3,4]\n\n    $ x[x==0]\n    [0,0,0]\n\n    $ shares=500 1000 1000 600 2000\n    $ prices=25.5 97.5  19.2 38.4 101.5\n    $ prices[shares>800]            \n    [97.5,19.2,101.5]              \n    $ prices at shares>800          \n    [97.5,19.2,101.5]      \n\n    $ m=(1..6).reshape(2:3) \n    $ m;      \n"
    },
    {
        "title": "atImax",
        "cal": "atImax(location, value)",
        "params": "`location`  and  `value` are vectors/matrices of the same dimensions. ",
        "exp": "Find the position of the element with the largest value in parameter *location*, and return the value of the element in the same position in parameter *value*. If there are multiple identical maximums in *location*, return the position of the first maximum.",
        "eg": "\n    $ atImax(3 5 1 2, 9 7 5 3)\n    7\n"
    },
    {
        "title": "atImin",
        "cal": "atImin(location, value)",
        "params": "`location` and `value` are vectors/matrices of the same dimensions. ",
        "exp": "Find the position of the element with the smallest value in parameter *location*, and return the value of the element in the same position in parameter *value*. If there are multiple identical minimums in *location*, return the position of the first minimum.",
        "eg": "\n    $ atImin(3 5 1 2, 9 7 5 3)\n    5\n"
    },
    {
        "title": "atan",
        "cal": "atan(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "The inverse tangent (arctan) function. ",
        "eg": "\n   $ atan 0.000000 1.557408 -2.185040;\n   [0,1,-1.141593]\n"
    },
    {
        "title": "atanh",
        "cal": "atanh(X)",
        "params": "`X`  is a scalar/vector/matrix. ",
        "exp": "The inverse hyperbolic tangent function. ",
        "eg": "\n   $ atanh 0.000000 0.557408 -0.185040;\n   [0,0.629065,-0.187196]\n"
    },
    {
        "title": "autocorr",
        "cal": "autocorr(X, lag)",
        "params": "`location` is a vector.",
        "exp": "Calculate the autocorrelation of X. Please note that the means of the two time series used in the calculation is the mean of X instead of the means of the two time series.",
        "eg": "\n    $ n=10000\n    $ x=array(double, n, n, NULL)\n    $ x[0]=1\n    $ r=rand(0.05, n)-0.025\n    $ for(i in 0:(n-1)){\n    $     x[i+1]=-0.8*x[i]+r[i]        \n    $ }\n\n    $ autocorr(x, 1)\n    -0.808343\n\n    $ autocorr(x, 2)\n    0.661018\n\n\n\n\n"
    },
    {
        "title": "avg",
        "cal": "avg(X)",
        "params": "`X`  is a scalar/pair/vector/matrix.",
        "exp": "Calculate the average of X.",
        "eg": "\n    $ avg(1 2 3 NULL)\n    2\n\n    $ m=matrix(1 2 3, 4 5 6)\n    $ m\n"
    },
    {
        "title": "backupDB",
        "cal": "backupDB(backupDir, dbPath)",
        "params": "`backupDir` is a string indicating the directory to save the backup.",
        "exp": "Back up the entire database to the specified directory.",
        "eg": "\n    $ dbName = \"dfs://compoDB2\"\n    $ n=1000\n    $ ID=rand(\"a\"+string(1..10), n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(10, n)\n    $ t=table(ID, date, x)\n    $ db1 = database(, VALUE, 2017.08.07..2017.08.11)\n    $ db2 = database(, HASH,[INT, 20])\n    $ if(existsDatabase(dbName)){\n    $ \tdropDatabase(dbName)\n    $ }\n    $ db = database(dbName, COMPO,[ db1,db2])\n\n    //create 2 tables\n    $ pt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\n    $ pt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\n    $ backupDB(backupDir, dbName)\n\n"
    },
    {
        "title": "backupTable",
        "cal": "backupTable(backupDir, dbPath, tableName)",
        "params": "`backupDir` is a string indicating the directory to save the backup.",
        "exp": "Back up a table to the specified directory.",
        "eg": "\n    $ dbName = \"dfs://compoDB2\"\n    $ n=1000\n    $ ID=rand(\"a\"+string(1..10), n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(10, n)\n    $ t=table(ID, date, x)\n    $ db1 = database(, VALUE, 2017.08.07..2017.08.11)\n    $ db2 = database(, HASH,[INT, 20])\n    $ if(existsDatabase(dbName)){\n    $ \tdropDatabase(dbName)\n    $ }\n    $ db = database(dbName, COMPO,[ db1,db2])\n\n    $ //create 2 tables\n    $ pt1 = db.createPartitionedTable(t, `pt1, `date`x).append!(t)\n    $ pt2 = db.createPartitionedTable(t, `pt2, `date`x).append!(t)\n\n    $ backupTable(backupDir,dbName,`pt1)\n    50\n\n"
    },
    {
        "title": "bar",
        "cal": "bar(X, interval, [closed='left'])",
        "params": "`X` is an integral/temporal scalar or vector.",
        "exp": "``bar`` can group *X* based on the length specified by *interval*. Return a vector with the same length as X.",
        "eg": "\n    $ bar(100,3);               // 100-(100%3)=100-1=99\n    99\n\n    $ bar(0..15, 3)\n    [0,0,0,3,3,3,6,6,6,9,9,9,12,12,12,15]\n\n    $ x=[7,4,5,8,9,3,3,5,2,6,12,1,0,-5,32]\n    $ bar(x, 5)\n    [5,0,5,5,5,0,0,5,0,5,10,0,0,-5,30]\n\n    $ t=table(2021.01.01T01:00:00..2021.01.01T01:00:29 as time, rand(1.0, 30) as x)\n    $ select max(x) from t group by bar(time,5s)\n    "
    },
    {
        "title": "beta",
        "cal": "beta(Y, X)",
        "params": "`Y` and `X` are vectors of the same length ",
        "exp": "Return the coefficient estimate of an ordinary-least-squares regression of Y on X (with intercept). ",
        "eg": "\n    $ x=1 3 5 7 11 16 23\n    $ y=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\n    $ beta(y,x);\n    3.378632\n\n"
    },
    {
        "title": "between",
        "cal": "between(X, Y)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Check if each element of X is between the pair indicated by Y (both boundaries are inclusive). The result is of the same dimension as X. ",
        "eg": "\n    $ between([1, 5.5, 6, 8], 1:6);\n    [1,1,1,0]\n    // 1, 5.5 and 6 are between 1 and 6, but 8 is not. \n    \n    $ between(1 2.4 3.6 2 3.9, 2.4:3.6);\n    [0,1,1,0,0]\n\n"
    },
    {
        "title": "bfill",
        "cal": "bfill(obj, [limit])",
        "params": "`obj` is a vector/matrix/table.",
        "exp": "If `obj` is a vector: back fill the NULL values in `obj` with the next non-NULL value.",
        "eg": "\n    $ x=1 2 3 NULL NULL NULL 4 5 6\n    $ x.bfill();\n    [1,2,3,4,4,4,4,5,6]\n\n    $ x=1 2 3 NULL NULL NULL 4 5 6\n    $ x.bfill(1);\n    [1,2,3,,,4,4,5,6]\n\n    $ x.bfill!(2);\n    $ x;\n    [1,2,3,,4,4,4,5,6]\n\n    $ date=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\n    $ sym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\n    $ price=[,,26.56,,50.76]\n    $ qty=[,,4500,5600,6800]\n    $ timestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\n    $ t=table(date,timestamp,sym,price,qty)\n    $ t;\n"
    },
    {
        "title": "bfill!",
        "cal": "bfill!(obj, [limit])",
        "params": "* If obj is a vector: back fill the NULL values in obj with the next non-NULL value.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "bigarray",
        "cal": "bigarray(dataType|template, [initialSize], [capacity], [defaultValue])",
        "params": "`dataType` is the data type for the big array. ",
        "exp": "Big arrays are specially designed for advanced users in big data analysis. Regular arrays use continuous memory. If there is not enough continuous memory, an out of memory exception will occur. A big array consists of many small memory blocks instead of one large block of memory. Therefore big arrays help relieve the memory fragmentation issue. ",
        "eg": "\n    $ x=bigarray(int,10,10000000);\n    $ x;\n    [0,0,0,0,0,0,0,0,0,0]\n\n    // default value is set to 1\n    $ x=bigarray(int,10,10000000,1);\n    $ x;\n    [1,1,1,1,1,1,1,1,1,1]\n\n    $ x=bigarray(int,0,10000000).append!(1..100);\n    $ x[0];\n    1\n    $ sum x;\n    5050\n    $ x[x$ 50&&x<60];\n    [51,52,53,54,55,56,57,58,59]\n\n    $ x=array(double, 40000000);\n    $ typestr x;\n    HUGE DOUBLE VECTOR\n"
    },
    {
        "title": "binaryExpr",
        "cal": "binaryExpr(X, Y, optr)",
        "params": "`X` and `Y` can be a scalar/vector/matrix.",
        "exp": "Connect *X* and *Y* with the binary operator specified in *optr* to generate metacode of a binary expression. You can execute the metacode with function :doc:`../e/eval`.",
        "eg": "\t"
    },
    {
        "title": "binsrch",
        "cal": "binsrch(X, Y)",
        "params": "`X`  must be a vector sorted in ascending order. ",
        "exp": "``binsrch`` means binary search. For each element in Y, ``binsrch`` locates its position in X. If nothing is found, it returns -1(s). ",
        "eg": "\n    $ 1..100 binsrch 12 6 88 102;\n    [11,5,87,-1]"
    },
    {
        "title": "bitAnd",
        "cal": "bitAnd(X, Y) or X & Y",
        "params": "`X` AND `Y` are vectors with the same size, or Y is a scalar.",
        "exp": "Return the result of the `bitAnd` operation. ",
        "eg": "\n    $ x=1 0 1;\n    $ y=0 1 1;\n    $ x&y;\n    [0,0,1]"
    },
    {
        "title": "bitNot",
        "cal": "bitNot(X)",
        "params": "`X` is a numeric scalar/vector/matrix/table.",
        "exp": "Return the result of a bitwise logical NOT operation.",
        "eg": "\n    $ bitNot(3)\n    -4\n\n    $ av = array(INT[], 0, 10).append!([1 2 3, 4 5])\n    $ bitNot(av)\n    [[-2,-3,-4],[-5,-6]]"
    },
    {
        "title": "bitOr",
        "cal": "bitOr(X, Y) or X | Y",
        "params": "`X` AND `Y` are vectors with the same size, or Y is a scalar. ",
        "exp": "Return the result of the `bitOr` operation. ",
        "eg": "\n    $ x=1 0 1;\n    $ y=0 1 1;\n    $ x | y;\n    [1,1,1]"
    },
    {
        "title": "bitXor",
        "cal": "bitXor(X, Y) or X ^ Y",
        "params": "`X` AND `Y` are vectors with the same size, or Y is a scalar.",
        "exp": "Return the result of the `bitXOr` operation. ",
        "eg": "\n    $ x=1 0 1;\n    $ y= 0 1 1;\n    $ x^y;\n    [1,1,0]"
    },
    {
        "title": "blob",
        "cal": "blob(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Convert the data type of X to blob.",
        "eg": "\n    $ str=\"hello\"\n    $ blob(str)\n    hello\n\n    $ t=table(1..10 as id, \"A\"+string(1..10) as sym, 2012.01.01..2012.01.10 as date, rand(100.0, 10) as val, rand(uuid(), 10) as uid)\n    $ str=toJson(t)\n    $ blob(str)\n"
    },
    {
        "title": "bool",
        "cal": "bool(X)",
        "params": "`X`  can be of any data type. ",
        "exp": "Convert the input to a boolean value. ",
        "eg": "\n    $ x=bool()\n    $ x;        \n    00b          \n    $ typestr x\n    BOOL              \n\n    $ bool(`true`false)\n    [1,0]        \n\n    $ bool(100.2)   \n    1\n\n    $ bool(0)        \n    0                  "
    },
    {
        "title": "bucket",
        "cal": "bucket(vector, dataRange, bucketNum, [includeOutbound=false])",
        "params": "`vector` a numeric or temporal vector. ",
        "exp": "Return a vector with the same length as the input vector. Each element of the result indicates which bucket each of the elements of the input vector belongs to, based on the bucket classification rules given by dataRange and bucketNum.",
        "eg": "\n    $ bucket(9 23 54 36 46 12, 12:54, 2);\n    [,0,,1,1,0]\n\n    $ bucket(9 23 54 36 46 12, 12:54, 2, 1);\n    [0,1,3,2,2,1]    \n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "title": "bucketCount",
        "cal": "bucketCount(vector, dataRange, bucketNum, [includeOutbound=false])",
        "params": "`vector` a numeric or temporal vector. ",
        "exp": "Accept the same set of parameters as the function  :doc:`bucket`  and return the count for each bucket. ",
        "eg": "\n    $ bucketCount(9 23 54 36 46 12, 12:54, 2);\n    [2,2]\n\n    $ bucketCount(9 23 54 36 46 12, 12:54, 2, 1);\n    [1,2,2,1]\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "title": "businessDay",
        "cal": "businessDay(X, [offset], [n=1])",
        "params": "`X`  is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "If X is a business day (Monday to Friday), return date(X). Otherwise, return the most recent business day.",
        "eg": "\n    $ businessDay(2019.01.06);\n    2019.01.04\n\n    $ businessDay(2019.01.04);\n    2019.01.04\n\n    $ date=2019.01.06 + 1..10\n    $ businessDay = businessDay(date)\n    $ businessDay2 = businessDay(date,min(date),2)\n    $ table(date, businessDay, businessDay2);\n"
    },
    {
        "title": "businessMonthBegin",
        "cal": "businessMonthBegin(X, [offset], [n=1])",
        "params": "`X`  is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first business day (Monday to Friday) of the month that X belongs to.",
        "eg": "\n    $ businessMonthBegin(2018.09.12);\n    2018.09.03\n\n    $ businessMonthBegin(2018.09.12, 2018.07.12, 3);\n    2018.07.02\n\n    $ date=2016.04.12+(1..10)*30\n    $ time = take(09:30:00, 10)\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n    $ t1;\n"
    },
    {
        "title": "businessMonthEnd",
        "cal": "businessMonthEnd(X, [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the last business day (Monday to Friday) of the month that X belongs to.",
        "eg": "\n    $ businessMonthEnd(2010.10.12);\n    2010.10.29\n\n    $ businessMonthEnd(2010.10.12, 2000.03.31, 3);\n    2010.12.31\n\n    $ date=2016.04.12+(1..10)*30\n    $ time = take(09:30:00, 10)\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n    $ t1;\n"
    },
    {
        "title": "businessQuarterBegin",
        "cal": "businessQuarterBegin(X, [startingMonth=1], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first business day (Monday to Friday) of the quarter that X belongs to. The first months of the quarters are determined by startingMonth. Note that startingMonth=1 is equivalent to startingMonth=4, 7 or 10.",
        "eg": "\n    $ businessQuarterBegin(2012.06.12);\n    2012.04.02\n\n    $ businessQuarterBegin(2012.06.12, 3);\n    2012.06.01\n\n    $ businessQuarterBegin(2012.06.12, 8, 2011.08.01, 3);\n    2012.05.01\n\n    $ date=2011.04.25+(1..10)*90\n    $ time = take(09:30:00, 10)\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ t1;\n    "
    },
    {
        "title": "businessQuarterEnd",
        "cal": "businessQuarterEnd(X, [endingMonth=12], [offset], [n=1])",
        "params": "`X`  is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the last day of the quarter that X belongs to. The last months of the quarters are determined by endingMonth. Note that endingMonth=3 is equivalent to endingMonth=6, 9 or 12.",
        "eg": "\n    $ businessQuarterEnd(2012.04.12);\n    2012.06.30\n\n    $ businessQuarterEnd(2012.04.12, 2);\n    2012.05.31\n\n    $ businessQuarterEnd(2012.04.12, 8, 2011.08.01, 3);\n    2012.05.31\n\n    $ date=2011.04.25+(1..10)*90\n    $ time = take(09:30:00, 10)\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ t1;\n"
    },
    {
        "title": "businessYearBegin",
        "cal": "businessYearBegin(X, [startingMonth=1], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first business day (Monday to Friday) of the year that X belongs to and that starts in the month of startingMonth.",
        "eg": "\n    $ businessYearBegin(2012.06.12);\n    2012.01.02\n\n    $ businessYearBegin(2012.06.13 10:10:10.008,5);\n    2012.05.01\n\n    $ date=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\n    $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ select avg(price),sum(qty) from t1 group by businessYearBegin(date,1,2011.10.01,2)\n"
    },
    {
        "title": "businessYearEnd",
        "cal": "businessYearEnd(X, [endingMonth=12], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the last business day (Monday to Friday) of the year that X belongs to and that ends in the month of endingMonth.",
        "eg": "\n    $ businessYearEnd(2012.06.12, 3);\n    2013.03.29\n\n    $ businessYearEnd(2012.06.12, 9);\n    2012.09.28\n\n    $ businessYearEnd(2012.06.12);\n    2012.12.31\n\n    $ businessYearEnd(2012.06.12, 12, 2009.04.03, 2);\n    2013.12.31\n\n    $ date=2011.04.25+(1..10)*365\n    $ time = take(09:30:00, 10)\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ t1;\n"
    },
    {
        "title": "byRow",
        "cal": "byRow(func, X)",
        "params": "`func` is either a vector function (both input and output are vectors of equal length) or an aggregate function.",
        "exp": "Apply the specified function to each row of a matrix.",
        "eg": "\n    $ m=matrix(1 1, 2 3, 2 1);\n    $ m;\n"
    },
    {
        "title": "cacheDS!",
        "cal": "cacheDS!(ds)",
        "params": "`ds` is a data source or a list of data sources.",
        "exp": "Instruct the system to cache the data source when it is executed next time. It returns true or false to indicate if this operation is successful.",
        "eg": "\n    $ PTNDB_DIR = \"D:/db_testing\"\n    $ dbName = database(PTNDB_DIR + \"/NYSETAQByName\")\n    $ Trades = dbName.loadTable(`Trades)\n\n    $ ds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\n    $ ds.cacheDS!()        //cache the data\n    $ ds.clearDSCache!()  //clear the cache"
    },
    {
        "title": "cacheDSNow",
        "cal": "cacheDSNow(ds)",
        "params": "`ds` is a data source or a list of data sources.",
        "exp": "Immediately execute and cache the data source. It returns the total number of cached rows.",
        "eg": "\n    $ PTNDB_DIR = \"D:/db_testing\"\n    $ dbName = database(PTNDB_DIR + \"/NYSETAQByName\")\n    $ Trades = dbName.loadTable(`Trades)\n\n    $ ds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\n    $ ds.cacheDSNow()        //cache the data immediately\n    $ ds.clearDSCacheNow()  //clear the cache immediately\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
        "title": "cachedTable",
        "cal": "cachedTable(updateFunc, retentionSeconds)",
        "params": "`updateFunc`  is a function without parameters. It must return a table. ",
        "exp": "Create a special type of in-memory table: cached table. When querying the cached table, if the length of time since the last update exceeds a specified value,",
        "eg": "This example defines a unary function, ``f1``, and fixes its argument to produce a partial application with no arguments, ``f1{t}``. ``f1{t}`` is passed as the *updateFunc* to ``cachedTable``.\n"
    },
    {
        "title": "call",
        "cal": "call(func, args...)",
        "params": "`func`  is a function.",
        "exp": "Call a function with the specified parameters. It is often used with function :doc:`each </Functionalprogramming/TemplateFunctions/each>`/:doc:`peach </Functionalprogramming/TemplateFunctions/peach>` or :doc:`loop </Functionalprogramming/TemplateFunctions/loop>`/:doc:`ploop </Functionalprogramming/TemplateFunctions/ploop>` to call multiple functions.",
        "eg": "\n    $ call(sum, 1..10);\n    55\n    // equivalent to sum(1..10)\n\n    $ each(call, [avg, sum], [0..10, 0..100]);\n    [5,5050]\n\n    $ each(call{, 1..3},(sin,log));\n    // note that call{, 1..3} is a partial application.\n"
    },
    {
        "title": "cancelConsoleJob",
        "cal": "cancelConsoleJob(rootJobId)",
        "params": "`rootJobId` is the job ID(s). It is a STRING scalar or vector. If it is a vector, multiple jobs are canceled at the same time.",
        "exp": "Cancel a submitted but unfinished interactive job. To cancel batch jobs, use :doc:`cancelJob`.",
        "eg": "In a session of a data node, enter the following:\n"
    },
    {
        "title": "cancelJob",
        "cal": "cancelJob(jobId)",
        "params": "`jobId` is the batch job ID(s). It is a STRING scalar or vector. If it is a vector, multiple batch jobs are canceled at the same time.",
        "exp": "Cancel a submitted but unfinished batch job.",
        "eg": "\n    $ def writeData(num){\n    $    n=10\n    $    month=take(2000.01M..2016.12M, n)\n    $    x=rand(1.0, n)\n    $    tt=table(month, x)\n    $    if(existsDatabase(\"dfs://test_db\")){\n    $        dropDatabase(\"dfs://test_db\")\n    $    }\n    $    db=database(\"dfs://test_db\", VALUE, 2000.01M..2016.12M)\n    $    pt = db.createPartitionedTable(tt, `pt, `month)\n    $    for(x in 1..num){\n    $        pt.append!(tt)\n    $        sleep(1000)\n    $    }\n    $ }\n\n    $ myJobId=\"writeData\"+temporalFormat(datetime(now()),\"yyyyMMddHHmmss\")\n    $ submitJob(myJobId,\"write data to dfs table\",writeData,120);\n    $ cancelJob(myJobId);\n"
    },
    {
        "title": "cancelRebalanceTask",
        "cal": "cancelRebalanceTask(taskId)",
        "params": "`taskId` is a STRING scalar or vector indicating the job ID of the replica recovery task. It can be obtained with function :doc:`../../FunctionReferences/g/getRecoveryTaskStatus` .",
        "exp": "Cancel the rebalance jobs that have been submitted but have not begun execution. This command can only be executed by an administrator on a controller.",
        "eg": ""
    },
    {
        "title": "cancelRecoveryTask",
        "cal": "cancelRecoveryTask(taskId)",
        "params": "`taskId` is a STRING scalar or vector indicating the job ID of the replica recovery task. It can be obtained with function :doc:`../../FunctionReferences/g/getRecoveryTaskStatus` .",
        "exp": "Cancel the replica recovery jobs that have been submitted but have not begun execution. This command can only be executed by an administrator on a controller.",
        "eg": ""
    },
    {
        "title": "cast",
        "cal": "cast(X, Y) or X $ Y",
        "params": "`X` can be of any data form.",
        "exp": "* convert a data type to another",
        "eg": "\n    $ x=8.9$INT;\n    $ x;\n    9\n\n    $ x=1..10;\n    $ x;\n    [1,2,3,4,5,6,7,8,9,10]\n    $ typestr x;\n    FAST INT VECTOR\n    $ x/2;\n    [0,1,1,2,2,3,3,4,4,5]\n    $ x=x$DOUBLE;\n    $ typestr x;\n    FAST DOUBLE VECTOR\n    $ x/2;\n    [0.5,1,1.5,2,2.5,3,3.5,4,4.5,5]\n\n    $ x=`IBM`MS;                \n    $ typestr x;\n    STRING VECTOR\n    $ x=x$SYMBOL;\n    $ typestr x;\n    FAST SYMBOL VECTOR\n\n    $ x=`128.9;                        \n    $ typestr x;\n    STRING\n    $ x=x$INT;                        \n    $ x;\n    128\n    $ typestr x;\n    INT\n\n    // convert a vector to a matrix\n    $ m=1..8$2:4;                    \n    $ m;      \n"
    },
    {
        "title": "cbrt",
        "cal": "cbrt(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the square root of X. The data type of the result is always DOUBLE. ",
        "eg": "\n    $ cbrt(8);\n    2\n\n    $ cbrt(8 12 16);\n    [2,2.289428,2.519842]\n\n    $ cbrt(1..6$2:3);\n    "
    },
    {
        "title": "cdfBeta",
        "cal": "cdfBeta(alpha, beta, X)",
        "params": "The shape parameters `alpha` and `beeta`  are positive floating numbers.",
        "exp": "Return the value of the cumulative distribution function of a beta distribution. ",
        "eg": "\n    $ cdfBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n    [0, 0.116056, 0.976416]\n\n    $ cdfBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.002451, 0.032995, 0.116056, 0.280532, 0.597694]\n\n\n\n\n"
    },
    {
        "title": "cdfBinomial",
        "cal": "cdfBinomial(trials, p, X)",
        "params": "`trials` is a positive integer.",
        "exp": "Return the value of the cumulative distribution function of a binomial distribution. ",
        "eg": "\n    $ cdfBinomial(10, 0.1, [1, 5, 9]);\n    [0.736099, 0.999853, 1]\n\n    $ cdfBinomial(12,0.627, [1, 3, 5, 7, 9]);\n    [0.000154, 0.009085, 0.114844, 0.483879, 0.88373]\n\n\n\n\n"
    },
    {
        "title": "cdfChiSquare",
        "cal": "cdfChiSquare(df, X)",
        "params": "`df`  is a positive integer indicating the degree of freedom of a chi-squared distribution.",
        "exp": "Return the value of the cumulative distribution function of a chi-squared distribution. ",
        "eg": "\n    $ cdfChiSquare(1, [-1, 0, 0.5, 1, 2]);\n    [0, 0, 0.5205, 0.682689, 0.842701]\n\n    $ cdfChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.24817, 0.416118, 0.5205, 0.597216, 0.657218]\n\n\n\n"
    },
    {
        "title": "cdfExp",
        "cal": "cdfExp(mean, X)",
        "params": "`mean`  is the mean of an exponential distribution.",
        "exp": "Return the value of the cumulative distribution function of an exponential distribution. ",
        "eg": "\n    $ cdfExp(1, [-1, 0, 0.5, 1, 2]);\n    [0, 0, 0.393469, 0.632121, 0.864665]\n\n    $ cdfExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.095163, 0.259182, 0.393469, 0.503415, 0.59343]\n\n\n\n"
    },
    {
        "title": "cdfF",
        "cal": "cdfF(numeratorDF, denominatorDF, X)",
        "params": "`numeratorDF` and `denominatorDF` are positive integers indicating degrees of freedom of an F distribution. ",
        "exp": "Return the value of the cumulative distribution function of an F distribution. ",
        "eg": "\n    $ cdfF(2.31, 0.627, [0.001, 0.5, 0.999]);\n    [0.000444, 0.245679, 0.35098]\n\n    $ cdfF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.07078, 0.176153, 0.245679, 0.295996, 0.334766]\n\n\n"
    },
    {
        "title": "cdfGamma",
        "cal": "cdfGamma(shape, scale, X)",
        "params": "The shape parameter `shape` is a positive floating number.",
        "exp": "Return the value of the cumulative distribution function of a gamma distribution. ",
        "eg": "\n    $ cdfGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n    [0, 0.127367, 0.38032]\n\n    $ cdfGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.004754, 0.048388, 0.127367, 0.225351, 0.329391]\n\n"
    },
    {
        "title": "cdfKolmogorov",
        "cal": "cdfKolmogorov(X)",
        "params": "`X` is a numeric scalar or vector.",
        "exp": "Return the value of the cumulative distribution function of a Kolmogorov distribution. ",
        "eg": "\n    $ cdfKolmogorov([0.1, 0.3, 0.5, 0.7, 0.9]);\n    [1, 0.999991, 0.963945, 0.711235, 0.392731]\n\n    $ cdfKolmogorov([1,2,3]);\n    [0.27, 0.000671, 3.045996E-8]"
    },
    {
        "title": "cdfLogistic",
        "cal": "cdfLogistic(mean, s, X)",
        "params": "`mean`  is the mean of a logistic distribution.",
        "exp": "Return the value of the cumulative distribution function of a logistic distribution. ",
        "eg": "\n    $ cdfLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n    [0.052812, 0.03895, 0.052812, 0.071241, 0.028617]\n\n\n"
    },
    {
        "title": "cdfNormal",
        "cal": "cdfNormal(mean, stdev, X)",
        "params": "`mean` is the mean of a normal distribution.",
        "exp": "Return the value of the cumulative distribution function of a normal distribution. ",
        "eg": "\n    $ cdfNormal(0,1,-2.33);\n    0.009903\n\n    $ cdfNormal(10, 20, -30);\n    0.02275\n\n\n\n"
    },
    {
        "title": "cdfPoisson",
        "cal": "cdfPoisson(mean, X)",
        "params": "`mean` is the mean of a Poisson distribution.",
        "exp": "Return the value of the cumulative distribution function of a Poisson distribution. ",
        "eg": "\n    $ cdfPoisson(1, [-1, 0, 1, 2, 3]);\n    [0, 0.367879, 0.735759, 0.919699, 0.981012]\n\n    $ cdfPoisson(1, [1, 3, 5, 7, 9]);\n    [0.735759, 0.981012, 0.999406, 0.99999, 1]\n\n\n\n\n\n"
    },
    {
        "title": "cdfStudent",
        "cal": "cdfStudent(df, X)",
        "params": "`df` is a positive floating number indicating the degree of freedom of a Student's t-distribution.",
        "exp": "Return the value of the cumulative distribution function of a Student's t-distribution. ",
        "eg": "\n    $ cdfStudent(1, [-1, 0, 0.5, 1, 2]);\n    [0.25, 0.5, 0.647584, 0.75, 0.852416]\n\n    $ cdfStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.531726, 0.592774, 0.647584, 0.6944, 0.733262]\n\n"
    },
    {
        "title": "cdfUniform",
        "cal": "cdfUniform(lower, upper, X)",
        "params": "`lower` and `upper` are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.",
        "exp": "Return the value of the cumulative distribution function of a continuous uniform distribution. ",
        "eg": "\n    $ cdfUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n    [0, 0, 0.221034]\n\n    $ cdfUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0, 0, 0, 0.043375, 0.16221]\n\n\n"
    },
    {
        "title": "cdfWeibull",
        "cal": "cdfWeibull(alpha, beta, X)",
        "params": "The scale parameter `alpha` and `beta` are both positive floating numbers. ",
        "exp": "Return the value of the cumulative distribution function of a Weibull distribution. ",
        "eg": "\n    $ cdfWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n    [0, 0.447241, 0.946762]\n\n    $ cdfWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n    [0.014295, 0.166535, 0.447241, 0.724646, 0.90021]\n\n\n\n"
    },
    {
        "title": "cdfZipf",
        "cal": "cdfZipf(num, exponent, X)",
        "params": "`num`  is a positive integer.",
        "exp": "Return the value of the cumulative distribution function of a Zipfian distribution. ",
        "eg": "\n    $ cdfZipf(10, 0.5, [1, 3, 5, 7, 9]);\n    [0.199164, 0.454981, 0.643631, 0.800216, 0.937019]\n\n\n\n\n\n"
    },
    {
        "title": "ceil",
        "cal": "ceil(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Functions :doc:`../f/floor` and :doc:`ceil` map a real number to the largest previous and the smallest following integer, respectively. Function :doc:`../r/round` maps a real number to the largest previous or the smallest following integer with the round half up rule.",
        "eg": "\n    $ ceil(2.1);\n    3\n    $ ceil(2.9);\n    3\n    $ ceil(-2.1);\n    -2\n\n    $ floor(2.1);\n    2\n    $ floor(2.9);\n    2\n    $ floor(-2.1);\n    -3\n\n    $ round(2.1);\n    2\n    $ round(2.9);\n    3\n    $ round(-2.1);\n    -2\n\n    $ m = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\n    $ m;\n"
    },
    {
        "title": "cell",
        "cal": "cell(obj, row, col)",
        "params": "`obj` is a matrix/table. ",
        "exp": "Return a scalar that is the value of the specified cell: obj[row, col]. The ``cell`` function runs generally faster than obj[row, col].",
        "eg": "\n    $ x=(1..6).reshape(3:2);\n    $ x;\n"
    },
    {
        "title": "cells",
        "cal": "cells(obj, row, col)",
        "params": "`obj` is a matrix.",
        "exp": "Return a vector of cells in a matrix by the specified row and column index.",
        "eg": "\n    $ m=(1..15).reshape(3:5)\n    $ m;\n"
    },
    {
        "title": "changePwd",
        "cal": "changePwd(oldPwd, newPwd)",
        "params": "`oldPwd` a string indicating the current password for the user.",
        "exp": "Change password. This can only be executed on the controller.",
        "eg": "\n    $ changePwd(`LTmp4389, `T5139pm);"
    },
    {
        "title": "char",
        "cal": "char(X)",
        "params": "`X`  can be of any data type.",
        "exp": "Convert the input to the data type of CHAR.",
        "eg": "  \n   $ x=char();\n   $ x;\n   00c\n   $ typestr x;\n   CHAR\n\n   $ a=char(99);\n   $ a;\n   'c'\n   $ typestr a;\n   CHAR\n   $ char(a+5);\n   'h'"
    },
    {
        "title": "charAt",
        "cal": "charAt(X, Y)",
        "params": "`X` is a STRING scalar/vector.",
        "exp": "Return the character in X at the position specified by Y. The result is a scalar/vector of data type CHAR.",
        "eg": "  \n   $ s=charAt(\"abc\",2);\n   $ s;\n   'c'\n\n   $ typestr(s);\n   CHAR\n\n   $ charAt([\"hello\",\"world\"],[3,4]);\n   ['l','d']"
    },
    {
        "title": "chiSquareTest",
        "cal": "chiSquareTest(X, [Y])",
        "params": "`X`   is a numeric vector/matrix/table.",
        "exp": "If X is a vector, conduct a Chi-squared goodness of fit test whether X and Y follow the same distribution.",
        "eg": "Example 1. X is a vector.\n"
    },
    {
        "title": "cholesky",
        "cal": "cholesky(obj, [lower=true])",
        "params": "`obj`  is a symmetric positive definite matrix.",
        "exp": "Conduct Cholesky decomposition of a symmetric positive-definite matrix.",
        "eg": "  \n   $ m=[1, 0, 1, 0, 2, 0, 1, 0, 3]$3:3\n   $ L=cholesky(m);\n   $ L;\n"
    },
    {
        "title": "cj",
        "cal": "cj(X, Y)",
        "params": "`X` and `Y` are tables.",
        "exp": "Perform a cross join between two tables and returns their Cartesian product. If X has n rows and Y has m rows, then cj(X,Y) has n*m rows.",
        "eg": "  \n   $ a=table(1..3 as x,`IBM`C`AAPL as y)\n   $ b=table(172.3 25 106.5 as z)\n   $ c=cj(a,b);\n   $ c;\n"
    },
    {
        "title": "cleanOutdateLogFiles",
        "cal": "cleanOutdateLogFiles([retentionTime=30])",
        "params": "`retentionTime` is the amount of time to keep a log file. The default value is 30 (in days).",
        "exp": "Call this command to remove the log files kept for over *retentionTime*.",
        "eg": ""
    },
    {
        "title": "clear!",
        "cal": "clear!(X)",
        "params": "`X`  is a vector/matrix/set/dictionary.",
        "exp": "Clear the contents of X. After execution X still exists. It retains its initial data type and can be appended with new data.",
        "eg": "  \n   $ x=1 2 3;\n   $ clear!(x);\n   []\n   $ typestr x;\n   FAST INT VECTOR\n   $ size x;\n   0\n   $ x.append!(1..6);\n   [1,2,3,4,5,6]\n\n   $ y=set(8 9 4 6);\n   $ y.clear!();\n   set()\n\n   $ x=1..3;\n   $ y=4..6;\n   $ z=dict(x,y);\n   $ z;\n   3->6\n   1->4\n   2->5\n   $ z.clear!();"
    },
    {
        "title": "clearAllCache",
        "cal": "clearAllCache()",
        "params": "None",
        "exp": "Clear the following cached data:",
        "eg": "\n    $ clearAllCache();"
    },
    {
        "title": "clearCachedModules",
        "cal": "clearCachedModules()",
        "params": "None",
        "exp": "Clear all cached modules. After updating a module, execute this command to clear the cached module data. When you call the module via ``use``, the system reloads it from the module file instead of using the cached data, and there is no need to restart the node.",
        "eg": "Define a module.\n"
    },
    {
        "title": "clearDSCache!",
        "cal": "clearDSCache!(ds)",
        "params": "`ds` is a data source or a list of data sources.",
        "exp": "Instruct the system to clear the cache after the next time the data source is executed.",
        "eg": "  \n   $ PTNDB_DIR = \"D:/db_testing\"\n   $ dbName = database(PTNDB_DIR + \"/NYSETAQByName\")\n   $ Trades = dbName.loadTable(`Trades)\n   \n   $ ds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\n   $ ds.cacheDS!()        //cache the data\n   $ ds.clearDSCache!()  //clear the cache"
    },
    {
        "title": "clearDSCacheNow",
        "cal": "clearDSCacheNow(ds)",
        "params": "`ds` is a data source or a list of data sources.",
        "exp": "Immediately clear the data source and cache.",
        "eg": "  \n   $ PTNDB_DIR = \"D:/db_testing\"\n   $ dbName = database(PTNDB_DIR + \"/NYSETAQByName\")\n   $ Trades = dbName.loadTable(`Trades)\n   \n   $ ds=sqlDS(<select Time,Exchange,Symbol,Trade_Volume as Vol, Trade_Price as Price from Trades>)\n   $ ds.cacheDSNow()        //cache the data immediately\n   $ ds.clearDSCacheNow()  //clear the cache immediately"
    },
    {
        "title": "clearTablePersistence",
        "cal": "clearTablePersistence(table)",
        "params": "`table` is a table object.",
        "exp": "Disable a table's persistence to disk, then delete the content of the table on disk. The table structure remains.",
        "eg": "\n    $ colName=[\"time\",\"x\"]\n    $ colType=[\"timestamp\",\"int\"]\n    $ t = streamTable(100:0, colName, colType);\n    $ enableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\n    $ go;\n"
    },
    {
        "title": "close",
        "cal": "close(X)",
        "params": "`X` is a file handle or a remote call connection.",
        "exp": "Close an opened file handle or a remote call connection. It must be executed by a logged-in user.",
        "eg": "\n    $ fout.writeLine(\"hello world!\");\n    1\n    $ fout.close();\n    $ fin = file(\"test3.txt\");\n    $ print fin.readLine();\n    $ hello world!\n    $ fin.close();"
    },
    {
        "title": "closeSessions",
        "cal": "closeSessions(sessionId)",
        "params": "`sessionId` is a scalar/vector of LONG type indicating one or multiple session IDs.",
        "exp": "Force close one or multiple sessions.",
        "eg": "\n    $ getSessionMemoryStat();\n\n"
    },
    {
        "title": "coevent",
        "cal": "coevent(event, eventTime, window, [orderSensitive=false])",
        "params": "`event`  is a vector indicating events.",
        "exp": "Count the number of occurrences of two events within the specified intervals.",
        "eg": "  \n   $ sensor_id=`A`B`C`D`C`A`B\n   $ time=[2012.06.13T12:30:00,2012.06.13T12:30:02,2012.06.13T12:30:04,2012.06.13T12:30:05,2012.06.13T12:30:06,2012.06.13T12:30:09,2012.06.13T12:30:10];\n\n   $ coevent(sensor_id, time, 2);\n"
    },
    {
        "title": "col",
        "cal": "col(obj, index)",
        "params": "`obj` is a vector/matrix/table.",
        "exp": "Return a column of a vector/matrix/table. Please check related function: :doc:`../r/row`.",
        "eg": "  \n   $ x=1..6$3:2;\n   $ x;\n"
    },
    {
        "title": "cols",
        "cal": "cols(X)",
        "params": "`X`  is a vector/matrix/table.  ",
        "exp": "Return the total number of columns in X. Please check related function: :doc:`../r/rows`.  ",
        "eg": "  \n   $ x=1..6$2:3;\n   $ x;\n"
    },
    {
        "title": "columnNames",
        "cal": "columnNames(X)",
        "params": "`X`  is a matrix/table.  ",
        "exp": "Return the column names of X as a vector. Please check related function: :doc:`../r/rowNames`.",
        "eg": "  \n   $ x=1..6$2:3;\n   $ x;\n"
    },
    {
        "title": "complex",
        "cal": "complex(X, Y)",
        "params": "`X` and `Y` are numeric scalars, pairs, vectors or matrices. They can be of integral (compress or INT128 not included) or floating type.",
        "exp": "Create a complex number X+Y*i. The length of a complex number is 16 bytes. The low 8 bytes are stored in *X*, and the high 8 bytes are stored in *Y*.",
        "eg": "  \n   $ complex(2, 5)\n   2.0+5.0i\n\n   $ a=1.0 2.3\n   $ b=3 4\n   $ complex(a,b)\n"
    },
    {
        "title": "compress",
        "cal": "compress(X, [method='lz4'])",
        "params": "`X` is a vector or a table.",
        "exp": "Compress a vector or a table (since version 1.30.6) with the specified compression algorithm. The compressed vector needs to be decompressed with function :doc:`../d/decompress` before it can be used in a calculation.",
        "eg": "  \n   $ x=1..100000000\n   $ y=compress(x, \"delta\");\n\n   $ y.typestr();\n   HUGE COMPRESS VECTOR\n\n   $ select name, bytes from objs() where name in `x`y;\n"
    },
    {
        "title": "concat",
        "cal": "concat(X, Y)",
        "params": "`X` can be a STRING/CHAR scalar or vector.",
        "exp": "If *X* is a STRING/CHAR scalar",
        "eg": ""
    },
    {
        "title": "concatDateTime",
        "cal": "concatDateTime(date, time)",
        "params": "`date` is a scalar/vector of data type DATE.",
        "exp": "Combine date and time into one new variable.",
        "eg": "  \n   $ concatDateTime(2019.06.15,13:25:10);\n   2019.06.15T13:25:10\n\n   $ concatDateTime(2019.06.15,[13:25:10, 13:25:12, 13:25:13]);\n   [2019.06.15T13:25:10,2019.06.15T13:25:12,2019.06.15T13:25:13]\n\n   $ date=[2019.06.18, 2019.06.20, 2019.06.21, 2019.06.19, 2019.06.18, 2019.06.20]\n   $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26]\n   $ sym = `C`MS`MS`MS`IBM`IBM$SYMBOL\n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23\n   $ qty = 2200 1900 2100 3200 6800 5400\n   $ t = table(date, time, sym, qty, price);\n\n   $ select concatDateTime(date,time) as datetime, sym, qty, price from t;\n"
    },
    {
        "title": "concatMatrix",
        "cal": "concatMatrix(X, [horizontal=true]) ",
        "params": "`X` is a tuple of multiple matrices.",
        "exp": "Concatenate the matrices vertically or horizontally.",
        "eg": "  \n   $ m1 = matrix(4 0 5, 2 1 8);\n   $ m2 = matrix(2 9 8, 3 7 -3, 6 4 2, 0 5 8);\n   $ m3 = matrix(1 -1 6 2, 1 -3 1 9, 5 3 0 -4, 1 NULL 3 4);\n   $ concatMatrix([m1, m2]);\n"
    },
    {
        "title": "conditionalFilter",
        "cal": "conditionalFilter(X, condition, filterMap)",
        "params": "`X`   is a scalar/vector.",
        "exp": "Return true if both of the following conditions are satisfied, otherwise return false.",
        "eg": "Example 1:\n"
    },
    {
        "title": "conditionalIterate",
        "cal": "conditionalIterate(cond, trueValue, falseIterFunc)",
        "params": "`cond` is a conditional expression or a function with BOOLEAN return values. It must contain fields from the input table. Constants/constant expressions are not supported.",
        "exp": "* As the iterations are performed based on the historical data, the output for the current record is calculated based on the historical results in the output table and X.",
        "eg": "Supposing the iteration is based only on the previous result, for the k-th (k  N+) record, the calculation logic is (where the column factor holds the results):\n\n* cond[k] == truefactor[k] = trueValue\n* cond[k] == falsefactor[k] = falseIterFunc(factor)[k-1]\n\nNote: If *falseIterFunc* is a window function, the iteration is based on multiple previous results."
    },
    {
        "title": "contextCount",
        "cal": "contextCount(X, Y)",
        "params": "`X` and `Y` are vectors of the same length.",
        "exp": "Count the number of positions that are not NULL in both X and Y.",
        "eg": "  \n   $ contextCount(1 2 3, 1 NULL 3)\n   2\n\n   $ contextCount(1..3,true false true)\n   3\n   \n   $ contextCount(1 2 NULL, 1 NULL 3)\n   1\n"
    },
    {
        "title": "contextSum",
        "cal": "contextSum(X, Y)",
        "params": "`X` and `Y` are vectors of the same length.",
        "exp": "Get of positions that are not NULL in both X and Y, and calculate the sum of the elements in X on these positions.",
        "eg": "  \n   $ contextSum(1 2 3 4 5, 2 3 4 5 6)\n   15\n\n   $ contextSum(1..3, true false true)\n   6\n\n   $ contextSum(1 2 NULL, 1 NULL 3)\n   1\n"
    },
    {
        "title": "contextSum2",
        "cal": "contextSum2(X, Y)",
        "params": "`X` and `Y` are vectors of the same length.",
        "exp": "Get of positions that are not NULL in both X and Y, and calculate the sum of squares of the elements in X on these positions.",
        "eg": "  \n   $ contextSum2(1 2 3, 10 NULL 30);\n   10\n\n   $ contextSum2(1 2 3, true false true);\n   14\n"
    },
    {
        "title": "contextby",
        "cal": "contextby(func, funcArgs, groupingCol, [sortingCol])",
        "params": "`func`  is a function.",
        "exp": "Calculate `func(funcArgs)` for each `groupingCol` group. The result is a vector of the same size as each of the input arguments other than `func`. If `func` is an aggregate function, all elements within the same group have identical result. We can use `sortingCol` to sort the within-group data before the calculation.",
        "eg": "\n    $ sym=`IBM`IBM`IBM`MS`MS`MS\n    $ price=172.12 170.32 175.25 26.46 31.45 29.43\n    $ qty=5800 700 9000 6300 2100 5300\n    $ trade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\n    $ contextby(avg, price, sym);\n    [172.563,172.563,172.563,29.113,29.113,29.113]\n\n    $ price avg :X sym;\n    [172.563,172.563,172.563,29.113,29.113,29.113]\n\n    $ price at price>contextby(avg, price,sym);\n    [175.25,31.45,29.43]\n\n    $ price at price>price avg :X sym;\n    [175.25,31.45,29.43]\n\n    $ sym at price>contextby(avg, price,sym);\n    [\"IBM\",\"MS\",\"MS\"]\n\n    $ contextby(wavg, [price, qty], sym);\n    [173.856,173.856,173.856,28.374,28.374,28.374]\n    // calculate volume-weighted average price (vwap)\n\n    $ contextby(ratios, price, sym, trade_date) - 1;\n    [-0.01786,,0.028946,-0.100917,,-0.064229]\n"
    },
    {
        "title": "convertEncode",
        "cal": "convertEncode(str, srcEncode, destEncode)",
        "params": "`str`   is a string scalar/vector.",
        "exp": "Change the encoding of strings. All encoding names must use lowercase.",
        "eg": "  \n   $ convertEncode(\"high-performance time-series database\",\"utf-8\",\"gbk\");\n   high-performance time-series database\n\n   $ convertEncode([\"hello\",\"DolphinDB\"],\"gbk\",\"utf-8\");\n   [\"hello\",\"DolphinDB\"]\n"
    },
    {
        "title": "convertExcelFormula",
        "cal": "convertExcelFormula(formula, colStart, colEnd, rowStart, rowEnd)",
        "params": "`formula` is a string scalar/vector indicating an Excel formula.",
        "exp": "Convert Excel formula to DolphinDB expressions.",
        "eg": "\n   $ convertExcelFormula(\"A2+B2\", \"A\", \"Z\", 2, 10);\n   col0+col1\n\n   $ convertExcelFormula(\"SUM(A2:C2)\", \"A\", \"Z\", 2, 10);\n   rowSum(col0, col1, col2)\n\n   $ convertExcelFormula(\"SUM(A2)\", \"A\", \"Z\", 2, 10);\n   cumsum(col0)\n\n   $ convertExcelFormula(\"SUM(A2:A5)\", \"A\", \"Z\", 2, 10);\n   msum(col0, 4)\n\n   $ convertExcelFormula(\"SUM(A2:A10)\", \"A\", \"Z\", 2, 10);\n   sum(col0)\n\n   $ convertExcelFormula([\"=SUM(A1:A10)\",\"IF(A1>0,B1,0\"], \"A\", \"D\", 1, 10)\n   [\"sum(col0)\",\"iif(col0>0,col1,0)\"]"
    },
    {
        "title": "convertTZ",
        "cal": "convertTZ(obj, srcTZ, destTZ)",
        "params": "`obj`   is a temporal variable/vector. The data type of obj can be datetime, timestamp, or nanotimestamp.",
        "exp": "Convert obj from time zone srcTZ to time zone destTZ. Daylight saving time is considered in time zone conversion.",
        "eg": "  \n   $ convertTZ(2016.04.25T08:25:45,\"US/Eastern\",\"Asia/Shanghai\");\n   2016.04.25T20:25:45\n"
    },
    {
        "title": "copy",
        "cal": "copy(X)",
        "params": "`X`  can be of any data type.",
        "exp": "Return a copy of X.  ",
        "eg": "  \n   $ x=1 2 3;\n   $ x.copy();\n   [1,2,3]\n"
    },
    {
        "title": "copyReplicas",
        "cal": "copyReplicas(srcNode, destNode, chunkId)",
        "params": "`srcNode` is a string indicating the alias of origination node.",
        "exp": "Copy replicas of one or multiple chunks from a node to another node. If the destination node already has the chunk, the command is skipped.",
        "eg": "Copy replicas of all chunks on \"node1\" to \"node2\".\n"
    },
    {
        "title": "corr",
        "cal": "corr(X,Y)",
        "params": "`X`  and `Y` are vectors of the same size.",
        "exp": "Calculate the correlation of X and Y.",
        "eg": "  \n   $ x = 7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\n   $ y=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\n   $ corr(x,y);\n   0.238769\n"
    },
    {
        "title": "corrMatrix",
        "cal": "corrMatrix(X)",
        "params": "`X` is a matrix.",
        "exp": "Return a correlation matrix, where the (i, j) entry is the correlation between the columns *i* and *j* of X.",
        "eg": "\n   $ m = rand(10.0, 30)$10:3\n   $ corrMatrix(m)\n"
    },
    {
        "title": "cos",
        "cal": "cos(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Apply the function of cos to X.",
        "eg": "\n   $ cos 0 1 2;\n   [1,0.540302,-0.416147]\n"
    },
    {
        "title": "cosh",
        "cal": "cosh(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The hyperbolic cosine function.",
        "eg": "\n   $ cosh 0 1 2;\n   [1,1.543081,3.762196]\n"
    },
    {
        "title": "count",
        "cal": "count(X)",
        "params": "`X` is a scalar/vector/matrix/table.",
        "exp": ":doc:`../s/size` returns the number of elements in a vector/matrix, while count returns the number of non-null elements in a vector/matrix. count can be used in a SQL query, but size cannot. For tables, size and count both return the number of rows. Please also check related function: :doc:`../s/size`.",
        "eg": "  \n   $ count(3 NULL 5 6);\n   3\n   $ size(3 NULL 5 6);\n   4\n\n   $ m=1 2 3 NULL 4 5$2:3;\n   $ m;\n"
    },
    {
        "title": "countNanInf",
        "cal": "countNanInf(X, [includeNull=false]) ",
        "params": "`X` is a DOUBLE type scalar, vector or matrix.",
        "exp": "An aggregate function that counts the number of NaN values and Inf values in *X*. When *includeNull* = true, the result includes the number of NULL values. The default value is false.",
        "eg": ""
    },
    {
        "title": "covar",
        "cal": "covar(X,Y)",
        "params": "`X` and `Y` are vectors of the same size.",
        "exp": "Calculate the covariance of X and Y.",
        "eg": "  \n   $ x=7 4 5 8 9 3 3 5 2 6 12 1 0 -5 32\n   $ y=1.1 7 8 9 9 5 4 8.6 2 1 -9 -3 5 8 13\n   $ covar(x,y);\n   10.881429\n"
    },
    {
        "title": "covarMatrix",
        "cal": "covarMatrix(X)",
        "params": "`X` is a matrix.",
        "exp": "Return a covariance matrix, where the (i, j) entry is the covariance between the columns *i* and *j* of X.",
        "eg": "\n   $ m = rand(10.0, 30)$10:3\n   $ covarMatrix(m)\n"
    },
    {
        "title": "crc32",
        "cal": "crc32(str, [cksum=0])",
        "params": "`str`  is a string scalar/vector.",
        "exp": "Create an CRC32 hash from STRING. The result is of data type INT.",
        "eg": "  \n   $ a=crc32(`aa`cc,1);\n   $ a;\n   [512829590,-1029100744]\n\n   $ typestr(a);\n   FAST INT VECTOR\n"
    },
    {
        "title": "createAsofJoinEngine",
        "cal": "createAsofJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [delayedTime], [garbageSize], [sortByTime])",
        "params": "Create an asof join streaming engine. Streams are ingested into the left table and the right table and joined on :ref:`matchingColumn <mc_aj>` and :ref:`timeColumn <tc_aj>` (or system time). For each record in the left table, join it with the right table record (1) with matching matchingColumn value and (2) whose timestamp is the last of the timestamps that are less than or equal to the timestamp of the left table record. This function returns a table object holding the asof  join results. ",
        "exp": ".. _name_aj:",
        "eg": "  \n   $ share streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as trades\n   $ share streamTable(1:0, `time`sym`bid`ask, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) as quotes\n   $ prevailingQuotes=table(100:0, `time`sym`price`bid`ask`spread, [TIMESTAMP, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE])\n   $ ajEngine=createAsofJoinEngine(name=\"aj1\", leftTable=trades, rightTable=quotes, outputTable=prevailingQuotes, metrics=<[price, bid, ask, abs(price-(bid+ask)/2)]>, matchingColumn=`sym, timeColumn=`time, useSystemTime=false, delayedTime=1)\n   $ tmp1=table(2020.08.27T09:30:00.000+2 8 20 22 as time, take(`A, 4) as sym, 20.01 20.04 20.07 20.08 as price)\n   $ tmp2=table(2020.08.27T09:30:00.000+1 5 6 11 19 as time, take(`A, 5) as sym, 20 20.02 20.03 20.05 20.06 as bid,  20.01 20.03 20.04 20.06 20.07 as ask)\n   $ tmp1.sortBy!(`time)\n   $ tmp2.sortBy!(`time)\n   //can only use appendForJoin to append data\n   $ subscribeTable(tableName=\"trades\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{ajEngine, true}, msgAsTable=true)\n   $ subscribeTable(tableName=\"quotes\", actionName=\"joinRight\", offset=0, handler=appendForJoin{ajEngine, false}, msgAsTable=true)\n\n   $ job1=submitJob(\"write1\", \"\", append!{trades, tmp1})\n   $ job2=submitJob(\"write2\", \"\", append!{quotes, tmp2})\n   $ getJobReturn(job1, true)\n   $ getJobReturn(job2, true)\n\n   $ sleep(1000)\n\n   $ select time, sym, bid from prevailingQuotes order by time, sym\n"
    },
    {
        "title": "createCrossSectionalAggregator",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "createCrossSectionalEngine",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "createDailyTimeSeriesEngine",
        "cal": "createDailyTimeSeriesEngine(name, windowSize, step, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [garbageSize], [updateTime], [useWindowStartTime], [roundTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [fill='none'], [sessionBegin], [sessionEnd], [mergeSessionEnd=false], [forceTriggerTime], [raftGroup], [forceTriggerSessionEndTime])",
        "params": "This function creates a daily time-series streaming engine. The windowing logic and calculation rules of the daily time-series engine are similar to those of the time-series engine, but with some added features:",
        "exp": "The daily time-series engine is an extension of the time-series engine (:doc:`createTimeSeriesEngine`) and inherits all of its parameters. In this section, we will only cover the parameters specific to this engine.",
        "eg": "  \n   $ share streamTable(1000:0, `date`second`sym`volume, [DATE, SECOND, SYMBOL, INT]) as trades\n   $ output1 = keyedTable(`time`sym, 10000:0, `time`sym`sumVolume, [DATETIME, SYMBOL, INT])\n   $ engine1 = createDailyTimeSeriesEngine(name=\"engine1\", windowSize=60, step=60, metrics=<[sum(volume)]>, dummyTable=trades, outputTable=output1, timeColumn=`date`second, useSystemTime=false, keyColumn=`sym, garbageSize=50, updateTime=2, useWindowStartTime=false, sessionBegin=09:30:00 13:00:00, sessionEnd=11:30:00 15:00:00,mergeSessionEnd=true)\n   $ subscribeTable(tableName=\"trades\", actionName=\"engine1\", offset=0, handler=append!{engine1}, msgAsTable=true);\n\n   $ insert into trades values(2018.10.08,09:25:31,`A,8)\n   $ insert into trades values(2018.10.08,09:26:01,`B,10)\n   $ insert into trades values(2018.10.08,09:30:02,`A,26)\n   $ insert into trades values(2018.10.08,09:30:10,`B,14)\n   $ insert into trades values(2018.10.08,11:29:46,`A,30)\n   $ insert into trades values(2018.10.08,11:29:50,`B,11)\n   $ insert into trades values(2018.10.08,11:30:00,`A,14)\n   $ insert into trades values(2018.10.08,11:30:00,`B,4)\n   $ insert into trades values(2018.10.08,13:00:10,`A,16)\n   $ insert into trades values(2018.10.08,13:00:12,`B,9)\n   $ insert into trades values(2018.10.08,14:59:56,`A,20)\n   $ insert into trades values(2018.10.08,14:59:58,`B,20)\n   $ insert into trades values(2018.10.08,15:00:00,`A,10)\n   $ insert into trades values(2018.10.08,15:00:00,`B,29)\n\n   $ sleep(1000)\n   $ select * from output1\n"
    },
    {
        "title": "createDistributedInMemoryTable",
        "cal": "createDistributedInMemoryTable(tableName, colNames, colTypes, globalPartitionType, globalPartitionScheme, globalPartitionColumn, [localPartitionType], [localPartitionScheme], [localPartitionColumn])",
        "params": "Create a distributed in-memory table and store it on different nodes based on the specified partitioning scheme. This function can only be executed on a data node or compute node.",
        "exp": "`tableName` is a STRING scalar indicating the name of a distributed in-memory table.",
        "eg": "* Create a distributed in-memory table\n\nThe cluster in this example has two data nodes: node1 and node2. Create a distributed in-memory table on node1. The number of partitions should be less than the total number of data nodes and compute nodes, thus HASH partitioning is recommended.\n"
    },
    {
        "title": "createDualOwnershipReactiveStateEngine",
        "cal": "createDualOwnershipReactiveStateEngine(name, metrics1, metrics2, dummyTable, outputTable, keyColumn1, keyColumn2, [snapshotDir], [snapshotIntervalInMsgCount], [keyPurgeFilter1], [keyPurgeFilter2], [keyPurgeFreqInSecond=0], [raftGroup])",
        "params": "Only the parameters of ``createDualOwnershipReactiveStateEngine`` and :doc:`createReactiveStateEngine` with different usages are explained here.",
        "exp": "The dual-ownership reactive state streaming engine extends the functionality of the reactive state streaming engine with a support of parallel computing on 2 groups with different metrics of a stream table. Compared to the cascade of reactive state streaming engines, this function has greatly improved the computing performance.",
        "eg": "    \n    $ share streamTable(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) as trades\n    $ outputTable = table(100:0, `date`sym`market`factor1`factor2, [DATE, SYMBOL, CHAR, DOUBLE, DOUBLE])\n    $ dors = createDualOwnershipReactiveStateEngine(name=\"test\", metrics1=<mfirst(price, 3)>, metrics2=<mmax(price, 3)>, dummyTable=trades, outputTable=outputTable, keyColumn1=`date`sym, keyColumn2=`date`market)\n    $ tmp = table(1:0, `date`time`sym`market`price`qty, [DATE, TIME, SYMBOL, CHAR, DOUBLE, INT]) \n    $ subscribeTable(tableName=`trades, actionName=\"test\",msgAsTable=true, handler=tableInsert{dors})\n    $ insert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.65, 1500)\n    $ insert into tmp values(2012.01.01, 09:00:00.030, `a, 'B', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.031, `b, 'A', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.031, `a, 'B', 10.65, 1500)\n    $ insert into tmp values(2012.01.01, 09:00:00.031, `a, 'A', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.033, `b, 'B', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.033, `a, 'A', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.59, 2500)\n    $ insert into tmp values(2012.01.01, 09:00:00.034, `b, 'A', 10.22, 1200)\n    $ insert into tmp values(2012.01.01, 09:00:00.035, `a, 'A', 11.0, 2500)\n    $ insert into tmp values(2012.01.02, 09:00:00.031, `b, 'A', 10.22, 1200)\n    $ insert into tmp values(2012.01.02, 09:00:00.032, `a, 'B', 11.0, 2500)\n    $ insert into tmp values(2012.01.02, 09:00:00.032, `b, 'B', 15.6, 1300)\n    $ insert into tmp values(2012.01.02, 09:00:00.040, `c, 'B', 13.2, 2000)\n    $ trades.append!(tmp)\n    $ select * from outputTable\n"
    },
    {
        "title": "createEqualJoinEngine",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "createEquiJoinEngine",
        "cal": "createEquiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, timeColumn, [garbageSize=5000], [maxDelayedTime])",
        "params": "Create an equi join streaming engine. Streams are ingested into the engine through left and right tables and joined on :ref:`matchingColumn <mc_aj>` and :ref:`timeColumn <tc_ej>`. Return a table object that is the equi join result of a left table and a right table. The result holds all records with matching values.",
        "exp": "When data is ingested into one table, the equi join streaming engine searches for records with matching values in the other table. If matches are found, the engine outputs the combined records with additional columns holding the calculation results of :ref:`metrics <metrics_aj>`.",
        "eg": "Some parameters of the equi join engine are the same as those of the asof join engine, please refer to the function :doc:`createAsofJoinEngine` for detailed information. The different parameters are described as below:\n\n.. _name_ej:\n\n`name` is a string indicating the name of the equal join streaming engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.\n\n.. _tc_ej:\n\n`timeColumn` is a string or a vector of strings indicating the time columns in the left table and the right table. The time columns in the left and right tables must have the same data type. When the two time columns have the same column name, *timeColumn* is a string scalar; otherwise, *timeColumn* is vector of two strings.\n\n`garbageSize` (optional) is a positive integer with the default value of 5,000 (in unit of rows). When the number of rows of historical data in memory exceeds the *garbageSize*, the system will remove the historical data that is not needed for the current calculation on the following conditions:\n\n* The historical data has already been joined and returned.\n\n* For historical data that has not been joined, if the timestamp difference between the historical data and the new arriving data in left/right table has exceeded the *maxDelayedTime*, it will also be discarded.\n\n`maxDelayedTime` is an optional parameter. It is a positive integer with the default value of 3 (seconds), indicating the maximum time to keep cached data in the engine. This parameter only takes effect when the conditions described in *garbageSize* are met. It is not recommended to set the *maxDelayedTime* too small in case data got removed before it is joined."
    },
    {
        "title": "createGroup",
        "cal": "createGroup(groupId, [userIds])",
        "params": "`groupId` a string indicating a group name.",
        "exp": "Create a group of users. This can only be executed by an administrator on the controller.",
        "eg": "Create a group \"production\", and add a user with user name \"JohnSmith\".\n"
    },
    {
        "title": "createIPCInMemoryTable",
        "cal": "createIPCInMemoryTable(size, tableName, columnNames, columnTypes)",
        "params": "`size` is an integer indicating the number of records that can be cached. The specified size must be greater than 1,000,000.",
        "exp": "Create a handle to inter-process communication (IPC) in-memory table. IPC in-memory tables are often used as output tables for streaming. In scenarios with extremely high latency requirements, user processes can directly access shared memory to obtain data through APIs, which greatly reduces the latency of network transmissions such as TCP.",
        "eg": "Create an IPC in-memory table that serves as the output table for subscription.\n"
    },
    {
        "title": "createLeftSemiJoinEngine",
        "cal": "createLeftSemiJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [garbageSize=5000], [updateRightTable=false])",
        "params": "Create a left semi join engine. For each record from the left table, the left semi join engine finds the matching records from the right table, and returns a table of its joining result. Unmatched records will not be returned. ",
        "exp": "`name` is a string indicating the name of the left semi join engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.",
        "eg": "\n    $ share streamTable(1:0, `time`sym`price, [TIMESTAMP, SYMBOL, DOUBLE]) as leftTable \n    $ share streamTable(1:0, `time`sym1`vol, [TIMESTAMP, SYMBOL, INT]) as rightTable\n\n    $ output=table(100:0, `time`sym`price`vol`total, [TIMESTAMP, SYMBOL, DOUBLE, INT, DOUBLE])\n    $ lsjEngine=createLeftSemiJoinEngine(name=\"test1\", leftTable=leftTable, rightTable=rightTable, outputTable=output,  metrics=<[price, vol,price*vol]>, matchingColumn=[[`time,`sym], [`time,`sym1]], updateRightTable=true)\n\n    $ subscribeTable(tableName=\"leftTable\", actionName=\"joinLeft\", offset=0, handler=appendForJoin{lsjEngine, true}, msgAsTable=true)\n    $ subscribeTable(tableName=\"rightTable\", actionName=\"joinRight\", offset=0, handler=appendForJoin{lsjEngine, false}, msgAsTable=true)\n\n    $ v = [1, 5, 10, 15]\n    $ tp1=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 4) as sym, rand(100,4) as price)\n    $ leftTable.append!(tp1)\n\n    $ v = [1, 1, 3, 4, 5, 5, 5, 15]\n    $ tp2=table(2012.01.01T00:00:00.000+v as time, take(`AAPL, 8) as sym, rand(100,8) as vol)\n    $ rightTable.append!(tp2)\n\n    $ select * from output    \n"
    },
    {
        "title": "createLookupJoinEngine",
        "cal": "createLookupJoinEngine(name, leftTable, rightTable, outputTable, metrics, matchingColumn, [rightTimeColumn], [checkTimes])",
        "params": "Create a lookup join streaming engine. The engine left joins two stream tables, or a stream table and a non-stream table (refreshed regularly), on *matchingColumn*. Use this engine when the right table has infrequent updates (e.g., a dimension table with intraday indicators).",
        "exp": "`name` is a string indicating the name of the lookup join engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "createPartitionedTable",
        "cal": "createPartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods], [sortColumns], [keepDuplicates=ALL], [sortKeyMappingFunction])",
        "params": "The parameters *sortColumns*, *keepDuplicates* and *sortKeyMappingFunction* take effect only in a TSDB storage engine (i.e., ``database().engine`` = TSDB).",
        "exp": "Create an empty partitioned table on disk or in memory with the same schema as the specified table. To create a table on disk, parameter table must be a table. To create an in-memory partitioned table, parameter table can be a table or a tuple of tables. ",
        "eg": "Example 1. Create a DFS table \n\nExample 1.1. Create a DFS table in OLAP database\n"
    },
    {
        "title": "createReactiveStateEngine",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "createSessionWindowEngine",
        "cal": "createSessionWindowEngine(name, sessionGap, metrics, dummyTable, outputTable, [timeColumn], [useSystemTime=false], [keyColumn], [updateTime], [useSessionStartTime=true], [snapshotDir], [snapshotIntervalInMsgCount], [raftGroup], [forceTriggerTime])",
        "params": "This function creates a session window streaming engine. The session window engine shares most of its parameters with the time-series engine (:doc:`createTimeSeriesEngine`), but includes two unique parameters: :ref:`sessionGap <sessionGap_sw>` and :ref:`useSessionStartTime <useSessionStartTime_sw>`.",
        "exp": "When records are ingested into a session window, the window remains open until a specified period of inactivity passes (specified by *sessionGap*). The window end is equal to the timestamp of the last received record + the *sessionGap* interval. The calculation of this window is triggered by the arrival of the next record after the window ends.",
        "eg": "As most of the parameters of ``createSessionWindowEngine`` are identical with those of :doc:`createTimeSeriesEngine`, we only explain the following parameters of ``createSessionWindowEngine`` that are different from those of ``createTimeSeriesEngine``.\n\n.. _sessionGap_sw:\n\n`sessionGap` a positive integer indicating the gap between 2 session windows. Its unit is determined by the parameter *useSystemTime*.\n\n.. _useSessionStartTime_sw:\n\n`useSessionStartTime` (optional) a Boolean value indicating whether the first column in *outputTable* is the starting time of the windows, i.e., the timestamp of the first record in each window. Setting it to false means the timestamps in the output table are the ending time of the windows, i.e., timestamp of the last record in window + *sessionGap*. If *updateTime* is specified, *useSessionStartTime* must be true.\n\n.. _forceTriggerTime_sw:\n\n`forceTriggerTime` (optional) a non-negative integer. Its unit is the same as the time precision of *timeColumn*. *forceTriggerTime* indicates the waiting time to force trigger calculation in uncalculated windows for each group."
    },
    {
        "title": "createTable",
        "cal": "createTable(dbHandle, table, tableName, [compressMethods], [sortColumns], [keepDuplicates=ALL])",
        "params": "`dbHandle`  is a distributed database handle.",
        "exp": "This function creates an empty dimension table. A dimension table is a non-partitioned table in a DFS database, used to store small datasets with infrequent updates.",
        "eg": "Example1\n"
    },
    {
        "title": "createTimeSeriesAggregator",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "createUser",
        "cal": "createUser(userId, password, [groupIds], [isAdmin=false])",
        "params": "`userId` a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.",
        "exp": "Create an user. This can only be executed by an administrator on the controller.",
        "eg": "Create a user with user name 'JohnSmith' and password 'Qb0507'. This user belongs to group \"research\" and group \"production. He is not an administrator.\n"
    },
    {
        "title": "createWindowJoinEngine",
        "cal": "createWindowJoinEngine(name, leftTable, rightTable, outputTable, window, metrics, matchingColumn, [timeColumn], [useSystemTime=false], [garbageSize = 5000], [maxDelayedTime], [nullFill], [outputElapsedMicroseconds=false], [sortByTime])",
        "params": "Create a window join streaming engine. Return a table object that is the real-time :doc:`/SQLStatements/TableJoiners/windowjoin` result of a left table and a right table. While the SQL window join only accepts aggregate functions as metrics, the window join streaming engine also supports non-aggregate functions.",
        "exp": "`name` is a string indicating the name of the window join streaming engine. It is the unique identifier of the engine on a data/compute node. It can contain letters, numbers and underscores and must start with a letter.",
        "eg": "`sortByTime` is a Boolean value that indicates whether the output data is globally sorted by time. The default value is false, meaning the output data is sorted only within groups. Note that if *sortByTime* is set to true, the parameter *maxDelayedTime* cannot be specified, and the data input to the left and right tables must be globally sorted."
    },
    {
        "title": "cross",
        "cal": "cross(func, X, [Y])",
        "params": "`func` is a binary function.",
        "exp": "Apply func to the permutation of all individual elements of *X* and *Y* and return a matrix.",
        "eg": "``cross`` with two vectors:\n"
    },
    {
        "title": "crossStat",
        "cal": "crossStat(X, Y)",
        "params": "`X`  and `X` are vectors of the same size.",
        "exp": "Return a tuple with the following elements: sum(isValid(X) && isValid(Y)), sum(X), sum(Y), sum2(X), sum2(Y), sum(X*Y)",
        "eg": "  \n   $ x=1 NULL 2 3\n   $ y=4 3 NULL 2\n   $ crossStat(x,y);\n   (2,4,6,10,20,10)"
    },
    {
        "title": "cumPositiveStreak",
        "cal": "cumPositiveStreak(X)",
        "params": "Cumulatively calculate the sum of consecutive positive elements of *X* after the last non-positive element to the left.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumavg",
        "cal": "cumavg(X)",
        "params": "Calculate the cumulative average of *X*. ",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumavgTopN",
        "cal": "cumavgTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the average of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumbeta",
        "cal": "cumbeta(Y, X)",
        "params": "Cumulatively calculate the coefficient estimate of the regression of Y on X. The result is a vector of the same length as X.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumbetaTopN",
        "cal": "cumbetaTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function obtains the first top pairs of elements in X and Y in a cumulative window and calculates the coefficient estimate ordinary-least-squares regressions of Y on X.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumcorr",
        "cal": "cumcorr(X,Y)",
        "params": "Cumulatively calculate the correlation of X and Y. The result is a vector of the same length as X.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumcorrTopN",
        "cal": "cumcorrTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the correlation of the first top pairs of elements in X and Y in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumcount",
        "cal": "cumcount(X)",
        "params": "Cumulatively calculate the number of non-NULL elements in *X*. ",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumcovar",
        "cal": "cumcovar(X,Y)",
        "params": "Cumulatively calculate the covariance of X and Y. The result is a vector of the same length as X.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumcovarTopN",
        "cal": "cumcovarTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the covariance of the first top pairs of elements in X and Y in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumfirstNot",
        "cal": "cumfirstNot(X, [k])",
        "params": "Return the last element of *X* that is not *k*. If *k* is unspecified, return the last non-NULL element.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumkurtosisTopN",
        "cal": "cumkurtosisTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the kurtosis of the first top elements of X in a cumulative window.",
        "eg": "    \n    $ X=1 2 3 10 100 4 3    \n    $ S = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\n    $ cumkurtosisTopN(X, S, 6, 4)\n    [,,1.5,2.2304,3.2152,4.1525,4.1554]\n    \n    $ X = matrix(1..10, 11..20)\n    $ S = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\n    $ cumkurtosisTopN(X, S, 6, 4)\n    "
    },
    {
        "title": "cumlastNot",
        "cal": "cumlastNot(X, [k])",
        "params": "Return the first element of *X* that is not *k*. If *k* is unspecified, return the first non-NULL element.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cummax",
        "cal": "cummax(X)",
        "params": "Cumulatively calculate the maximum values in *X*. It can be used to calculate maximum drawdown, for example.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cummed",
        "cal": "cummed(X)",
        "params": "Calculate the cumulative median of *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cummin",
        "cal": "cummin(X)",
        "params": "Cumulatively calculate the minimum values in *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumpercentile",
        "cal": "cumpercentile(X, percent, [interpolation='linear'])",
        "params": "`X`   is a vector.",
        "exp": "If X is a vector, cumulatively calculate the given percentile of a vector. The calculation ignores NULL values.",
        "eg": "  \n   $ a=1..10;\n\n   $ cumpercentile(a,25);\n   [1,1.25,1.5,1.75,2,2.25,2.5,2.75,3,3.25]\n\n   $ cumpercentile(a,25,'lower');\n   [1,1,1,1,2,2,2,2,3,3]\n\n   $ cumpercentile(a,25,'higher');\n   [1,2,2,2,2,3,3,3,3,4]\n\n   $ cumpercentile(a,25,'midpoint');\n   [1,1.5,1.5,1.5,2,2.5,2.5,2.5,3,3.5]\n\n   $ cumpercentile(a,25,'nearest');\n   [1,1,1,2,2,2,2,3,3,3]\n\n   $ cumpercentile(a,50.5);\n   [1,1.505,2.01,2.515,3.02,3.525,4.03,4.535,5.04,5.545]\n\n   $ m=matrix(1..10, 11..20);\n   $ m;\n"
    },
    {
        "title": "cumprod",
        "cal": "cumprod(X)",
        "params": "Cumulatively calculate the product of the elements in *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumrank",
        "cal": "cumrank(X, [ascending=true], [ignoreNA=true], [tiesMethod='min'], [percent=false)",
        "params": "`X` is a vector/ matrix.",
        "exp": "If *X* is a vector, for each element in *X*, return the position ranking from the first element to the current element. The result is of the same length as *X*. If `ignoreNA` = true, NULL values return NULL.",
        "eg": "  \n   $ cumrank(1 3 2 3 4);\n   [0,1,1,2,4]\n\n   $ cumrank(1 3 2 2 4 NULL, , true);\n   [0,1,1,1,4,]\n\n   $ cumrank(1 3 2 2 4 NULL, , false);\n   [0,1,1,1,4,0]\n\n   $ cumrank(1 3 2 2 4 NULL, , false, 'max');\n   [0,1,1,2,4,0]\n\n   $ m=matrix(1 4 2 3 4, 4 NULL 6 1 2);\n   $ m;\n"
    },
    {
        "title": "cumskewTopN",
        "cal": "cumskewTopN(X, S, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the skewness of the first top elements of X in a cumulative window.",
        "eg": "    \n    $ X=1 2 3 10 100 4 3    \n    $ S = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\n    $ cumskewTopN(X, S, 6, 4)\n    [,0,0,1.0182,1.4754,1.7635,1.7650]\n    \n    $ X = matrix(1..10, 11..20)\n    $ S = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\n    $ cumskewTopN(X, S, 6, 4)\n    "
    },
    {
        "title": "cumstd",
        "cal": "cumstd(X)",
        "params": "Cumulatively calculate the standard deviation of *X*. ",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumstdTopN",
        "cal": "cumstdTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the standard deviation of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumstdp",
        "cal": "cumstdp(X)",
        "params": "Cumulatively calculate the population standard deviation of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "cumstdpTopN",
        "cal": "cumstdpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the population standard deviation of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumsum",
        "cal": "cumsum(X)",
        "params": "Cumulatively calculate the sum of the elements in *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumsum2",
        "cal": "cumsum2(X)",
        "params": "Cumulatively calculate the sum of squares of the elements in *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumsum3",
        "cal": "cumsum3(X)",
        "params": "Cumulatively calculate the cubes of squares of the elements in *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumsum4",
        "cal": "cumsum4(X)",
        "params": "Cumulatively calculate the fourth powers of the elements in *X*.  ",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumsumTopN",
        "cal": "cumsumTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the sum of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumvar",
        "cal": "cumvar(X)",
        "params": "Cumulatively calculate the variance of *X*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumvarTopN",
        "cal": "cumvarTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the variance of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumvarp",
        "cal": "cumvarp(X)",
        "params": "Cumulatively calculate the population variance of *X*. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "cumvarpTopN",
        "cal": "cumvarpTopN(X, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the population variance of the first top elements of X in a cumulative window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cumwavg",
        "cal": "cumwavg(X, Y)",
        "params": "Calculate the cumulative weighted average of X with Y as the weights. The result is a vector of the same length as X. Null values are ignored in the calculation.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumwsum",
        "cal": "cumwsum(X, Y)",
        "params": "Calculate the cumulative weighted sum of X with Y as the weights. The result is a vector of the same length as X. Null values are ignored in the calculation.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "cumwsumTopN",
        "cal": "cumwsumTopN(X, Y, S, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function obtains the first top pairs of elements in X and Y in a cumulative window and calculates the cumulative weighted sum of X with Y as the weights.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "cut",
        "cal": "cut(X, size|cutPositions)",
        "params": "`X` is a scalar/vector/matrix/table.",
        "exp": "This function divides *X* based on the specified *size* or *cutPositions*, and returns a tuple:",
        "eg": "  \n   $ a=1..10;\n\n   $ cut(a,2);\n   ([1,2],[3,4],[5,6],[7,8],[9,10])\n\n   $ cut(a,3);\n   ([1,2,3],[4,5,6],[7,8,9],[10])\n\n   $ cut(a,9);  \n   ([1,2,3,4,5,6,7,8,9],[10])\n\n   $ b = cut(a,2);\n   $ b;\n   ([1,2],[3,4],[5,6],[7,8],[9,10])\n\n   $ flatten b;\n   (1,2,3,4,5,6,7,8,9,10)\n\n   $ cut(a, 0 2 7);\n   ([1,2],[3,4,5,6,7],[8,9,10])\n\n   $ cut(a, 2 7);\n   ([3,4,5,6,7],[8,9,10])\n\n   $ m=matrix(1 5 9, 12 20 23, 25 29 32)\n   $ cut(m,2)\n\n   (#0 #1\n   -- --\n   1  12\n   5  20\n   9  23\n   ,#0\n   --\n   25\n   29\n   32\n   )\n\n   $ cut(m, 1 2)\n   (#0\n   --\n   12\n   20\n   23\n   ,#0\n   --\n   25\n   29\n   32\n   )\n"
    },
    {
        "title": "cutPoints",
        "cal": "cutPoints(X, binNum, [freq])",
        "params": "`X`  is a vector.",
        "exp": "Return a vector with (binNum+1) elements such that the elements of X are evenly distributed within each of the binNum buckets indicated by the vector. Each bucket is defined by two adjacent elements of the vector. The lower bound is inclusive and the upper bound is exclusive.",
        "eg": "  \n   $ cutPoints(2 3 1 4, 2);\n   [1,3,5]\n\n   $ cutPoints(1 2 3 4, 2, 1 1 1 3);\n   [1,4,5]"
    },
    {
        "title": "dailyAlignedBar",
        "cal": "dailyAlignedBar(X, timeOffset, n, [timeEnd], [mergeSessionEnd=false])",
        "params": "`X` is a temporal vector of type SECOND, TIME, NANOTIME, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine windows based on the starting time (specified by timeOffset), window length (specified by n), and possibly ending time (specified by timeEnd). For each element of X, return the starting time of the window it belongs to. Specifically, return X-((X-timeOffset)%n) for each element of X and return a vector with the same length as X.",
        "eg": "Please note that the examples below use randomly generated data for the column of price. The result is different each time you execute it.\n\nEx 1. The Chinese stock market has 2 sessions each day: from 9:30AM to 11:30AM and from 1PM to 3PM. The script below calculates rolling 1-hour average prices for these sessions.\n"
    },
    {
        "title": "database",
        "cal": "database(directory, [partitionType], [partitionScheme], [locations], [engine='OLAP'], [atomic='TRANS'])",
        "params": "`directory` the directory where a database is located. To establish a database in the distributed file system, directory should start with \"dfs://\".",
        "exp": "Create a database handle.",
        "eg": "\\1. To establish a non-partitioned database on disk:\n"
    },
    {
        "title": "date",
        "cal": "date(X)",
        "params": "`X`  is an integer or temporal scalar/vector.",
        "exp": "Return the corresponding date(s).",
        "eg": "  \n   $ date 2012.12.03 01:22:01;\n   2012.12.03\n\n   $ date(2016.03M);\n   2016.03.01\n\n   $ date(1);\n   1970.01.02\n"
    },
    {
        "title": "datehour",
        "cal": "datehour(X)",
        "params": "`X` is a temporal scalar/vector that contains information about dates.",
        "exp": "Convert a temporal scalar/vector into DATEHOUR data type.",
        "eg": "  \n   $ datehour(2012.06.13 13:30:10);\n   2012.06.13T13\n\n   $ datehour([2012.06.15 15:32:10.158,2012.06.15 17:30:10.008]);\n   [2012.06.15T15,2012.06.15T17]"
    },
    {
        "title": "datetime",
        "cal": "datetime(X)",
        "params": "`X`  is a temporal scalar/vector, or an integer.",
        "exp": "Return the corresponding datetime(s). The return value type is DATETIME, a temporal.",
        "eg": "  \n   $ datetime(2009.11.10);\n   2009.11.10T00:00:00\n\n   $ typestr datetime(2009.11.10);\n   DATETIME\n\n   $ datetime(now());\n   2016.03.02T20:51:10\n"
    },
    {
        "title": "datetimeParse",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "dayOfMonth",
        "cal": "dayOfMonth(X)",
        "params": "`X`  is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the day of the month for each element in X.  ",
        "eg": "  \n   $ dayOfMonth(2011.01.01);\n   1\n\n   $ dayOfMonth([2012.06.12T12:30:00,2012.07.28T12:35:00]);\n   [12,28]\n"
    },
    {
        "title": "dayOfWeek",
        "cal": "dayOfWeek(X)",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return an integer from 0 to 6 indicating which day of the week is X. 0 means Monday, ....., 6 means Sunday.",
        "eg": "  \n   $ dayOfWeek(2012.12.05);\n   2\n\n   $ dayOfWeek 2013.05.23T12:00:00;\n   3\n\n   $ dayOfWeek(2014.01.11T23:04:28.113);\n   5\n\n   $ dayOfWeek(2012.12.05 2012.12.06 2013.01.05);\n   [2,3,4]"
    },
    {
        "title": "dayOfYear",
        "cal": "dayOfYear(X)",
        "params": "`X`  is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the day of the year for each element in X. ",
        "eg": "  \n   $ dayOfYear(2011.01.01);\n   1\n\n   $ dayOfYear([2011.12.31,2012.12.31]);\n   [365,366]\n\n   $ dayOfYear([2012.06.12T12:30:00,2012.07.12T12:35:00]);\n   [164,194]\n"
    },
    {
        "title": "daysInMonth",
        "cal": "daysInMonth(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the number of days in the month for each element in X.",
        "eg": "  \n   $ daysInMonth(2012.06.12T12:30:00);\n   30\n\n   $ daysInMonth([2012.02.01,2013.12.05]);\n   [29,31]"
    },
    {
        "title": "decimal128",
        "cal": "decimal128(X, scale)",
        "params": "`X` is an integer/floating-point/string scalar or vector.",
        "exp": "Convert the input values into DECIMAL128.",
        "eg": ""
    },
    {
        "title": "decimal32",
        "cal": "decimal32(X, scale)",
        "params": "`X` is an integer/floating-point/string scalar or vector.",
        "exp": "Convert the input values into DECIMAL32.",
        "eg": ""
    },
    {
        "title": "decimal64",
        "cal": "decimal64(X, scale)",
        "params": "`X` is an integer/floating-point/string scalar or vector.",
        "exp": "Convert the input values into DECIMAL64.",
        "eg": ""
    },
    {
        "title": "decimalFormat",
        "cal": "decimalFormat(X, format)",
        "params": "`X` is a scalar/vector of integers or floating numbers.",
        "exp": "Apply a specified format to the given object. The result is a string scalar/vector.",
        "eg": ""
    },
    {
        "title": "decompress",
        "cal": "decompress(X)",
        "params": "`X` is a compressed vector or a table.  ",
        "exp": "Decompress a compressed vector or a table.",
        "eg": "    \n   $ x=1..100000000\n   $ y=compress(x, \"delta\");\n\n   $ y.typestr();\n   HUGE COMPRESS VECTOR\n\n   $ z=decompress(y);\n   $ z.size();\n   100000000\n"
    },
    {
        "title": "defined",
        "cal": "defined(names, [type=VAR])",
        "params": "`names` is a string scalar/vector indicating object name(s).",
        "exp": "Return a scalar/vector indicating whether each element of names is defined.",
        "eg": "  \n   $ x=10\n   $ y=20\n   $ def f(a){return a+1}\n   $ share table(1..3 as x, 4..6 as y) as t1;\n\n   $ defined([\"x\",\"y\",\"f\",`t1]);\n   [1,1,0,0]\n\n   $ defined([\"x\",\"y\",\"f\",`t1], DEF);\n   [0,0,1,0]\n\n   $ defined([\"x\",\"y\",\"f\",`t1], SHARED);\n   [0,0,0,1]"
    },
    {
        "title": "defs",
        "cal": "defs([X])",
        "params": "`X` is a string. It supports wildcard symbols \"%\" and \"?\". \"%\" means 0, 1 or multiple characters and \"?\" means 1 character.",
        "exp": "If X is not specified, return all functions in the system as a table.",
        "eg": "  \n   $ defs();\n"
    },
    {
        "title": "deg2rad",
        "cal": "deg2rad(X)",
        "params": "`X` is a scalar/vector.",
        "exp": "Convert angle units from degrees to radians for each element of X.",
        "eg": "    \n   $ deg2rad 45 90 180 360;\n   [0.785398,1.570796,3.141593,6.283185]"
    },
    {
        "title": "deleteGroup",
        "cal": "deleteGroup(groupName)",
        "params": "`groupName` a string indicating a group name.",
        "exp": "Delete a group. This can only be executed by an administrator on the controller.",
        "eg": "\n    $ deleteGroup(`Production);\n"
    },
    {
        "title": "deleteGroupMember",
        "cal": "deleteGroupMember(userIds, groupIds)",
        "params": "`userIds` a string scalar/vector indicating a user name or multiple user names.",
        "exp": "Remove a user from a group or multiple groups, or remove multiple users from a group. This can only be executed by an administrator on the controller.",
        "eg": "\n    $ deleteGroupMember(`AlexEdwards`ElizabethRoberts, `production);\n"
    },
    {
        "title": "deleteReplicas",
        "cal": "deleteReplicas(chunkId, nodeAlias)",
        "params": "`chunkId` is a string or a string vector indicating ID of chunks. ",
        "exp": "Delete replicas of one or multiple chunks from a node.",
        "eg": "Delete the replicas of all chunks on \"node1\".\n"
    },
    {
        "title": "deleteScheduledJob",
        "cal": "deleteScheduledJob(jobId)",
        "params": "`jobId` is a string indicating a scheduled job ID.",
        "exp": "Delete a scheduled job. If the specified job ID doesn't exist, throw an exception. ",
        "eg": "\n    $ deleteScheduledJob(`dailyJob1);"
    },
    {
        "title": "deleteUser",
        "cal": "deleteUser(userId)",
        "params": "`userId` a string indicating a user name. ",
        "exp": "Delete a user. It removes the user from all the groups she belongs to.",
        "eg": "\n    $ deleteUser(`JohnSmith);"
    },
    {
        "title": "deltas",
        "cal": "deltas(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If X is a vector, return a vector containing the subtractions between adjacent elements. The first element of the result is always NULL.",
        "eg": "  \n   $ x=7 4 5 8 9;\n   $ deltas(x);\n   [,-3,1,3,1]\n   // equivalent to [, 4-7, 5-4, 8-5, 9-8]\n\n   $ x=NULL 1 2 NULL 3;\n   $ deltas(x);\n   [,,1,,]\n\n   $ m=matrix(1 3 2 5 6, 0 8 NULL 7 6);\n   $ m;\n"
    },
    {
        "title": "dema",
        "cal": "dema(X, window)",
        "params": "Calculate the Double Exponential Moving Average (dema) for *X* in a sliding window of the given length.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "denseRank",
        "cal": "denseRank(X, [ascending=true],[ignoreNA=true], [percent=false])",
        "params": "`X` is a vector/matrix.",
        "exp": "If *X* is a vector:",
        "eg": "\n   $ x=1 5 5 6 8 8 9\n   $ print denseRank(x)\n   [0,1,1,2,3,3,4]\n\n   $ y=time(4 1 1 2)\n   $ print denseRank(y, ascending=false)\n   [0,2,2,1]\n   $ m = matrix(1 2 2 NULL, 0 0 0 1, 0 0 NULL 2)\n   $ denseRank(m, ignoreNA=false)\n"
    },
    {
        "title": "deny",
        "cal": "deny(userId|groupId, accessType, [objs])",
        "params": "`userId` | `groupId` a string indicating a user name or a group name. ",
        "exp": "Deny specified access privileges to a user or a group. This command can only be executed by an administrator on the controller/data node.",
        "eg": "None of the members of the group \"production\" can read any table in the database dfs://db1:\n"
    },
    {
        "title": "derivative",
        "cal": "derivative(func, X, [dx =1.0], [n=1], [order=3])",
        "params": "`func` is a unary function.",
        "exp": "Return the derivative of func of order n at X.",
        "eg": "  \n   $ derivative(acos, 0.458, 1e-3);\n   -1.12492\n\n   $ a=[0.25, -4.53, 1.85, 12.45, 2.0];\n   $ derivative(cbrt, a, 1e-3, 1, 5);\n   [0.83995,0.121753,0.221189,0.062053,0.209987] \n\n   $ derivative(pow{3,}, 5);\n   324"
    },
    {
        "title": "det",
        "cal": "det(X)",
        "params": "`X` is a matrix.",
        "exp": "Return the determinant of matrix X. NULL values are replaced with 0 in the calculation.",
        "eg": "  \n   $ x=1..4$2:2;\n   $ x;\n"
    },
    {
        "title": "diag",
        "cal": "diag(X)",
        "params": "`X` is a numeric vector or a square matrix.",
        "exp": "If X is a vector: return a diagonal matrix.",
        "eg": "  \n   $ diag(1..5);\n"
    },
    {
        "title": "dict",
        "cal": "dict(keyObj, valueObj, [ordered=false]) ",
        "params": "`keyObj` a vector indicating dictionary keys.",
        "exp": "Return a dictionary object.",
        "eg": "    \n   $ x=1 2 3  \n   $ y=4.5 7.8 4.3\n   $ z=dict(x,y); \n   $ z; \n   3->4.3            \n   1->4.5            \n   2->7.8        \n\n   $ z=dict(INT,DOUBLE);  \n   $ z[5]=7.9; \n   $ z; \n   5->7.9 \n\n   $ z[3]=6;\n   $ z;\n   3->6\n   5->7.9\n\n   $ dt=dict([`test], [1]);\n   $ dt;\n   test->1\n\n   //create an ordered dictionary\n   $z=dict(x,y,true)\n   $z;\n   1->4.5\n   2->7.8\n   3->4.3\n"
    },
    {
        "title": "dictUpdate!",
        "cal": "dictUpdate!(dictionary, function, keys, parameters, [initFunc=copy])",
        "params": "`dictionary` is a dictionary object.",
        "exp": "Update a dictionary for specified keys with the specified function.",
        "eg": "  \n   $ x=dict(1 2 3, 1 1 1);\n   $ x;\n   3->1\n   1->1\n   2->1\n\n   $ dictUpdate!(x, add, 2 3, 1 2);\n   3->3\n   1->1\n   2->2\n\n   $ x.dictUpdate!(mul, 3 4, 2 4);\n   4->4\n   3->6\n   1->1\n   2->2\n\n   $ d = dict(`IBM`MSFT, [1 2, 3 4])\n   $ msg = table(`IBM`MSFT`GOOG as symbol, 2 3 2 as ap)\n   $ d.dictUpdate!(append!, msg.symbol, msg.ap, x->array(x.type(), 0, 512).append!(x))\n   $ d;\n   MSFT->[3,4,3]\n   GOOG->[2]\n   IBM->[1,2,2]"
    },
    {
        "title": "difference",
        "cal": "difference(X)",
        "params": "`X` is a scalar/vector.",
        "exp": "Return the last element minus the first element of an vector. If X is a scalar, it returns 0.",
        "eg": "  \n   $ difference(2 4 2);\n   0\n\n   $ difference(12.3 15.6 17.8);\n   5.5\n\n   $ difference(278);\n   0"
    },
    {
        "title": "disableActivePartition",
        "cal": "disableActivePartition(dbHandle)",
        "params": "`dbHandle` is the handle of the historical database.",
        "exp": "Cancel the connection between the active database and the historical database. ",
        "eg": "\n    $ histdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\n    $ activeNodeAlias = getNodeAlias()\n    $ activeDate = today()\n    $ enableActivePartition(histdb, activeDate, activeNodeAlias);\n\n    $ disableActivePartition(histdb);\n"
    },
    {
        "title": "disableQueryMonitor",
        "cal": "disableQueryMonitor()",
        "params": "None",
        "exp": "Disable the monitor on the query status. ",
        "eg": ""
    },
    {
        "title": "disableTSDBAsyncSorting",
        "cal": "disableTSDBAsyncSorting()",
        "params": "None",
        "exp": "Data written to the TSDB cache engine are sorted by sortColumns. The tasks of writing and sorting data can be processed synchronously or asynchronously. Execute the command to disable asynchronous sorting mode. This command can only be executed by an administrator on a data node. ",
        "eg": ""
    },
    {
        "title": "disableTablePersistence",
        "cal": "disableTablePersistence(table)",
        "params": "`table` is a table object.",
        "exp": "Disable a table persistence to disk. Any future update of the table will not be persisted to disk.",
        "eg": ""
    },
    {
        "title": "distance",
        "cal": "distance(X, Y)",
        "params": "`X` and `Y` a POINT scalar/pair/vector representing points in the coordinate system of earth.",
        "exp": "Calculate the distance in meters between 2 points on the earth's surface.",
        "eg": "    \n   $ p1 = point(180, 24.118418)\n   $ p2 = point(180, 24.11931)\n   $ distance(p1,p2)\n   99.185916\n\n   $ p1 = point(117.60972, 24.118418)\n   $ p2 = point(117.50972, 24.118418)\n   $ p3 = point(117.70972, 24.118418)\n   $ p4 = point(117.75972, 24.118418)\n   $ distance([p1,p2], [p3,p4]) \n"
    },
    {
        "title": "distinct",
        "cal": "distinct(X) ",
        "params": "`X` is a vector.",
        "exp": "Return the distinct elements from vector X. The order of the elements in the result is not guaranteed.",
        "eg": "    \n   $ distinct 4 5 5 2 3; \n   [3,2,5,4]\n\n   $ t=table(3 1 2 2 3 as x);\n   $ select distinct x from t; \n\n"
    },
    {
        "title": "div",
        "cal": "div(X, Y) or X/Y",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "dividedDifference",
        "cal": "dividedDifference(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
        "params": "`X` is a strictly increasing vector of temporal type.",
        "exp": "Resample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform divided difference interpolation on *Y* based on the resampled *X*.",
        "eg": "\n    $ dividedDifference([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n    \n    [1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578,\n    1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092,\n    1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342,\n    2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328,\n    3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]"
    },
    {
        "title": "dot",
        "cal": "dot(X, Y) or X**Y",
        "params": "`X` / `Y` is a scalar/vector/matrix. If both of X and Y are vectors, they must have the same length. If one of X/Y is a matrix, the other is a vector/matrix and their dimensions must satisfy the rules of matrix multiplication.",
        "exp": "Return the matrix multiplication of X and Y. If X and Y are vectors of the same length, return their inner product.  ",
        "eg": "  \n   $ x=1..6$2:3;\n   $ y=1 2 3;\n   $ x dot y;\n"
    },
    {
        "title": "double",
        "cal": "double(X)",
        "params": "`X` can be of any data type.",
        "exp": "Convert the input to the data type of DOUBLE.",
        "eg": "  \n   // make a double variable with default value 0\n   $ x=double();\n   $ x;\n   00F\n   $ typestr x;\n   DOUBLE\n\n   $ typestr double(`10);\n   DOUBLE\n\n   $ double(`10.9);\n   10.9\n\n   $ double(now());\n   5.297834e+011"
    },
    {
        "title": "drop",
        "cal": "drop(X, n)",
        "params": "`X` is a vector/matrix/table.",
        "exp": "If X is a vector: Delete the first n or last n (if n is negative) elements.",
        "eg": "  \n   $ x=1..10;\n   $ x.drop(2);\n   [3,4,5,6,7,8,9,10]\n   $ x.drop(-2);\n   [1,2,3,4,5,6,7,8]\n\n   $ x=1..10$2:5;\n   $ x;\n"
    },
    {
        "title": "dropAggregator",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "dropColumns!",
        "cal": "dropColumns!(table, colNames)",
        "params": "`table` is a table object. It can be is an in-memory table or a DFS table (for OLAP engine only).",
        "exp": "Delete one or multiple columns from a table. ",
        "eg": "  \n   $ t=table(1 2 3 as x, 4 5 6 as y, 7..9 as z, 10..12 as a, 13..15 as b, 16..18 as c);\n   $ t;\n"
    },
    {
        "title": "dropDatabase",
        "cal": "dropDatabase(directory)",
        "params": "`directory` the directory where the database is located. For a database in the distributed file system, the directory should start with \"dfs://\". ",
        "exp": "Delete all physical files from the specified database.",
        "eg": "Drop a DFS database:\n"
    },
    {
        "title": "dropDistributedInMemoryTable",
        "cal": "dropDistributedInMemoryTable(tableName)",
        "params": "`tableName` is a STRING scalar indicating column names of a distributed in-memory table. ",
        "exp": "Delete the specified distributed in-memory table. This function can only be executed on a data node or compute node.",
        "eg": "\n    $ pt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\n    $ time = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\n    $ id = 0..39;\n    $ value = rand(100, 40);\n    $ tmp = table(time, id, value);\n\n    $ pt = loadDistributedInMemoryTable(`dt)\n    $ pt.append!(tmp);\n    $ dropDistributedInMemoryTable(`dt)\n\n"
    },
    {
        "title": "dropFunctionView",
        "cal": "dropFunctionView(name)",
        "params": "`name` is a string scalar indicating the name of user defined function.",
        "exp": "Delete a function view.",
        "eg": ""
    },
    {
        "title": "dropIPCInMemoryTable",
        "cal": "dropIPCInMemoryTable(tableName)",
        "params": "`tableName` is a STRING indicating the name of IPC in-memory table to be dropped.",
        "exp": "Drop an IPC in-memory table.",
        "eg": "  "
    },
    {
        "title": "dropPartition",
        "cal": "dropPartition(dbHandle, partitionPaths, tableName, [forceDelete=false], [deleteSchema=false])",
        "params": "`dbHandle` is a DolphinDB database handle. ",
        "exp": "Delete data from one or multiple partitions from a table or a database. The database must be in the distributed files system.",
        "eg": "Reminder: the script in this example should be executed on a data node of a cluster. \n"
    },
    {
        "title": "dropStreamEngine",
        "cal": "dropStreamEngine(name)",
        "params": "`name` is a string indicating the name of a created stream engine. You can obtain all created engines with function ``getStreamEngineStat``.",
        "exp": "Release the definition of a stream engine from the memory. The stream engine is created by :doc:`../../FunctionReferences/c/createTimeSeriesAggregator`, :doc:`../../FunctionReferences/c/createCrossSectionalEngine`, :doc:`../../FunctionReferences/c/createAnomalyDetectionEngine`, :doc:`../../FunctionReferences/c/createReactiveStateEngine`.",
        "eg": "\n    $ share streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\n    $ outputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\n    $ tradesAggregator = createTimeSeriesAggregator(name=\"StreamAggregatorDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable, timeColumn=`time, useSystemTime=false, keyColumn=`sym, garbageSize=50)\n    $ subscribeTable(tableName=\"trades\", actionName=\"tradesAggregator\", offset=0, handler=append!{tradesAggregator}, msgAsTable=true)\n"
    },
    {
        "title": "dropStreamTable",
        "cal": "dropStreamTable(tableName)",
        "params": "`tableName` is a string indicating a stream table name.",
        "exp": "Delete the a stream table. If the table has been persisted to disk, the persisted data on disk will be deleted as well.",
        "eg": "\n    $ colNames = `timestamp`sym`qty`price\n    $ colTypes = [TIMESTAMP,SYMBOL,INT,DOUBLE]\n    $ t=streamTable(1:0,colNames,colTypes)\n    $ enableTableShareAndPersistence(t,`trades);\n\n    $ dropStreamTable(`trades);\n"
    },
    {
        "title": "dropTable",
        "cal": "dropTable(dbHandle, tableName)",
        "params": "`dnHandle` is a DolphinDB database handle.",
        "exp": "Delete the specified table on disk. ",
        "eg": "\n    $ n=1000000\n    $ ID=rand(10, n)\n    $ x=rand(1.0, n)\n    $ t=table(ID, x)\n    $ db=database(\"dfs://rangedb\", RANGE,  0 5 10)\n    $ pt = db.createPartitionedTable(t, `pt, `ID)\n    $ pt.append!(t)\n\n    $ dropTable(db,`pt);\n"
    },
    {
        "title": "dropna",
        "cal": "dropna(X, [byRow=true], [thresh])",
        "params": "`X` is a vector or matrix.",
        "exp": "If X is a vector, delete all NULL values from X.",
        "eg": "  \n   $ x=1 NULL 2 3 NULL NULL 4;\n   $ x.dropna();\n   [1,2,3,4]\n\n   $ m=matrix(1 1 1 1, 1 1 1 NULL, 1 NULL 1 NULL);\n   $ m;\n"
    },
    {
        "title": "duration",
        "cal": "duration(X)",
        "params": "`X` is a STRING scalar. It is composed of an integer and a unit of time (y, M, w, d, B, H, m, s, ms, us, ns). For examples: \"2y\", \"3M\", \"30m\", \"100ms\".",
        "exp": "Convert a string scalar to DURATION type. It indicates the length of a time interval.",
        "eg": "  \n   $ y=duration(\"20H\")\n   $ y\n   20H\n\n   $ typestr(y)\n   DURATION\n"
    },
    {
        "title": "each",
        "cal": "| each(func, args...)",
        "params": "`func` is a function.",
        "exp": "Apply a function (specified by *func* or *operator*) to each element of *args*/ *X*/ *Y*. ",
        "eg": "Suppose we need to calculate the daily compensation for 3 workers. Their working hours are stored in vector x=[9,6,8]. Their hourly rate is $10 under 8 hours and $20 beyond 8 hours. Consider the following function ``wage``:\n"
    },
    {
        "title": "eachLeft",
        "cal": "eachLeft(func, X, Y, [consistent=false])",
        "params": "`func`  is a binary function.",
        "exp": "Calculate *func(X(i),Y)* for each element of *X*.",
        "eg": "``eachLeft`` with 2 vectors:\n"
    },
    {
        "title": "eachPost",
        "cal": "eachPost(func, X, [post], [consistent=false])",
        "params": "`func` is a binary function.",
        "exp": "Apply *func* over all pairs of consecutive elements of the object. It is equivalent to: F(X[0], X[1]), F(X[1], X[2]), ..., F(X[n], post).",
        "eg": "\n    $ x=1..10;\n    $ eachPost(sub, x);\n    [-1,-1,-1,-1,-1,-1,-1,-1,-1,]\n    // equivalent to [1-2, 2-3, ..., 9-10, NULL]\n\n    $ +:O x;\n    [3,5,7,9,11,13,15,17,19,]\n    // equivalent to [1+2, 2+3, ..., 9+10, NULL]\n\n\n\n    $ x +:O 0;\n    [3,5,7,9,11,13,15,17,19,10]\n    // equivalent to [1+2, 2+3, ..., 9+10, 10+0]\n\n    $ x=1..12$3:4;\n    $ x;\n"
    },
    {
        "title": "eachPre",
        "cal": "eachPre(func, X, [pre], [consistent=false])",
        "params": "`func` is a binary function.",
        "exp": "Apply *func* over all pairs of consecutive elements of X. It is equivalent to: F(X[0], pre), F(X[1], X[0]), ..., F(X[n], X[n-1]).",
        "eg": "\n    $ x=1..10;\n\n    $ eachPre(sub, x);\n    [,1,1,1,1,1,1,1,1,1]\n    // equivalent to [NULL, 2-1, ..., 10-9]\n\n    $ -:P x;\n    [,1,1,1,1,1,1,1,1,1]\n    // same as above\n\n    $ eachPre(+, x);\n    [,3,5,7,9,11,13,15,17,19]\n    // equivalent to [NULL, 2+1, ..., ]\n\n\n    $ 0 +:P x;\n    [1,3,5,7,9,11,13,15,17,19]\n    // equivalent to [1+0, 2+1, ..., ]\n\n    $ x=1..12$3:4;\n    x;\n"
    },
    {
        "title": "eachRight",
        "cal": "eachRight(func, X, Y, [consistent=false])",
        "params": "`func` is a binary function.",
        "exp": "Calculate *func(X, Y(i))* for each element of *Y*.",
        "eg": "``eachRight`` with 2 vectors:\n"
    },
    {
        "title": "eig",
        "cal": "eig(A) ",
        "params": "`A` is a real symmetric matrix or a Hermitian matrix.",
        "exp": "Calculate the eigenvalues and eigenvectors of A. Return a dictionary.",
        "eg": "  \n   $ A = 1 1 2 7 9 3 5 7 0 $ 3:3;\n   $ eig(A);\n   vectors->\n   #0        #1       #2\n   --------- -------- ---------\n   0.839752  0.169451 -0.515852\n   -0.301349 0.935753 -0.18318\n   0.45167   0.309277 0.836864\n\n   values->[1.716868,10.17262,-1.889488]\n"
    },
    {
        "title": "elasticNet",
        "cal": "elasticNet(ds, yColName, xColNames, [alpha=1.0], [l1Ratio=0.5], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
        "params": "`ds` is an in-memory table or a data source usually generated by the :doc:`../s/sqlDS` function.",
        "exp": "Linear regression with combined L1 and L2 priors as regularizer.",
        "eg": "  \n   $ y = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288]\n   $ x0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599]\n   $ x1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219]\n   $ t = table(y, x0, x1)\n   $ elasticNet(t, `y, `x0`x1);\n"
    },
    {
        "title": "ema",
        "cal": "ema(X, window, warmup=false)",
        "params": "`warmup` is a Boolean value. The default value is false, indicating that the first (window-1) elements windows return NULL. If set to true, elements in the first (window-1) windows are calculated based on the formula given in the details.",
        "exp": "Calculate the Exponential Moving Average (ema) for *X* in a count-based sliding window of the given length.",
        "eg": "  \n   $ x=12.1 12.2 12.6 12.8 11.9 11.6 11.2\n   $ ema(x,3);\n   [,,12.3,12.55,12.225,11.9125,11.55625]\n\n   $ x=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\n   $ ema(x,3);\n"
    },
    {
        "title": "enableActivePartition",
        "cal": "enableActivePartition(db, activeDate, siteAlias)",
        "params": "`db` is the handle of the historical database.",
        "exp": "Create a connection between the active database and the historical database. ",
        "eg": "\n    $ histdb = database(\"C:\\DolphinDBDemo\\example\\data\\dbspace\\historical-A\\Trades2ndDomain\")\n    $ activeNodeAlias = getNodeAlias()\n    $ activeDate = today()\n    $ enableActivePartition(histdb, activeDate, activeNodeAlias);"
    },
    {
        "title": "enableQueryMonitor",
        "cal": "enableQueryMonitor()",
        "params": "None",
        "exp": "Enable the monitor on the query status. The monitor is enabled by default.",
        "eg": ""
    },
    {
        "title": "enableTSDBAsyncSorting",
        "cal": "enableTSDBAsyncSorting()",
        "params": "None",
        "exp": "Data written to the TSDB cache engine are sorted by sortColumns. The tasks of writing and sorting data can be processed synchronously or asynchronously. Execute the command to enable asynchronous sorting mode. The number of asynchronous threads is specified with configuration parameter TSDBAsyncSortingWorkerNum. This command can only be executed by an administrator on a data node. Please make sure the configuration parameter is set greater than 0 before executing the command.",
        "eg": ""
    },
    {
        "title": "enableTablePersistence",
        "cal": "enableTablePersistence(table, [asynWrite=true], [compress=true], [cacheSize=-1], [retentionMinutes=1440], [flushMode=0])",
        "params": "`table` is an empty shared stream table.",
        "exp": "This command enables a shared stream table to be persisted to disk. ",
        "eg": "- It is recommended to invoke command :doc:`/FunctionsandCommands/CommandsReferences/f/fflush` to write data in the page cache to disk before you kill a DolphinDB process and restart it.\n- If asynchronous mode is enabled for data persistence or flush, data loss may occur due to server crash."
    },
    {
        "title": "enableTableShareAndPersistence",
        "cal": "enableTableShareAndPersistence(table, tableName, [asynWrite=true], [compress=true], [cacheSize=-1], [retentionMinutes=1440], [flushMode=0], [preCache])",
        "params": "`table` is an empty stream table.",
        "exp": "Share a stream table, and enable it to be persisted to disk. For this command to work, we need to specify the configuration parameter `persistenceDir` in the configuration file (*dolohindb.cfg* in standalone mode and *cluster.cfg* in cluster mode). For details of this configuration parameter, see :doc:`/DatabaseandDistributedComputing/Configuration/StandaloneMode`. The persistence location of the table is <PERSISTENCE_DIR>/<TABLE_NAME>.  The directory contains 2 types of files: data files (named like `data0.log`, `data1.log`...) and an index file index.log. The data that has been persisted to disk will be loaded into memory after the system is restarted.",
        "eg": "- It is recommended to invoke command :doc:`/FunctionsandCommands/CommandsReferences/f/fflush` to write data in the page cache to disk before you kill a DolphinDB process and restart it.\n- If asynWrite is set to true, streaming data is written at the fastest speed and data loss may occur due to server crash.\n- If asynWrite is set to false and flushMode to 0, data loss may occur due to operating system crash.\n- If asynWrite is set to false and flushMode to 1, the streaming data is written at the slowest speed, and server or operating system crash will not cause data loss.\n- It is not allowed to share a stream table multiple times by modifying the shared table name."
    },
    {
        "title": "endsWith",
        "cal": "endsWith(X, str)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Check if X ends with str. If yes, return true; otherwise, return false.",
        "eg": "  \n   $ endsWith('ABCDEF!', \"F!\");\n   1\n\n   $ endsWith('ABCDEF!', \"E!\");\n   0"
    },
    {
        "title": "enlist",
        "cal": "enlist()",
        "params": "`X` can be of any data form.",
        "exp": "Returns a vector or tuple composed of *X*.",
        "eg": "\n    $ enlist(1)\n    [1]\n\n    $ enlist(`aaa)\n    [\"aaa\"]\n\n    $ enlist([2022.01.01,2022.01.02,2022.01.03])\n    ([2022.01.01,2022.01.02,2022.01.03])\n\n    $ enlist([\"a\",2,3])\n    ((\"a\",2,3))\n\n    $ a = array(INT[], 0, 10).append!([1 2 3, 4 5,6 7 8, 9 NULL])\n    $ enlist(a)\n    ([[1,2,3],[4,5],[6,7,8],[9,00i]])"
    },
    {
        "title": "eq",
        "cal": "eq(X, Y) or X==Y ",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix/set. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither X nor Y is a set, return the element-by-element comparison of X and Y.",
        "eg": "  \n   $ 1 2 3 == 2;\n   [0,1,0]\n\n   $ 1 2 3==0 2 4;\n   [0,1,0]\n\n   $ 1:2==1:6;\n   1 : 0\n\n   $ m1=1..6$2:3;\n   $ m1;\n"
    },
    {
        "title": "eqFloat",
        "cal": "eqFloat(X, Y, [precision=9])",
        "params": "`X` / `Y` is a numeric scalar/vector/matrix. If X or Y is a vector/matrix, the other is a scalar or a vector/matrix of the same size.",
        "exp": "Return the element-by-element comparison of X and Y with the given precision.  ",
        "eg": "  \n   $ eqFloat(0.1234567891, 0.123456789);\n   1\n\n   $ eqFloat(0.123456788, 0.123456789);\n   0\n\n   $ eqFloat(0.123456788 0.123456789 0.1234567891, 0.123456789);\n   [0,1,1]\n"
    },
    {
        "title": "eqObj",
        "cal": "eqObj(obj1, obj2, [precision])",
        "params": "`obj1` / `obj2` is a scalar/pair/vector/matrix.",
        "exp": "Check if the data types and values of two objects are identical. Return true only if both data types and values are identical. Please note that ``eqObj`` returns false if values are identical but object types are different. This is different from fuction :doc:`eq`.",
        "eg": "  \n   $ eqObj(2, 2.0);\n   false\n\n   $ eq(2, 2.0);\n   true\n\n   $ eqObj(1.1, 1.2, 0);\n   true\n\n   $ eqObj(1.1, 1.2, 1);\n   false\n\n   $ eqObj(1 2 3, 1 2 3);\n   true\n   $ eq(1 2 3, 1 2 3);\n   [true,true,true]\n"
    },
    {
        "title": "erase!",
        "cal": "erase!(obj, key|filter)",
        "params": "`obj` is a set/dictionary/table.",
        "exp": "Eliminate elements from a set, or members from a dictionary, or rows from a table.",
        "eg": "On a set:\n"
    },
    {
        "title": "esd",
        "cal": "esd(data, [hybrid], [maxAnomalies], [alpha])",
        "params": "`data` is a numeric vector.",
        "exp": "Conduct anomaly detection with the Extreme Studentized Deviate test (ESD).",
        "eg": "    \n   $ n = 1000\n   $ ts = rand(10.0, n)\n   $ ts[500 600 700 999] += 20\n   $ esd(ts);\n"
    },
    {
        "title": "euclidean",
        "cal": "euclidean(X, Y)",
        "params": "`X` and `Y` are numeric scalars, or vectors/matrices of the same size.",
        "exp": "If *X* and *Y* are scalars or vectors, return the result of their Euclidean distance.",
        "eg": "  \n   $ a=[100, 0, 0]\n   $ b=[0, 51, NULL]\n   $ euclidean(a,b)\n   112.254176\n\n   $ s1=indexedSeries(1 2 4, 10.4 11.2 9)\n   $ s2=indexedSeries(1 2 5, 23.5 31.2 26)\n   $ euclidean(s1,s2) \n   23.9084\n\n   $ m=matrix(23 56 47, 112 94 59)\n   $ euclidean(a,m) \n   [106.1791,111.6288]\n\n   $ m1=matrix(11 15 89, 52 41 63)\n   $ euclidean(m,m1)   \n   [59.9083,80.1561]\n\n   $ m.rename!(2020.01.01..2020.01.03, `A`B)\n   $ m.setIndexedMatrix!()\n   $ m1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\n   $ m1.setIndexedMatrix!()\n   $ euclidean(m,m1)  \n   [34.176,62.6418]\n"
    },
    {
        "title": "eval",
        "cal": "eval(<X>)  ",
        "params": "`X` is metacode.",
        "exp": "Evaluate the given metacode.",
        "eg": "  \n   $ eval(<1+2>);\n   3\n\n   $ eval(<1+2+3=10>);\n   0\n\n   $ eval(expr(6,<,8));\n   1\n\n   $ eval(expr(sum, 1 2 3));\n   6\n\n   $ a=6; b=9;\n   $ eval(expr(<a>,+,<b>));\n   15"
    },
    {
        "title": "evalTimer",
        "cal": "evalTimer(funcs, [count=1])",
        "params": "`funcs` is a function or a tuple of functions with no parameters.",
        "exp": "Return the execution time of the specified functions in units of milliseconds. If funcs is a tuple of functions, return the amount of time to execute these functions consecutively.",
        "eg": "    \n   $ x=rand(10.0, 1000000)\n   $ evalTimer(dot{x,2},10);\n   39.609375\n\n   $ evalTimer(sort{x},10);\n   837.542702\n\n   $ evalTimer([dot{x,2},sort{x}],10)\n   870.065348  \n"
    },
    {
        "title": "ewmCorr",
        "cal": "ewmCorr(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
        "params": "Calculate exponentially weighted moving correlation of X and other.",
        "exp": "`X` is a numeric vector.",
        "eg": "    \n   $ a=[0,1,2,int(),4]\n   $ b=[2,4,3,6,5]\n   $ ewmCorr(X=a,other=b,com=0.5);\n   [,1,-0.0533,-0.020776,0.775788]\n\n   $ ewmCorr(X=a,other=b,com=0.5,ignoreNA=true);\n   [,1,-0.0533,-0.020776,1.040629]\n"
    },
    {
        "title": "ewmCov",
        "cal": "ewmCov(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [other], [bias=false])",
        "params": "Calculate exponentially weighted moving covariance of X and other.",
        "exp": "`X` is a numeric vector.",
        "eg": "    \n   $ a=[0,1,2,int(),4]\n   $ b=[2,4,3,6,5]\n   $ ewmCov(X=a,other=b,com=0.5);\n   [,1,-0.038462,-0.038462,2.112637]\n\n   $ ewmCov(X=a,other=b,com=0.5,ignoreNA=true);\n   [,1,-0.038462,-0.038462,1.969231]"
    },
    {
        "title": "ewmMean",
        "cal": "ewmMean(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false])",
        "params": "Calculate exponentially weighted moving average.",
        "exp": "`X` is a numeric vector.",
        "eg": "    \n   $ a=[0,1,2,int(),4]\n   $ ewmMean(X=a,com=0.5);\n   [0,0.75,1.615385,1.615385,3.670213]\n\n   $ ewmMean(X=a,com=0.5,ignoreNA=true);\n   [0,0.75,1.615385,1.615385,3.225]\n"
    },
    {
        "title": "ewmStd",
        "cal": "ewmStd(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
        "params": "Calculate exponentially weighted moving standard deviation.",
        "exp": "`X` is a numeric vector.",
        "eg": "    \n   $ a=[0,1,2,int(),4]\n   $ ewmStd(X=a,com=0.5);\n   [,0.707107,0.919866,0.919866,1.720513]\n\n   $ ewmStd(X=a,com=0.5,ignoreNA=true);\n   [,0.707107,0.919866,0.919866,1.679057]\n"
    },
    {
        "title": "ewmVar",
        "cal": "ewmVar(X, [com], [span], [halfLife], [alpha], [minPeriods=0], [adjust=true], [ignoreNA=false], [bias=false])",
        "params": "Calculate exponentially weighted moving variance.",
        "exp": "`X` is a numeric vector.",
        "eg": "    \n   $ a=[0,1,2,int(),4]\n   $ ewmVar(X=a,com=0.5);\n   [,0.5,0.846154,0.846154,2.960165]\n\n   $ ewmVar(X=a,com=0.5,ignoreNA=true);\n   [,0.5,0.846154,0.846154,2.819231]\n"
    },
    {
        "title": "exists",
        "cal": "exists(path)",
        "params": "`path` is a string or a string vector, indicating the path of a file (or files) or a folder (or folders).",
        "exp": "Check if the specified file (or files) or folder (or folders) exists. In the distributed files system, check if the specified folder (or folders) exists.",
        "eg": "  \n   $ t=table(1..10 as ID, rand(1.0, 10) as x);\n   $ saveText(t, \"C:/DolphinDB/Data/t.txt\");\n \n   $ exists(\"C:/DolphinDB/Data/t.txt\");\n   1\n   $ exists(\"C:/DolphinDB/Data/t1.txt\");\n   0\n   $ exists(\"C:/DolphinDB/Data\");\n   1\n\n   $ exists([\"C:/DolphinDB/Data/t.txt\",\"C:/DolphinDB/Data/t1.txt\",\"C:/DolphinDB/Data\"]);\n   [1,0,1]\n"
    },
    {
        "title": "existsDatabase",
        "cal": "existsDatabase(path)",
        "params": "`path` is a string indicating the path of a database folder.",
        "exp": "Check if a database exists under the specified folder.",
        "eg": "To check if a DFS database exists:\n"
    },
    {
        "title": "existsPartition",
        "cal": "existsPartition(path, [tableName])",
        "params": "`path` is a string indicating the path of a partition folder.",
        "exp": "Check if the specified partition exists.",
        "eg": "Check if the specified partition exists. The following scripts must be executed on a data node or compute node.\n"
    },
    {
        "title": "existsSubscriptionTopic",
        "cal": "existsSubscriptionTopic([server], tableName, [actionName])",
        "params": "`server` is a STRING indicating the node alias of the subscribed stream table, or the handler of a remote call connection. If *server* is not specified or an empty string, it means the streaming data is from the local server.",
        "exp": "Check the existence of a subscription topic of a shared stream table. Return true if the subscription topic exists, false if it doesn't.",
        "eg": "1.30.16 / 2.00.4"
    },
    {
        "title": "existsTable",
        "cal": "existsTable(path, tableName)",
        "params": "`path` a string indicating the path of a database.",
        "exp": "Check if the specified table exists in the specified database.",
        "eg": "To check if a table exists in a DFS database (on a data node or compute node):\n"
    },
    {
        "title": "exp",
        "cal": "exp(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Apply the exponential function to all elements of X.",
        "eg": "  \n   $ exp(1 2 3);\n   [2.718282,7.389056,20.085537]\n\n   $ log(exp(1));\n   1"
    },
    {
        "title": "exp2",
        "cal": "exp2(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Return 2 raised to the power of X. The data type of the result is always DOUBLE.",
        "eg": "  \n   $ exp2(3);\n   8\n\n   $ exp2(2 4 NULL 6);\n   [4,16,,64]\n\n   $ exp2(1..4$2:2);\n"
    },
    {
        "title": "expm1",
        "cal": "expm1(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Return exp(X)-1.",
        "eg": "  \n   $ expm1(5);\n   147.413159\n\n   $ expm1(1 2 3 NULL);\n   [1.718282,6.389056,19.085537,]\n\n   $ expm1(1..4$2:2);\n"
    },
    {
        "title": "expr",
        "cal": "expr(args...)  ",
        "params": "`args...` are objects, operators, or metacode. Metacode is objects and/or expressions surrounded by \"<\" and \">\". The minimum number of arguments is 2.",
        "exp": "Generate metacode from objects, operators, or other metacode.",
        "eg": "  \n   $ expr(6,<,8);\n   < 6 < 8 >\n\n   $ expr(sum, 1 2 3);\n   < sum [1,2,3] >\n\n   $ a=6; \n   $ expr(a,+,1);\n   < 6 + 1 >\n\n   $ expr(<a>,+,1);\n   < a + 1 >\n\n   $ expr(<a>,+,<b>);\n   < a + b >\n\n   $ expr(a+7,*,8);\n   < 13 * 8 >\n\n   $ expr(<a+7>,*,8);\n   < (a + 7) * 8 >\n\n   $ expr(not, < a >);\n   < ! a >\n"
    },
    {
        "title": "extractTextSchema",
        "cal": "extractTextSchema(filename, [delimiter], [skipRows=0])",
        "params": "`filename` the input data file name with its absolute path.",
        "exp": "Generate the schema table for the input data file. The schema table has 2 columns: column names and their data types.",
        "eg": "    \n   $ n=1000000\n   $ timestamp=09:30:00+rand(18000,n)\n   $ ID=rand(100,n)\n   $ qty=100*(1+rand(100,n))\n   $ price=5.0+rand(100.0,n)\n   $ t1 = table(timestamp,ID,qty,price)\n   $ saveText(t1, \"C:/DolphinDB/Data/t1.txt\")\n   $ schema=extractTextSchema(\"C:/DolphinDB/Data/t1.txt\");\n   $ schema;\n"
    },
    {
        "title": "eye",
        "cal": "eye(X)",
        "params": "`X` is a positive integer.",
        "exp": "Return an X by X indentity matrix.",
        "eg": "  \n   $ eye(3);\n"
    },
    {
        "title": "fTest",
        "cal": "fTest(X, Y, [ratio=1.0], [confLevel=0.95])",
        "params": "`X` is a numeric vector indicating the first sample for the F-test.",
        "exp": "Conduct an F-test to compare the variances of two samples.  ",
        "eg": "    \n   $ x = norm(10.0, 1.0, 20);\n   $ y = norm(1.0, 2.0, 10);\n   $ fTest(x, y, 0.5);\n   numeratorDf->19\n   stat->\n   alternativeHypothesis                  pValue    lowerBound upperBound\n   -------------------------------------- --------- ---------- ----------\n   ratio of variances is not equal to 0.5 0.002326  0.025844   0.274161  \n   ratio of variances is less than 0.5    0.001163  0          0.230624  \n   ratio of variances is greater than 0.5 0.998837  0.032295   Infinity  \n  \n   denominatorDf->9\n   confLevel->0.95\n   fValue->0.190386\n   method->F test to compare two variances"
    },
    {
        "title": "ffill",
        "cal": "ffill(obj, [limit])",
        "params": "`obj` is a vector/matrix/table.",
        "exp": "If obj is a vector: forward fill the NULL values in obj with the previous non-NULL value.",
        "eg": "    \n   $ x=1 2 3 NULL NULL NULL 4 5 6\n   $ x.ffill();\n   [1,2,3,3,3,3,4,5,6]\n\n   $ x.ffill(1);\n   [1,2,3,3,,,4,5,6]\n\n   $ x.ffill!(2);\n   $ x;\n   [1,2,3,3,3,,4,5,6]  \n\n   $ date=[2012.06.12,2012.06.12,2012.06.13,2012.06.14,2012.06.15]\n   $ sym=[\"IBM\",\"MSFT\",\"IBM\",\"MSFT\",\"MSFT\"]\n   $ price=[40.56,26.56,,,50.76]\n   $ qty=[2200,4500,,5600,]\n   $ timestamp=[09:34:07,09:35:26,09:36:42,09:36:51,09:36:59]\n   $ t=table(date,timestamp,sym,price,qty);\n   $ t;\n  "
    },
    {
        "title": "ffill!",
        "cal": "ffill!(obj, [limit])",
        "params": "Please refer to :doc:`ffill`. The only difference between ``ffill`` and ``ffill!`` is that the latter assigns the result to X and thus changing the value of X after the execution.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "fflush",
        "cal": "fflush(obj)",
        "params": "`obj` is a file handle. Open a file with function :doc:`/FunctionsandCommands/FunctionReferences/f/file` to obtain the file handle.",
        "exp": "Write the buffered data to the file system in the operating system. It must be executed by a logged-in user.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "file",
        "cal": "file(name, [mode=\"r\"], [isLittleEndian])",
        "params": "`name` a string indicating a file name.",
        "exp": "Open a file with a given mode. It must be executed by a logged-in user.",
        "eg": "    \n   $ fout=file(\"test.txt\",\"w\");\n   $ fout.writeLine(\"hello world!\");\n   1\n   $ fout.close();\n\n   $ fin = file(\"test.txt\");\n   $ print fin.readLine();\n   hello world!\n   $ fin.close();   "
    },
    {
        "title": "files",
        "cal": "files(directory, [pattern]) ",
        "params": "`directory` is a string indicating a directory path.",
        "exp": "It must be executed by a logged-in user.",
        "eg": "    \n   $ files(\"D:/06_DolphinDB/01_App/DolphinDB_Win_V0.2\");\n"
    },
    {
        "title": "fill!",
        "cal": "fill!(obj, index, value)",
        "params": "`obj` can be a vector, tuple, matrix, dictionary or table.",
        "exp": "Execute the following script: obj[index]=value.",
        "eg": "Ex 1. Create a tuple with 20 elements. Each element is a NULL of floating type.\n"
    },
    {
        "title": "find",
        "cal": "find(X, Y)",
        "params": "`X` is a vector, dictionary, in-memory table with one column, keyed table, or indexed table.",
        "exp": "If X is a vector: for each element of Y, return the position of its first occurrence in vector X. If the element doesn't appear in X, return -1. (To find the positions of all occurences, please use function :doc:`../a/at`.)",
        "eg": "When X is a vector:\n"
    },
    {
        "title": "first",
        "cal": "first(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "Return the first element of a vector, or the first row of a matrix.",
        "eg": "    \n   $ first(`hello `world);\n   hello\n\n   $ first(1..10);\n   1\n\n   $ m = matrix(1 2 3, 4 5 6);\n   $ m;\n"
    },
    {
        "title": "firstHit",
        "cal": "firstHit(func, X, target)",
        "params": "`func` can only be the following operators: >, >=, <, <=, !=, <>, ==.",
        "exp": "Return the first element in *X* that satisfies the condition ``X func target`` (e.g. X>5).",
        "eg": ".. code-block:: console\n   :linenos:\n   :emphasize-lines: 2, 6\n\n    $ X = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\n    $ firstHit(<, X, 2.5) \n    1.2\n\n    // return null value if no element satisfies the condition\n    $ firstHit(>, X, 10.0) \n    NULL\n\nRelated Function: :doc:`../i/ifirstHit`"
    },
    {
        "title": "firstNot",
        "cal": "firstNot(X, [k])",
        "params": "`X` is a vector/matrix.",
        "exp": "If X is a vector:",
        "eg": "\n   $ firstNot(0 0 0 6 1, 0);\n   6\n\n   $ firstNot(NULL 0 3 2 1, 0);\n   3\n\n   $ firstNot(NULL 0 1 6);\n   0\n\n   $ t=table(1 1 1 1 1 2 2 2 2 2 as id, 0 0 0 2 1 NULL NULL 0 0 3 as x);\n   $ t;\n"
    },
    {
        "title": "fixedLengthArrayVector",
        "cal": "fixedLengthArrayVector(args)",
        "params": "`args` can be vectors (excluding array vectors)/tuples/matrices/tables. All *args* must be of the same data type supported by :doc:`/DataTypesandStructures/DataForms/Vector/arrayVector`.",
        "exp": "Concatenate vectors, matrices, and tables and return an array vector. ",
        "eg": "Example 1. \n"
    },
    {
        "title": "flatten",
        "cal": "flatten(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "Convert a matrix or a list of vectors into a one dimensional vector.",
        "eg": "Convert a matrix into a vector.\n"
    },
    {
        "title": "flip",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "floor",
        "cal": "floor(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The ``floor`` and :doc:`../c/ceil` functions map a real number to the largest previous and the smallest following integer, respectively. Function :doc:`../r/round` maps a real number to the largest previous or the smallest following integer with the round half up rule.",
        "eg": "    \n   $ floor(2.1);\n   2\n   $ floor(2.9);\n   2\n   $ floor(-2.1);\n   -3\n\n   $ ceil(2.1);\n   3\n   $ ceil(2.9);\n   3\n   $ ceil(-2.1);\n   -2\n\n   $ round(2.1);\n   2\n   $ round(2.9);\n   3\n   $ round(-2.1);\n   -2\n\n   $ m = 1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9 10$2:5;\n   $ m;\n"
    },
    {
        "title": "flushOLAPCache",
        "cal": "flushOLAPCache()",
        "params": "None",
        "exp": "Forcibly flush the data of completed transactions cached in the OLAP cache engine to the database. Specify the configuration parameter *chunkCacheEngineMemSize* and set *dataSync* = 1 before execution.",
        "eg": ""
    },
    {
        "title": "flushTSDBCache",
        "cal": "flushTSDBCache()",
        "params": "None",
        "exp": "Forcibly flush the completed transactions cached in the TSDB cache engine to the database. Specify the configuration parameter *TSDBCacheEngineSize* before execution.",
        "eg": "2.00.4"
    },
    {
        "title": "form",
        "cal": "form(X)",
        "params": "`X` is an arbitrary variable or constant.",
        "exp": "Generate the data form ID of a variable or a constant. Data form IDs and their corresponding data forms are: 0: scalar; 1: vector; 2: pair; 3: matrix; 4: set; 5: dictionary; 6: table.",
        "eg": "    \n   $ form(false);\n   0\n\n   $ form(`TEST);\n   0\n\n   $ form(`t1`t2`t3);\n   1\n\n   $ form(1 2 3);\n   1\n\n   $ x= 1 2 3\n   $ if(form(x) == VECTOR){y=1}\n   $ y;\n   1\n\n   $ form(1..6$2:3); \n   3"
    },
    {
        "title": "format",
        "cal": "format(X, format)",
        "params": "`X` is a scalar/vector.",
        "exp": "Apply a specified format to the given object. The result is a string scalar/vector.",
        "eg": "\n   $ t = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty);\n   $ t;\n"
    },
    {
        "title": "fromJson",
        "cal": "fromJson(X)",
        "params": "`X` is a JSON string that complies with DolphinDB specification.",
        "exp": "Converta a JSON string that complies with DolphinDB specification to a DolphinDB variable.",
        "eg": "    \n   $ x=1 2 3\n   $ y=toJson(x)\n   $ y;\n   {\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\n   $ fromJson(y);\n   [1,2,3]\n"
    },
    {
        "title": "fromUTF8",
        "cal": "fromUTF8(str, encode)",
        "params": "`str` is a string scalar/vector.",
        "exp": "Change the encoding of strings from UTF-8.",
        "eg": "    \n   $ fromUTF8(\"DolphinDB\",\"gbk\");\n   DolphinDB\n\n   $ fromUTF8([\"hello\",\"world\"],\"euc-cn\");\n   [\"hello\",\"world\"]\n"
    },
    {
        "title": "funcByName",
        "cal": "funcByName(name)",
        "params": "`name` is a string indicating an operator or a function. The function can be either a built-in function or a user-defined function.",
        "exp": "Dynamically execute an operator or a function. It is mainly used in metaprogramming.",
        "eg": "  \n   $ def f(x, a, b){\n   $    return funcByName(x)(a, b)\n   $ }\n\n   $ f(\"+\", 1 2 3, 4 5 6);\n   [5,7,9]\n\n   $ f(\"sub\", 1 8 3, 4 8 6);\n   [-3,0,-3]\n\n   $ f(\"corr\", 1 8 3, 4 8 6);\n   0.970725\n\n   $ def cal(a,b){\n   $    return pow(a\\b,2)\n   $ }\n\n   $ f(\"cal\", 4 8 10, 2 2 2);\n   [4,16,25]\n\n   $ funcByName(\"call\")(sum,1..10);\n   55"
    },
    {
        "title": "fy5253",
        "cal": "fy5253(X, [weekday=0], [startingMonth=1], [nearest=true], [offset], [n=1])",
        "params": "`X` is a scalar/vector.  Its data type can be DATE, DATETIME, TIMESTAMP, or NANOTIMESTAMP.",
        "exp": "Using the 52-53 weeks in a fiscal year (4-4-5 calendar), it returns the start date of fiscal year which includes `X`.",
        "eg": "    \n   $ fy5253(2016.11.01,0,1,true);\n   2016.02.01\n   // The Monday closest to 2016.01.31 is 2016.02.01\n\n   $ fy5253(2016.11.01,0,1,false);\n   2016.01.25\n   // The last Monday in January 2016 is 2016.01.25\n\n   $ date=2011.10.25 2012.10.25 2013.10.25 2014.10.25 2015.10.25 2016.10.25 2017.10.25 2018.10.25 2019.10.25 2020.10.25\n   $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n   $ sym = take(`MSFT,10)\n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n\n   $ select avg(price),sum(qty) from t1 group by fy5253(date,0,1,true,2011.10.01,2);\n"
    },
    {
        "title": "fy5253Quarter",
        "cal": "fy5253Quarter(X, [weekday=0], [startingMonth=1], [qtrWithExtraWeek=1], [nearest=true], [offset], [n=1])",
        "params": "`X` is a scalar/vector, its type can be DATE, DATETIME, TIMESTAMP, NANOTIMESTAMP.",
        "exp": "Using the 52-53 week in fiscal year (4-4-5 calendar), this function returns the start date of fiscal year which includes `X`.",
        "eg": "    \n   $ fy5253Quarter(2019.12.01,0,1,1,true);\n   2019.11.04\n\n   $ fy5253Quarter(2019.12.01,0,1,4,true);\n   2019.10.28\n\n   // The start date of the fiscal year 2019 is 2019.01.28. For the fiscal year 2020 it is 2020.02.03. The difference between them is 53 weeks, suggesting the existence of a leap quarter. qtrWithExtraWeek=1 means the first quarter is a leap quarter, which contains 14 weeks, so the start date of the quarter including 2019.12.01 is 2019.11.01; qtrWithExtraWeek=4 means that the fourth quarter is a leap season, which contains 14 weeks, so the start date of the quarter including 2019.12.01 is 2019.10.28.\n\n   $ date=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\n   $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n   $ sym = take(`MSFT,10)\n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n\n   $ select avg(price),sum(qty) from t1 group by fy5253Quarter(date,0,1,1,true,2016.01.01,2);\n"
    },
    {
        "title": "gaussianNB",
        "cal": "gaussianNB(Y, X, [varSmoothing=1e-9])",
        "params": "`Y` is a vector with the same length as table X. Each element of labels indicates the class that the correponding row in X belongs to.",
        "exp": "Conduct the Naive Bayesian classification. Return a dictionary with the following keys:",
        "eg": "The dataset iris.data used in the following example can be downloaded from `<https://archive.ics.uci.edu/ml/datasets/iris>`_.\n"
    },
    {
        "title": "ge",
        "cal": "ge(X, Y) or X>=Y",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix/set. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither X nor Y is a set, return the element-by-element comparison of X>=Y.",
        "eg": "\n   $ 1 2 3 >= 2;\n   [0,1,1]\n\n   $ 1 2 3 >= 0 2 4;\n   [1,1,0]\n\n   $ 2:3>=1:6;\n   1 : 0\n\n   $ m1=1..6$2:3;\n   $ m1;\n"
    },
    {
        "title": "gema",
        "cal": "gema(X, window, alpha)",
        "params": "`alpha` is a floating-point number in (0,1) indicating the smoothing factor alpha.",
        "exp": "Calculate the Exponential Moving Average (ema) for *X* in a sliding window of the given length.",
        "eg": "  \n   $ x=12.1 12.2 12.6 12.8 11.9 11.6 11.2\n   $ gema(x,3,0.5);\n   [,,12.299999999999998,12.55,12.225000000000001,11.912500000000001,11.55625]\n\n   $ x=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2, 14 15 18 19 21 12 10)\n   $ gema(x,3,0.1);\n\n"
    },
    {
        "title": "getActiveMaster",
        "cal": "getActiveMaster()",
        "params": "None.",
        "exp": "Return the alias of the controller node. For a cluster with multiple controller nodes, return the alias of the Leader controller node. Please note that this function can only be executed on the control node.",
        "eg": "    \n   $ getActiveMaster();\n   controller1\n"
    },
    {
        "title": "getAggregator",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "getAggregatorStat",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "getAllDBs",
        "cal": "getAllDBs()",
        "params": "None",
        "exp": "The function returns a dictionary containing the information of DFS databases on the current node. The keys are the database names and the values are the table names, and the following numbers indicates the number of the table in this database (starting from 1), whether it has been deleted (1 means it has been deleted).",
        "eg": "  \n   $ getAllDBs();\n"
    },
    {
        "title": "getAuthenticatedUsers",
        "cal": "getAuthenticatedUsers()",
        "params": "None",
        "exp": "Return a list of users who are currently logged in on all nodes.",
        "eg": "\n    $ getAuthenticatedUsers()\n    [\"admin\",\"a1\",\"a3\",\"a2\",\"a4\"]   "
    },
    {
        "title": "getBackupList",
        "cal": "getBackupList(backupDir, dbPath, tableName)",
        "params": "`backupDir`  is a string indicating the directory where the backup is saved.",
        "exp": "Return a table with information about the backups of a DFS table. Each row of the table corresponds to a backed-up partition. The table contains the following columns:",
        "eg": "  \n   $ if(existsDatabase(\"dfs://valuedb\")){\n   $    dropDatabase(\"dfs://valuedb\")\n   $ }\n   $ n=3000000\n   $ month=take(2000.01M..2000.04M, n);\n   $ x=1..n\n   $ t=table(month,x);\n\n\n   $ db=database(\"dfs://valuedb\", VALUE, 2000.01M..2000.04M)\n   $ pt = db.createPartitionedTable(t, `pt, `month);\n   $ pt.append!(t);\n   $ backup(\"/home/DolphinDB/backup\",\"dfs://valuedb\",tableName=\"pt\");\n   $ getBackupList(\"/home/DolphinDB/backup\",\"dfs://valuedb\",\"pt\");\n\n"
    },
    {
        "title": "getBackupMeta",
        "cal": "getBackupMeta(backupDir, dbPath, partition, tableName)",
        "params": "`backupDir` is a string indicating the directory where the backup is saved.",
        "exp": "Return a dictionary with information about the backup of a partition in a DFS table, which contains the following keys:",
        "eg": "  \n   $ getBackupMeta(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\")\n   schema->\n   name  typeString typeInt extra comment\n   ----- ---------- ------- ----- -------\n   month MONTH      7                    \n   x     INT        4                    \n\n   dfsPath->dfs://valuedb/200001M/b39\n   rows->750000\n   chunkID->0061427c-4b24-e3b6-425c-c0e1553d3c35\n   cid->13349\n"
    },
    {
        "title": "getBackupStatus",
        "cal": "getBackupStatus([userName])",
        "params": "`userName` is a string indicating the user name. ",
        "exp": "Return the status of backup/restore tasks. Return a table where each row represents the information of a task.",
        "eg": "\n   $ getBackupStatus()\n   "
    },
    {
        "title": "getChunkPath",
        "cal": "getChunkPath(ds)",
        "params": "`ds`  is one or multiple data sources.",
        "exp": "Return the paths of the chunks that the given data sources represent.",
        "eg": "  \n   $ if(existsDatabase(\"dfs://valuedb\")){\n   $   dropDatabase(\"dfs://valuedb\")\n   $ }\n\n   $ db=database(\"dfs://valuedb\", VALUE, 1..10)\n   $ n=1000000\n   $ t=table(rand(1..10, n) as id, rand(100.0, n) as val)\n   $ pt=db.createPartitionedTable(t, `pt, `id).append!(t);\n   $ ds=sqlDS(<select * from pt where id in 1..3>)\n   $ getChunkPath(ds);\n\n   [\"/valuedb/1\",\"/valuedb/2\",\"/valuedb/3\"]\n"
    },
    {
        "title": "getChunksMeta",
        "cal": "getChunksMeta([chunkPath], [top = 1024])",
        "params": "`chunkPath`  is the DFS path to one or multiple database chunks. It supports wildcards %, * and ?.",
        "exp": "Return metadata of specified database chunks on the local datanode. If chunkPath is not specified, return metadata of all database chunks on the local datanode.",
        "eg": "  \n   $ if(existsDatabase(\"dfs://testDB\")){\n   $   dropDatabase(\"dfs://testDB\")\n   $ }\n   $ db=database(\"dfs://testDB\", VALUE, 1..10)\n\n   $ n=1000000\n   $ t=table(rand(1..10, n) as id, rand(100.0, n) as x)\n   $ db.createPartitionedTable(t, `p1, `id).append!(t)\n\n   $ n=2000000\n   $ t=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\n   $ db.createPartitionedTable(t, `pt2, `id).append!(t)\n   $ getChunksMeta(\"/testDB%\");\n"
    },
    {
        "title": "getClusterDFSDatabases",
        "cal": "getClusterDFSDatabases()",
        "params": "None",
        "exp": "Return a list of the DFS databases in the cluster.",
        "eg": "\n   $ getClusterDFSDatabases()\n   [\"dfs://demohash\",\"dfs://myDataYesDB\",\"dfs://testDB\"]\n"
    },
    {
        "title": "getClusterDFSTables",
        "cal": "getClusterDFSTables()",
        "params": "None",
        "exp": "The function returns a vector that lists DFS tables in the cluster.",
        "eg": "\n   $ getClusterDFSTables()\n   [\"dfs://demohash/pt\",\"dfs://myDataYesDB/tick\",\"dfs://testDB/pt1\",\"dfs://testDB/pt2\"]\n\n"
    },
    {
        "title": "getCompletedQueries",
        "cal": "getCompletedQueries([top])",
        "params": "`top`  is a positive integer. It is optional with the default value of 10.",
        "exp": "Return descriptive information about the most recently finished *top* SQL queries on DFS databases at the local node. It returns a table with the following columns:",
        "eg": "  \n    $ n=1000000\n    $ ID=rand(10, n)\n    $ x=rand(1.0, n)\n    $ t=table(ID, x)\n    $ db=database(\"dfs://rangedb16\", RANGE,  0 5 10)\n    $ pt = db.createPartitionedTable(t, `pt, `ID)\n    $ pt.append!(t)\n    $ t1 = select count(x) from pt;\n    $ t2 = select * from pt where ID=1;\n    $ t3 = select * from pt where ID=5;\n\n    $ getCompletedQueries()\n"
    },
    {
        "title": "getConfig",
        "cal": "getConfigure([key])",
        "params": "`key` is a STRING indicating the name of a configuration parameter. It is an optional parameter.",
        "exp": "- If *key* is not specified, return a dictionary with all configuration information of the system. ",
        "eg": ""
    },
    {
        "title": "getConnections",
        "cal": "getConnections()",
        "params": "None",
        "exp": "Return information about all network connections on the local node. It can be executed on all nodes.",
        "eg": "  \n   $ getConnections()\n"
    },
    {
        "title": "getConsoleJobs",
        "cal": "getConsoleJobs()",
        "params": "None",
        "exp": "Return the descriptive information about the running interactive jobs of the local node.",
        "eg": "  \n    $ getConsoleJobs()\n"
    },
    {
        "title": "getControllerAlias",
        "cal": "getControllerAlias()",
        "params": "None",
        "exp": "Get the alias of the controller. The controller alias is specified by *localSite* in the configuration file *controller.cfg* by default.",
        "eg": "  \n    $ getControllerAlias();\n    master\n"
    },
    {
        "title": "getControllerElectionTick",
        "cal": "getControllerElectionTick()",
        "params": "None",
        "exp": "Obtain the election tick in the raft group composed of controllers. The election tick is specified by the parameter *tickCount* of command ``setRaftElectionTick`` or the configuration parameter *raftElectionTick*.  ",
        "eg": "1.30.16/2.00.4\n\nRelated Functions: :doc:`/FunctionsandCommands/CommandsReferences/s/setRaftElectionTick`, :doc:`/FunctionsandCommands/FunctionReferences/g/getRaftElectionTick`\n"
    },
    {
        "title": "getCurrentSessionAndUser",
        "cal": "getCurrentSessionAndUser()",
        "params": "None",
        "exp": "Get the sessionId and username of the current session. Return a tuple with sessionId as the first element and userId as the second element.",
        "eg": "\n    $ getCurrentSessionAndUser()\n    (1166953221,\"admin\")"
    },
    {
        "title": "getDFSDatabases",
        "cal": "getDFSDatabases()",
        "params": "None",
        "exp": "This function returns a vector that lists DFS databases on the current node.",
        "eg": "  \n   $ getDFSDatabases()"
    },
    {
        "title": "getDFSTablesByDatabase",
        "cal": "getDFSTablesByDatabase(directory)",
        "params": "`directory` the directory where a DFS database is located.",
        "exp": "This functions returns a vector that lists tables under the specified DFS directory.",
        "eg": "\n   $ getDFSTablesByDatabase(\"dfs://db\")\n   [\"dfs://db1/dt\", \"dfs://db1/dt1\"]\n"
    },
    {
        "title": "getDiskIOStat",
        "cal": "getDiskIOStat()",
        "params": "None",
        "exp": "Return a dictionary with 2 pairs.",
        "eg": "  \n    $ getDiskIOStat()\n"
    },
    {
        "title": "getEnv",
        "cal": "getEnv(name, [default])",
        "params": "`name`  is a string scalar indicating the name of an environment variable.",
        "exp": "Return the value of the specified environment variable. ",
        "eg": "  \n   $ getEnv(\"path\")\n   C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Program Files\\Docker\\Docker\\Resources\\bin;\n\n   $ getEnv(\"JAVA_HOME\");\n   C:\\Program Files\\Java\\jdk1.8.0_191\n\n   $ getEnv(\"not_exist\",\"not exist\")\n   not exist         \n"
    },
    {
        "title": "getFunctionViews",
        "cal": "getFunctionViews()",
        "params": "None",
        "exp": "Return all the function views. ",
        "eg": "  \n   $ getFunctionViews()\n"
    },
    {
        "title": "getGroupAccess",
        "cal": "getGroupAccess(groupIds)",
        "params": "`groupIds` a string scalar/vector indicating one or multiple group names.",
        "exp": "Return a table of privileges for one or multiple groups. It can only be executed by an administrator on the controller.",
        "eg": ""
    },
    {
        "title": "getGroupList",
        "cal": "getGroupList()",
        "params": "None",
        "exp": "Return a list of group names. It can only be executed by an administrator on the controller.",
        "eg": ""
    },
    {
        "title": "getGroupsByUserId",
        "cal": "getGroupsByUserId(userId)",
        "params": "`userId` a string indicating a user name.",
        "exp": "Return a string vector of the group names that the user belongs to. It can only be executed by an administrator on the controller.",
        "eg": ""
    },
    {
        "title": "getHomeDir",
        "cal": "getHomeDir()",
        "params": "None",
        "exp": "Return the home directory of the local node, which is defined in the configuration file dolphindb.cfg.",
        "eg": "  \n   $ getHomeDir()\n\n   /data/ddb/server\n"
    },
    {
        "title": "getJobMessage",
        "cal": "getJobMessage(jobId)",
        "params": "`jobId`  is a batch job ID.",
        "exp": "Retrieve the intermediate messages from a batch job. For details about batch jobs please refer to :doc:`/SystemManagement/BatchJobManagement`.",
        "eg": "  \n    $ def job1(n){\n    $    s = 0\n    $    for (x in 1 : n) {\n    $        s += sum(sin rand(1.0, 100000000)-0.5)\n    $        print(\"iteration \" + x + \" \" + s)\n    $ \n    $    }\n    $    return s\n    $ }\n    $ \n    $ job1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\n    "
    },
    {
        "title": "getJobReturn",
        "cal": "getJobReturn(jobId, [blocking=false])",
        "params": "`jobId` is a batch job ID.",
        "exp": "Retrieve the batch job result. For details about batch jobs please refer to :doc:`/SystemManagement/BatchJobManagement`.",
        "eg": "  \n    $ def job1(n){\n    $    s = 0\n    $    for (x in 1 : n) {\n    $        s += sum(sin rand(1.0, 100000000)-0.5)\n    $        print(\"iteration \" + x + \" \" + s)\n    $ \n    $    }\n    $    return s\n    $ }\n    $ \n    $ job1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\n    $ getJobReturn(job1_ID);\n\n    The job [job1_ID20210428] is not complete yet.\n    "
    },
    {
        "title": "getJobStat",
        "cal": "getJobStat()",
        "params": "None",
        "exp": "Monitor the number of jobs and tasks that are are running or in the job queue.",
        "eg": "  \n    $ getJobStat();\n\n    queuedLocalTasks->0\n    runnningJobs->0\n    queuedRemoteTasks->0\n    queuedJobs->0\n    runningLocalTasks->0\n"
    },
    {
        "title": "getJobStatus",
        "cal": "getJobStatus(jobId)",
        "params": "`jobId` is the batch job ID.",
        "exp": "Retrieve the status of a batch job. ",
        "eg": "  \n    $ def job1(n){\n    $    s = 0\n    $    for (x in 1 : n) {\n    $        s += sum(sin rand(1.0, 100000000)-0.5)\n    $        print(\"iteration \" + x + \" \" + s)\n    $ \n    $    }\n    $    return s\n    $ }\n    $ \n    $ job1_ID=submitJob(\"job1_ID\",\"\", job1, 100);\n    $ getJobStatus(job1_ID);\n"
    },
    {
        "title": "getLeftStream",
        "cal": "`joinEngine` is a table object returned by creating a join engine. The join engines currently supported by DolphinDB are:",
        "params": "Return the schema of the left table of the join engine. The data ingested into this schema will be ingested into *joinEngine*.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "getLevelFileIndexCacheStatus",
        "cal": "getLevelFileIndexCacheStatus()",
        "params": "None",
        "exp": "Obtain the memory usage of the indexes of all level files. Return a dictionary with the following keys:",
        "eg": "  \n    $ getLevelFileIndexCacheStatus()\n\n    usage->0\n    capacity->429496729"
    },
    {
        "title": "getLicenseExpiration",
        "cal": "getLicenseExpiration()",
        "params": "None",
        "exp": "Return the expiration date of the license on the current node. It can be used to verify whether the license file has been updated.",
        "eg": "  \n    $ getLicenseExpiration()\n    2021.09.30\n"
    },
    {
        "title": "getMachineFingerprint",
        "cal": "getMachineFingerprint(outputPath)",
        "params": "`outputPath` a string indicating the path of the file with fingerprint. ",
        "exp": "Generate a file with the fingerprint of the computer. This command must be executed by a logged-in user on Linux, or an administrator on Windows.",
        "eg": "\n    $ generateMachineFingerprint(\"/home/DolphinDB\")\n"
    },
    {
        "title": "getMemLimitOfQueryResult",
        "cal": "getMemLimitOfQueryResult()",
        "params": "None",
        "exp": "Get the memory limit (in units of bytes) for the result of each query. Return a DOUBLE value.",
        "eg": "  \n    $ setMemLimitOfQueryResult(0.2)\n    $ getMemLimitOfQueryResult() / 1024 / 1024 / 1024\n    0.2\n"
    },
    {
        "title": "getMemLimitOfTaskGroupResult",
        "cal": "getMemLimitOfTaskGroupResult()",
        "params": "None",
        "exp": "Get the memory limit of a task group sent from the current node. Return a DOUBLE value.",
        "eg": "  \n    $ setMemLimitOfTaskGroupResult(10)\n    $ getMemLimitOfTaskGroupResult() / 1024 / 1024 / 1024\n    10\n"
    },
    {
        "title": "getMemoryStat",
        "cal": "getMemoryStat()",
        "params": "None",
        "exp": "Return the allocated memory and the unused memory.",
        "eg": "  \n    $ getMemoryStat();\n\n    freeBytes->6430128\n    allocatedBytes->35463168\n"
    },
    {
        "title": "getNodeAlias",
        "cal": "getNodeAlias()",
        "params": "None",
        "exp": "Return the alias of the local node, which is defined in the configuration file dolphindb.cfg.",
        "eg": "  \n    $ getNodeAlias();\n\n    controller2\n"
    },
    {
        "title": "getNodeHost",
        "cal": "getNodeHost()",
        "params": "None",
        "exp": "Return the host name of the local node, which is defined in the configuration file dolphindb.cfg.",
        "eg": "  \n    $ getNodeHost();\n\n    10.6.0.6\n"
    },
    {
        "title": "getNodePort",
        "cal": "getNodePort()",
        "params": "None",
        "exp": "Return the port number of the local node, which is defined in the configuration file dolphindb.cfg.",
        "eg": "  \n    $ getNodePort();\n\n    8081\n"
    },
    {
        "title": "getNodeType",
        "cal": "getNodeType()",
        "params": "None",
        "exp": "Return the type of the node. ",
        "eg": "  \n    $ getNodeType();\n\n    2\n"
    },
    {
        "title": "getOLAPCacheEngineSize",
        "cal": "getOLAPCacheEngineSize()",
        "params": "None",
        "exp": "Obtain the memory status (in Byte) of the OLAP cache engine on the current node.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "getOLAPCacheEngineStat",
        "cal": "getOLAPCacheEngineStat()",
        "params": "None",
        "exp": "Get the status of the OLAP cache engine on the current node. The function can only be called on the data node.",
        "eg": "\n    $ getOLAPCacheEngineStat()\n"
    },
    {
        "title": "getOS",
        "cal": "getOS()",
        "params": "None",
        "exp": "Return the operating system where DolphinDB is running.",
        "eg": "  \n    $ getOS();\n\n    linux\n"
    },
    {
        "title": "getOSBit",
        "cal": "getOSBit()",
        "params": "None",
        "exp": "Indicate whether the operating system is 32-bit or 64-bit.",
        "eg": "  \n    $ getOSBit();\n\n    64\n"
    },
    {
        "title": "getPerf",
        "cal": "getPerf()",
        "params": "None",
        "exp": "``getPerf`` returns various performance monitoring metrics of the local node as a dictionary.",
        "eg": "  \n    $ getPerf();\n\n    lastMinuteWriteVolume->684\n    runningJobs->0\n    lastMsgLatency->0\n    maxLast100QueryTime->0\n    avgLoad->0.0040625\n    diskWriteRate->144\n    lastMinuteNetworkSend->228528\n    queuedJobs->0\n    lastMinuteNetworkRecv->525533\n    maxLast10QueryTime->0\n    medLast100QueryTime->0\n    maxRunningQueryTime->0\n    diskReadRate->2663\n    cumMsgLatency->0\n    medLast10QueryTime->0\n    diskFreeSpaceRatio->0\n    cpuUsage->0.306748466257669\n    memoryUsed->29053456\n    jobLoad->0\n    networkSendRate->4460\n    memoryAlloc->35463168\n    lastMinuteReadVolume->159940\n    networkRecvRate->8950\n    diskCapacity->0\n    diskFreeSpace->0\n"
    },
    {
        "title": "getPersistenceMeta",
        "cal": "getPersistenceMeta(table)",
        "params": "`table` is a table object.",
        "exp": "Return metadata of a shared stream table that has been enabled to be persisted to disk.",
        "eg": "  \n    $ colName=[\"time\",\"x\"]\n    $ colType=[\"timestamp\",\"int\"]\n    $ t = streamTable(100:0, colName, colType);\n    $ enableTableShareAndPersistence(table=t, tableName=`st, cacheSize=1200000)\n    $ \n    $ go;\n    $ \n    $ for(s in 0:200){\n    $    n=10000\n    $    time=2019.01.01T00:00:00.000+s*n+1..n\n    $    x=rand(10.0, n)\n    $    insert into st values(time, x)\n    $ }\n    $ \n    $ getPersistenceMeta(st);\n\n    astLogSeqNum->-1\n    sizeInMemory->800000\n    asynWrite->true\n    totalSize->2000000\n    raftGroup->-1\n    compress->true\n    memoryOffset->1200000\n    retentionMinutes->1440\n    sizeOnDisk->2000000\n    persistenceDir->/dolphindb/server/streamPersistDir/st\n    hashValue->0\n    diskOffset->0\n"
    },
    {
        "title": "getQueryStatus",
        "cal": "getQueryStatus()",
        "params": "None",
        "exp": "Get the status of a running query initialized on the current node. Return a table with the following columns:",
        "eg": "\n    getQueryStatus();\n"
    },
    {
        "title": "getRaftElectionTick",
        "cal": "getRaftElectionTick(groupId)",
        "params": "`groupId` is a positive integer indicating the raft group ID. Currently it can only be 1, referring to the ID of the raft group composed of controllers.",
        "exp": "Obtain the election tick in the specified raft group. The election tick is specified by the parameter *tickCount* of command ``setRaftElectionTick`` or the configuration parameter *raftElectionTick*. ",
        "eg": "1.30.16/2.00.4\n\nRelated Functions: :doc:`/FunctionsandCommands/CommandsReferences/s/setRaftElectionTick`, :doc:`/FunctionsandCommands/FunctionReferences/g/getControllerElectionTick`"
    },
    {
        "title": "getRecentJobs",
        "cal": "getRecentJobs(n)",
        "params": "`n` is a positive integer. If it is unspecified, return all batch jobs since the session is started.",
        "exp": "Retrieve the status of most recent n batch jobs on the local node. ",
        "eg": "  \n    $ def jobDemo(n){\n    $    s = 0\n    $    for (x in 1 : n) {\n    $        s += sum(sin rand(1.0, 100000000)-0.5)\n    $        print(\"iteration \" + x + \" \" + s)\n    $    }\n    $    return s\n    $ };\n    $ \n    $ submitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\n    $ submitJob(\"jobDemo2\",, jobDemo, 10);\n    $ getRecentJobs(10);\n"
    },
    {
        "title": "getRecoveryTaskStatus",
        "cal": "getRecoveryTaskStatus()",
        "params": "None",
        "exp": "Get the status of recovery tasks. This function can only be executed on a controller.",
        "eg": "  \n    $ getRecoveryTaskStatus();"
    },
    {
        "title": "getRecoveryWorkerNum",
        "cal": "getRecoveryWorkerNum()",
        "params": "None",
        "exp": "Get the number of worker threads used by the current node for chunk recovery.",
        "eg": "\n    $ resetRecoveryWorkerNum(2)\n    $ getRecoveryWorkerNum()\n    2\n"
    },
    {
        "title": "getRedoLogGCStat",
        "cal": "getRedoLogGCStat()",
        "params": "None",
        "exp": "Get the status of garbage collection of the redo log. Return a table containing the following columns:",
        "eg": "\n    getRedoLogGCStat()\n"
    },
    {
        "title": "getRightStream",
        "cal": "getRightStream(joinEngine)",
        "params": "`joinEngine` is a table object returned by creating a join engine. The join engines currently supported by DolphinDB are:",
        "exp": "Return the schema of the right table of the join engine. The data ingested into this schema will be inserted into *joinEngine*.",
        "eg": ""
    },
    {
        "title": "getRunningQueries",
        "cal": "getRunningQueries()",
        "params": "None",
        "exp": "Return descriptive information about the SQL queries that are being executed on the local node. It returns a table with the following columns:",
        "eg": "  \n    $ getRunningQueries();\n    "
    },
    {
        "title": "getScheduledJobs",
        "cal": "getScheduledJobs([jobIdPattern])",
        "params": "`jobIdPattern` is a string indicating a job ID or a pattern of job ID. It supports wildcard characters (% and ?).  ",
        "exp": "Return a table of scheduled jobs. If *jobIdPattern* is not specified, return all scheduled jobs. ",
        "eg": "  \n    $ getScheduledJobs();\n    "
    },
    {
        "title": "getSessionMemoryStat",
        "cal": "getSessionMemoryStat()",
        "params": "None",
        "exp": "Return information about memory usage of all sessions on the current node. It returns a table containing the following columns:",
        "eg": "  \n    $ t = getSessionMemoryStat();\n    $ t;\n"
    },
    {
        "title": "getSnapshotMsgId",
        "cal": "getSnapshotMsgId(engine)",
        "params": "`engine` is a built-in streaming engine, i.e., the abstract table object return by functions such as :doc:`../c/createReactiveStateEngine`.",
        "exp": "Get the message ID (msgId) of the last snapshot of the specified streaming engine when resubscibing after an interruption of subscription. If snapshot is enabled, during resubscription the parameter 'offset' of function :doc:`../s/subscribeTable` is set to getSnapshotMsgId(engine)+1. The streaming engine will load the snapshot and start to subcribe from the next message after getSnapshotMsgId(engine). ",
        "eg": ""
    },
    {
        "title": "getStreamEngine",
        "cal": "getStreamEngine(name)",
        "params": "`name`  is a string indicating the name of the stream engine. It is the only identifier of the stream engine. It can have letter, number and \"_\". It must start with a letter. ",
        "exp": "Return the handle of a stream engine. It can be used as the handler of a :doc:`../s/subscribeTable`. ",
        "eg": "  \n    $ share streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\n    $ outputTable = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\n    $ tradesAggregator = createTimeSeriesEngine(\"StreamAggregatorDemo\",3, 3, <[sum(qty)]>, trades, outputTable, `time, false,`sym, 50)\n    $ subscribeTable(, \"trades\", \"tradesAggregator\", 0, append!{tradesAggregator}, true)    \n    $ \n    $ def writeData(n){\n    $    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    $    symv =take(`A`B, n)\n    $    qtyv = take(1, n)\n    $    insert into trades values(timev, symv, qtyv)\n    $ }\n    $ \n    $ writeData(6);\n    $ h = getStreamEngine(\"StreamAggregatorDemo\")\n"
    },
    {
        "title": "getStreamEngineStat",
        "cal": "getStreamEngineStat()",
        "params": "None",
        "exp": "Return a dictionary of tables with various metrics about all stream engines. ",
        "eg": "  \n    $ share streamTable(10:0,`time`sym`price`qty,[TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades\n    $ outputTable1 = table(10000:0, `time`sym`sumQty, [TIMESTAMP, SYMBOL, INT])\n    $ outputTable2 = table(1:0, `time`avgPrice`sumqty`Total, [TIMESTAMP,DOUBLE,INT,DOUBLE])\n    $ tradesTsAggregator = createTimeSeriesEngine(name=\"TimeSeriesDemo\", windowSize=3, step=3, metrics=<[sum(qty)]>, dummyTable=trades, outputTable=outputTable1, timeColumn=`time, keyColumn=`sym, garbageSize=50)\n    $ tradesCsAggregator=createCrossSectionalEngine(name=\"CrossSectionalDemo\", metrics=<[avg(price), sum(qty), sum(price*qty)]>, dummyTable=trades, outputTable=outputTable2, keyColumn=`sym, triggeringPattern=`perRow)\n    $ subscribeTable(tableName=\"trades\", actionName=\"tradesTsAggregator\", offset=0, handler=append!{tradesTsAggregator}, msgAsTable=true)\n    $ subscribeTable(tableName=\"trades\", actionName=\"tradesCsAggregator\", offset=0, handler=append!{tradesCsAggregator}, msgAsTable=true)\n  \n    $ def writeData(n){\n    $    timev = 2000.10.08T01:01:01.001 + timestamp(1..n)\n    $    symv =take(`A`B, n)\n    $    pricev=take(102.1 33.4 73.6 223,n)\n    $    qtyv = take(60 74 82 59, n)\n    $    insert into trades values(timev, symv, pricev,qtyv)\n    $ }\n   \n    $ writeData(4);\n   \n    $ getStreamEngineStat().TimeSeriesEngine;\n    $ getStreamEngineStat().CrossSectionalEngine;\n"
    },
    {
        "title": "getStreamTableFilterColumn",
        "cal": "getStreamTableFilterColumn(streamTable)",
        "params": "`streamTable` is a stream table object.",
        "exp": "Return the filter column name of a stream table. The filter column is specified by the function :doc:`/FunctionsandCommands/CommandsReferences/s/setStreamTableFilterColumn`.",
        "eg": ""
    },
    {
        "title": "getStreamingLeader",
        "cal": "getStreamingLeader(groupId)",
        "params": "`groupId` is an integer indicating a Raft group ID",
        "exp": "Get the node alias of the Leader in a Raft group.",
        "eg": "  \n    $ getStreamingLeader(11);\n\n    DFS_NODE2"
    },
    {
        "title": "getStreamingRaftGroups",
        "cal": "getStreamingRaftGroups()",
        "params": "None  ",
        "exp": "Return a table with information about the Raft group that the local node belongs to. The first column is Raft group ID; the second column is information about the data nodes in the Raft group. ",
        "eg": "  \n    $ getStreamingRaftGroups();\n"
    },
    {
        "title": "getStreamingStat",
        "cal": "getStreamingStat()",
        "params": "None",
        "exp": "Monitor streaming process. Return a dictionary with the following tables:",
        "eg": ""
    },
    {
        "title": "getSubscriptionTopic",
        "cal": "getSubscriptionTopic(tableName, [actionName])",
        "params": "`tableName` a string indicating the name of the shared stream table.",
        "exp": "Return a tuple with 2 elements: the subscription topic name and a list of column names of the stream table. Can only be executed on a publisher node.",
        "eg": "The following script is executed on a node with alias \"rh8502\":\n"
    },
    {
        "title": "getSupportBundle",
        "cal": "getSupportBundle([dir])",
        "params": "`dir` the directory to store the support bundle. It is an optional parameter. The default path is <HomeDir> (which can be obtained with :doc:`getHomeDir`) for a standalone mode, and the sibling directory of <HomeDir> for a cluster mode. ",
        "exp": "Generate a file of support bundle containing all configuration information and return the file path. The function can only be called on a data node or compute node.",
        "eg": "\n    $ getSupportBundle()\n    /home/dolphindb/server/getSupportBundle.1655869793424\n\n    $ getSupportBundle(\"/home/dolphindb/sup\")\n    /home/dolphindb/sup/getSupportBundle.1655869853178\n\n"
    },
    {
        "title": "getSystemCpuUsage",
        "cal": "getSystemCpuUsage()",
        "params": "None",
        "exp": "This function returns the CPU utilization rate taken by a DolphinDB process on the current node. ",
        "eg": "  \n    $ getSystemCpuUsage();\n\n    1.771654\n"
    },
    {
        "title": "getSystemLoadAvg",
        "cal": "getSystemLoadAvg()",
        "params": "none",
        "exp": "Return real-time system load average. To use this function, we must set perfMonitoring=1 in the configuration file to enable performance monitoring. ",
        "eg": "  \n    $ getSystemLoadAvg();\n    5.664062\n"
    },
    {
        "title": "getTSDBCacheEngineSize",
        "cal": "getTSDBCacheEngineSize()",
        "params": "None",
        "exp": "Return a LONG type data that indicates the maximum memory (in byte) allocated to the TSDB cache engine.",
        "eg": "2.00.4"
    },
    {
        "title": "getTSDBCompactionTaskStatus",
        "cal": "getTSDBCompactionTaskStatus([count])",
        "params": "`count` a non-negative integer. Return the status of the latest count compaction tasks. The default value is 0, indicating that all completed compaction tasks (up to 256 latest tasks) and uncompleted tasks are returned.",
        "exp": "Obtain the status of TSDB level file compaction tasks. The function can only be executed on a data node. ",
        "eg": "\n    $ getTSDBCompactionTaskStatus()\n    "
    },
    {
        "title": "getTSDBMetaData",
        "cal": "getTSDBMetaData()",
        "params": "None",
        "exp": "Obtain the metadata of all chunks in the TSDB engine. The function can only be executed on a data node.",
        "eg": "2.00.4"
    },
    {
        "title": "getTables",
        "cal": "getTables(dbHandle)",
        "params": "`dbHandle` is a database handle.",
        "exp": "Return a list of all tables saved in the specified database.",
        "eg": "  \n    $ n=1000000\n    $ ID=rand(10, n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(10.0, n)\n    $ y=rand(10, n)\n    $ t1=table(ID, date, x)\n    $ t2=table(ID, date, y)\n    $ db = database(\"dfs://valueDB\", VALUE, 2017.08.07..2017.08.11)\n    $ pt1 = db.createPartitionedTable(t1, `pt1, `date)\n    $ pt1.append!(t1)\n    $ pt2 = db.createPartitionedTable(t2, `pt2, `date)\n    $ pt2.append!(t2);\n    $ getTables(db);\n\n    [\"pt1\",\"pt2\"]\n"
    },
    {
        "title": "getTablet",
        "cal": "getTablet(table, partition)",
        "params": "`table` is an in-memory partitioned table.",
        "exp": "Return a table or a list of tables corresponding to the specified partition or partitions.",
        "eg": "  \n    $ db=database(partitionType=RANGE, partitionScheme=2012.06.01 2012.06.10 2012.06.20 2012.07.01)\n    $ n=30\n    $ t=table(take(2012.06.01..2012.06.30, n) as date, n..1 as val)\n    $ pt=db.createPartitionedTable(table=t, tableName=`pt, partitionColumns=`date).append!(t);\n    \n    $ getTablet(pt, 2012.06.05);\n"
    },
    {
        "title": "getTabletsMeta",
        "cal": "getTabletsMeta([chunkPath], [tableName], [diskUsage=false], [top=1024])",
        "params": "`chunkPath` is the DFS path to one or multiple database chunks. It supports wildcards %, * and ?.",
        "exp": "Return metadata of specified tablet chunks on the local node. To get metadata about all tablet chunks of a distributed table, use ``getTabletsMeta`` together with :doc:`../p/pnodeRun`. ",
        "eg": "  \n    $ if(existsDatabase(\"dfs://testDB\")){\n    $    dropDatabase(\"dfs://testDB\")\n    $ }\n    $ db=database(\"dfs://testDB\", VALUE, 1..10)\n    $ n=1000000\n    $ t=table(rand(1..10, n) as id, rand(100.0, n) as x)\n    $ db.createPartitionedTable(t, `pt1, `id).append!(t)\n    $ n=2000000\n    $ t=table(rand(1..10, n) as id, rand(100.0, n) as x, rand(100, n) as y)\n    $ db.createPartitionedTable(t, `pt2, `id).append!(t)\n    $ update loadTable(\"dfs://testDB\",`pt1) set x=x*10\n    $ getTabletsMeta(\"/testDB/%\", `pt1, true);\n"
    },
    {
        "title": "getTopicProcessedOffset",
        "cal": "getTopicProcessedOffset(topic)",
        "params": "`topic`  is the subscription topic returned by function :doc:`../s/subscribeTable`",
        "exp": "If parameter persistOffset of function ``subscribeTable`` is true, return the offset of the last subscribed message that has been processed.",
        "eg": "  \n    $ share streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT]) as trades\n    $ trades_1 = streamTable(1000:0, `time`sym`qty, [TIMESTAMP, SYMBOL, INT])\n    $ topic=subscribeTable(tableName=\"trades\", actionName=\"trades_1\", offset=0, handler=append!{trades_1}, msgAsTable=true, persistOffset=true)\n    $ def writeData(n){\n    $    timev = 2018.10.08T01:01:01.001 + timestamp(1..n)\n    $    symv =take(`A`B, n)\n    $    qtyv = take(1, n)\n    $    insert into trades values(timev, symv, qtyv)\n    $ }\n    $ writeData(6);\n    $ select * from trades_1;\n"
    },
    {
        "title": "getTransactionStatus",
        "cal": "getTransactionStatus()",
        "params": "None",
        "exp": "Get the status of transactions. Return a table containing the following columns:",
        "eg": "\n    getTransactionStatus() \n"
    },
    {
        "title": "getUnresolvedTxn",
        "cal": "getUnresolvedTxn()",
        "params": "None",
        "exp": "Get transactions and nodes in the resolution phase. This can only be executed by an administrator on the controller.",
        "eg": ""
    },
    {
        "title": "getUserList",
        "cal": "getUserList()",
        "params": "Return a list of user names other than the administrators. It can only be executed by an administrator on the controller.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "getUsersByGroupId",
        "cal": "getUsersByGroupId(groupId)",
        "params": "`groupId` a string indicating a group name. ",
        "exp": "Return a string vector of the user names that belong to the specified group. It can only be executed by an administrator on the controller.",
        "eg": ""
    },
    {
        "title": "glm",
        "cal": "glm(ds, yColName, xColNames, [family], [link], [tolerance=1e-6], [maxIter=100])",
        "params": "`ds` is the data source to be trained. It can be generated with function :doc:`../s/sqlDS`.",
        "exp": "Fit a generalized linear model. The result is a dictionary with the following keys: coefficients, link, tolerance, family,  xColNames, tolerance, modelName, residualDeviance, iterations and dispersion. coefficients is a table with the coefficient estimate, standard deviation, t value and p value for each coefficient; modelName is \"Generalized Linear Model\"; iterations is the number of iterations; dispersion is the dispersion coefficient of the model.",
        "eg": "Fit a generalized linear model model with simulated data:\n"
    },
    {
        "title": "gmm",
        "cal": "gmm(X, k, [maxIter=300], [tolerance=1e-4], [randomSeed], [mean], [sigma])",
        "params": "`X` is the training data set. For univariate data, X is a vector; For multivariate data, X is a matrix/table where each column is a sample.",
        "exp": "Train the Gaussian Mixture Model (GMM) with the given data set. Return a dictionary with the following keys:",
        "eg": "\n    $ dataT = 6.8 7.2 5.3 9.4 6.5 11.2 25.6 0.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5\n    $ mean = [2, 2]\n    $ re = gmm(dataT, 2, 300, 1e-4, 42, mean)\n    $ re\n\n    sigma->[36.759822,36.759822]\n    modelName->Gaussian Mixture Model\n    prior->[0.5,0.5]\n    mean->[6.686667,6.686667]\n\n    $ dataT = transpose(matrix(3.2 1.5 2.6 7.8 6.3 4.2 5.1 8.9 11.2 25.8, 25.6 4.6 8.9 4.3 2.2 1.9 8.7 0.2 1.5 9.3))\n    $ mean = transpose(matrix([1, 0], [0, 1]))\n    $ re = gmm(dataT, 2, 300, 1e-4, 42, mean)\n    $ re\n\n    sigma->(#0        #1       \n    51.001369 18.273032\n    18.273032 9.34789  \n    ,#0       #1       \n    1.718475 0.629584 \n    0.629584 67.713701\n    )\n    modelName->Gaussian Mixture Model\n    prior->[0.558683,0.441317]\n    mean->\n    #0        #1       \n    11.152841 3.238262 \n    3.341493  10.996997"
    },
    {
        "title": "gmtime",
        "cal": "gmtime(X)",
        "params": "`X` is a scalar or a vector. The data type of X can be datetime, timestamp or nanotimestamp",
        "exp": "Convert X in local time zone to GMT (Greenwich Mean Time). GMT is also called UTC (Universal Time Coordinated). ",
        "eg": "The following examples were conducted in US Eastern time zone.\n"
    },
    {
        "title": "gram",
        "cal": "gram(ds, [colNames], [subMean], [normalize])",
        "params": "`ds` is one or multiple data source. It is usually generated by function :doc:`../s/sqlDS`.",
        "exp": "Calculate the Gram matrix of the selected columns in the given table.",
        "eg": "\n    $ x = [7,1,1,0,5,2]\n    $ y = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\n    $ t=table(x, y)\n    $ ds = sqlDS(<select * from t>);\n    $ gram(ds);\n"
    },
    {
        "title": "gramSchmidt",
        "cal": "gramSchmidt(X, [normalize = false])",
        "params": "`X` is a matrix where each column (as a vector) is linearly independent, i.e., the matrix has column full rank. It cannot contain any NULL values.",
        "exp": "This function converts a matrix of full column rank into an orthogonal matrix. It returns a matrix of DOUBLE type.",
        "eg": "\n    $ x = matrix([2 3 5, 3 6 2, 8 3 6]);\n    $ gramSchmidt(x)\n\n    col1    col2    col3\n    2.0000  1.2105  4.7932\n    3.0000  3.3157  -2.1968\n    5.0000  -2.4736 -0.5991\n\n    // If normalize=true, a normalized orthogonal matrix is returned.\n    $ gramSchmidt(x, true)\n\n    col1    col2    col3\n    0.3244\t0.2808\t0.9033\n    0.4867\t0.7693\t-0.414\n    0.8111\t-0.5739\t-0.1129\n\n\n    // An error is raised when the columns of the matrix are linearly dependent.\n    $ x = matrix([1 4, 2 5, 3 6]);  \n    $ gramSchmidt(x)\n\n    vector set must be linearly independent"
    },
    {
        "title": "grant",
        "cal": "grant(userId|groupId, accessType, [objs])",
        "params": "`userId` | `groupId` a string indicating a user name or a group name. ",
        "exp": "- Grant a user or group with the specified privilege. ",
        "eg": "All members of the group \"production\" can read all tables in all databases: \n"
    },
    {
        "title": "groupby",
        "cal": "groupby(func, funcArgs, groupingCol)",
        "params": "`func` is a function.",
        "exp": "Calculate func(funcArgs) for each *groupingCol* group. The result for each group can be a scalar/vector/dictionary, and the output of the template is a table of the same size as the number of *groupingCol* groups.",
        "eg": "\n    $ sym=`IBM`IBM`IBM`MS`MS`MS$symbol;\n    $ price=172.12 170.32 175.25 26.46 31.45 29.43;\n    $ qty=5800 700 9000 6300 2100 5300;\n    $ trade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;\n    $ groupby(avg, price, sym);\n"
    },
    {
        "title": "groups",
        "cal": "groups(X, [mode='dict'])",
        "params": "`X` is a vector.",
        "exp": "For each unique value in *X*, return the indices of all elements that hold the value.",
        "eg": "\n    $ x=NULL NULL 12 15 12 16 15 14 NULL NULL\n    $ groups(x);\n\n    16->[5]\n    ->[0,1,8,9]\n    12->[2,4]\n    14->[7]\n    15->[3,6]\n\n    $ groups(x, \"vector\")\n    [[0,1,8,9],[2,4],[7],[3,6],[5]]\n\n    $ groups(x, \"tuple\")\n    ([0,1,8,9],[2,4],[7],[3,6],[5])\n\n    $ groups(x, \"table\")\n"
    },
    {
        "title": "gt",
        "cal": "gt(X, Y) or X>Y ",
        "params": "`X` and `Y` is a scalar/pair/vector/matrix/set. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither X nor Y is a set, return the element-by-element comparison of X>Y.",
        "eg": "\n    $ 1 2 3 > 2;\n    [0,0,1]\n\n    $ 1 2 3>0 2 4;\n    [1,0,0]\n\n    $ 2:3>1:6;\n    1 : 0\n\n    $ m1=1..6$2:3;\n    $ m1;\n"
    },
    {
        "title": "haStreamTable",
        "cal": "haStreamTable(raftGroup, table, tableName, cacheLimit, [keyColumn], [retentionMinutes=1440])",
        "params": "`raftGroup` an integer greater than 1 indicating Raft group ID.",
        "exp": "Create a high-availability stream table. To use the function, we must enable high availability for streaming by specifying parameters `streamingHAMode` and `streamingRaftGroups` in cluster configuration file `cluster.cfg`.",
        "eg": "Suppose streamingRaftGroups=11:NODE1:NODE2:NODE3. Execute the following script on any data node of the Raft group to create a high-availability stream table `trades`:\n"
    },
    {
        "title": "hasNull",
        "cal": "hasNull(X)",
        "params": "`X` is a scalar/vector/matrix/table. ",
        "exp": "For a scalar, return true if it is NULL.",
        "eg": "\n    $ hasNull NULL;\n    1\n\n    $ x=00f; \n    $ hasNull x;\n    1\n\n    $ hasNull 5;\n    0\n\n    $ hasNull(1 2 NULL 4 NULL 6);\n    1\n\n    $ x=((NULL,1),2);\n    $ hasNull x;\n    0\n\n    $ m=(1 NULL 3 4 5 6)$2:3; \n    $ hasNull m;\n    1\n\n    $ t=table(`AAPL`IBM`MSFT as sym, 2200 NULL 4500 as qty); \n    $ hasNull(t);\n    1"
    },
    {
        "title": "hashBucket",
        "cal": "hashBucket(X, buckets)",
        "params": "`X` is a scalar/vector.",
        "exp": "Compute the hash value of X. The HASH partition is based on the hash value of the partitioning column elements. ",
        "eg": "\n    $ hashBucket(34 45 67, 10);    \n    [4,5,7]\n\n    $ hashBucket(`AAPL`TSLA`GS`MS`GE`BA`UAL`WMT, 10);\n    [9,4,1,8,3,7,5,2]"
    },
    {
        "title": "head",
        "cal": "head(X, [n=1])",
        "params": "`X` is a vector/matrix/table.",
        "exp": "Return the first n element(s) of a vector, or the first n columns of a matrix, or the first n rows of a table.",
        "eg": "\n    $ x=1..10; head(x);\n    1\n    \n    $ x=1..10$2:5;\n    $ x;\n"
    },
    {
        "title": "hex",
        "cal": "hex(X, [reverse=false])",
        "params": "`X` is an integer scalar/vector. ",
        "exp": "Convert integers to hexadecimal. The data type of the result is STRING.",
        "eg": "\n    $ hex(16 25);\n    [\"00000010\",\"00000019\"]\n\n    $ hex(16 25,true);\n    [\"10000000\",\"19000000\"]"
    },
    {
        "title": "highDouble",
        "cal": "highDouble(X)",
        "params": "`X` is a vector/scalar which must be 16-byte data type.",
        "exp": "It returns the higher 8 bytes of X, which is of DOUBLE type.",
        "eg": "\n   $ $ x=1 2 3 4\n   $ y=4 3 2 1\n   $ points = point(x, y)\n   $ x1 = highDouble(points)\n   [4,3,2,1]\n"
    },
    {
        "title": "hour",
        "cal": "hour(X)",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return the corresponding hour(s). The data type of the result is INTEGER.",
        "eg": "\n    $ hour(2012.12.03 01:22:01);\n    1\n"
    },
    {
        "title": "hourOfDay",
        "cal": "hourOfDay(X)",
        "params": "`X` is a scalar/vector of type TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP. ",
        "exp": "For each element in X, return a number from 0 to 23 indicating which hour of the day it falls in.",
        "eg": "\n    $ hourOfDay(00:46:12);\n    0\n\n    $ hourOfDay([2012.06.12T12:30:00,2012.10.28T17:35:00,2013.01.06T02:36:47,2013.04.06T08:02:14]);\n    [12,17,2,8]\n"
    },
    {
        "title": "ifNull",
        "cal": "ifNull(X, Y)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Determine whether X is NULL. If it is NULL, return X, if not, return Y.",
        "eg": "\n    $ x = take(1..5 join NULL 6,7)\n    $ y = 1..7\n    $ ifNull(x,y)\n    [1,2,3,4,5,,7]\n    $ y1 = int(take(1..5 join int(),6))$2:3\n    $ x1 = int(take(100,6))$2:3\n    $ ifNull(x1,y1)\n"
    },
    {
        "title": "ifValid",
        "cal": "ifValid(X, Y)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Determine whether X is NULL. If it is NULL, the value of X is returned, if not , the value of Y is returned.",
        "eg": "\n    $ x = take(1..5 join NULL 6,7)\n    $ y = 1..7\n    $ ifValid(x,y)\n    [1,2,3,4,5,6,6]\n    $ x1 = int(take(1..5 join int(),6))$2:3\n    $ y1 = int(take(100,6))$2:3\n    $ ifValid(x1,y1)\n"
    },
    {
        "title": "ifirstHit",
        "cal": "ifirstHit(func, X, target)",
        "params": "`func` can only be the following operators: >, >=, <, <=, !=, <>, ==.",
        "exp": "Return the index of the first element in *X* that satisfies the condition ``X func target`` (e.g. X>5).",
        "eg": ".. code-block:: console\n   :linenos:\n   :emphasize-lines: 2, 6\n\n    $ X = NULL 3.2 4.5 1.2 NULL 7.8 0.6 9.1\n    $ ifirstHit(<, X, 2.5) \n    3\n\n    // return -1 if no element in X satisfies the condition.\n    $ ifirstHit(>, X, 10.0) \n    -1\n\nRelated function: :doc:`../f/firstHit`"
    },
    {
        "title": "ifirstNot",
        "cal": "ifirstNot(X)",
        "params": "`X` is a vector, or a tuple of vectors of equal length, or a matrix. ",
        "exp": "If `X` is a vector, return the subscript of the first non-Null element. Return -1 if all elements are Null.",
        "eg": "\n    $ ifirstNot(NULL NULL 2 4 8 NULL 1);\n    2\n\n    $ ifirstNot(take(int(),5));\n    -1\n\n    $ x=NULL NULL 4 7 8 NULL\n    $ y=1 NULL NULL 4 NULL NULL\n    $ ifirstNot([x,y]);\n    3\n\n    $ x=NULL NULL 4 7 8 NULL\n    $ y=1 2 NULL NULL NULL 6\n    $ ifirstNot([x,y]);\n    -1\n\n    $ m=matrix(0 NULL 1 2 3, NULL 2 NULL 0 3);\n    $ m;\n"
    },
    {
        "title": "iif",
        "cal": "iif(cond, trueResult, falseResult)",
        "params": "`cond` is a Boolean scalar/vector/matrix. It can be an expression returning Boolean values.",
        "exp": "Element-wise conditional operation. `cond` is of Boolean type. If `cond[i]` is true, it returns trueResult(`cond[i]` ); otherwise it returns falseResult(`cond[i]` ). Ifcond[i]is NULL, it returns NULL.",
        "eg": "\n    $ iif(true true true false false false, 1..6, 6..1);\n    [1,2,3,3,2,1]\n\n    $ iif(1..6==3, 1, 2);\n    [2,2,1,2,2,2]\n    \n    $ x=9 6 8;\n    $ iif(x<=8, 10*x, 20*x-80);   \n    [100,60,80]\n"
    },
    {
        "title": "ilastNot",
        "cal": "ilastNot(X)",
        "params": "`X` is a vector, or a tuple of vectors of equal length, or a matrix. ",
        "exp": "If `X` is a vector, return the subscript of the last non-Null element. Return -1 if all elements are Null.",
        "eg": "\n    $ ilastNot(NULL NULL 2 4 8 1 NULL);\n    5\n\n    $ ilastNot(take(int(),5));\n    -1\n\n    $ x=NULL NULL 4 7 8 NULL\n    $ y=1 NULL NULL 4 NULL NULL\n    $ ilastNot([x,y]);\n    3\n\n    $ x=NULL NULL 4 7 8 NULL\n    $ y=1 2 NULL NULL NULL 6\n    $ ilastNot([x,y]);\n    -1\n\n    $ m=matrix(2 NULL 1 0 NULL, NULL 2 NULL 6 0);\n    $ m;\n"
    },
    {
        "title": "ilike",
        "cal": "ilike(X, pattern)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "Return a Boolean value scalar or vector indicating whether each element in X fits a specific pattern. The comparison is case insensitive.",
        "eg": "\n    $ ilike(`ABCDEFG, `de);\n    0\n\n    $ ilike(`ABCDEFG, \"%de%\");\n    1\n\n    $ a=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\n    $ a ilike  \"%OO%\";\n    [0,0,0,1,1,0]\n\n    $ a[a ilike  \"%OO%\"];\n    [\"Goog\",\"YHOO\"]\n"
    },
    {
        "title": "imax",
        "cal": "imax(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "If `X` is a vector, return the position of the element with the largest value in `X`. If there are multiple identical maximum values, return the position of the first maximum value starting from the left.",
        "eg": "\n    $ x = 1.2 2 NULL 6 -1 6;\n    $ imax(x);                \n    3\n\n    $ x = 5 3 1 6 4 6 $ 3:2;\n    $ imax(x);\n    (0,1)\n\n    $ x=array(int,0);\n    $ x;\n    []\n\n    $ imax(x);\n    -1\n    // for an empty vector, imax returns -1. \n\n    $ m=matrix(1 2 3, 6 5 4);\n    $ m;\n"
    },
    {
        "title": "imin",
        "cal": "imin(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "If `X` is a vector, return the position of the minimum value in a vector or a matrix. If there are multiple identical minimum values, return the position of the first minimum value starting from the left. As with all aggregate functions, NULL values are not included in the calculation.",
        "eg": "\n   $ x = 1.2 2 NULL -1 6 -1\n   $ imin(x);                 \n   3\n\n   $ x = 5 3 1 6 4 1 $ 3:2\n   $ imin(x);\n   [2,2]\n"
    },
    {
        "title": "imr",
        "cal": "imr(ds, initValue, mapFunc, [reduceFunc], [finalFunc], terminateFunc, [carryover=false])",
        "params": "`ds` the list of data sources. It must be a tuple with each element as a data source object. Even if there is only one data source, we still need a tuple to wrap the data source. In iterative computing, data sources are automatically cached and the cache will be cleared after the last iteration.",
        "exp": "DolphinDB offers function ``imr`` for iterative computing based on the map-reduce methodology. Each iteration uses the result from the previous iteration and the input dataset. The input dataset for each iteration is unchanged so that it can be cached. Iterative computing requires initial values for the model parameters and a termination criterion.",
        "eg": "The following is an example of distributed median calculation. The data are distributed on multiple nodes and we would like to calculate the median of a variable. First, for each data source, put the data into buckets and use the map function to count the number of data points in each bucket. Then use the reduce function to merge the bucket counts from multiple data sources. Locate the bucket that contains the median. In the next iteration, the chosen bucket is divided into smaller buckets. The iterations will finish when the size of the chosen bucket is no more than the specified number.\n"
    },
    {
        "title": "in",
        "cal": "in(X, Y)",
        "params": "`X` is a scalar/vector.",
        "exp": "If Y is a scalar:",
        "eg": "\n   $ in(3 3 5 2, 2 3);\n   [true,true,false,true]\n\n   $ x=dict(INT,DOUBLE);\n   $ x[1, 2, 3]=[4.5, 6.6, 3.2]; \n   $ x;           \n   3->3.2\n   1->4.5\n   2->6.6\n\n   $ in(1..6, x);\n   [true,true,true,false,false,false]\n\n   $ t = table(1 3 5 7 9 as id)\n   $ 2 3 in t\n   [false,true]\n\n   $ kt = keyedTable(`name`id,1000:0,`name`id`age`department,[STRING,INT,INT,STRING])\n   $ insert into kt values(`Tom`Sam`Cindy`Emma`Nick, 1 2 3 4 5, 30 35 32 25 30, `IT`Finance`HR`HR`IT)\n   $ in((`Tom`Cindy, 1 3), kt);\n   [true,true]\n\n   $ t1 = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\n   $ insert into t1 values(`IBM`MSFT`GOOG, ['B','S','B'], 10.01 10.02 10.03, 10 10 20)\n   $ in((`IBM`MSFT, ['S','S']), t1);\n   [false,true]\n"
    },
    {
        "title": "indexedSeries",
        "cal": "indexedSeries(index, value)",
        "params": "`index` and  `value` are vectors of the same length. index must be monotonically increasing with no duplicate values.",
        "exp": "``indexedSeries`` supports alignment operations for panel data. When performing binary operations between matrices or vectors, calculations are performed on the corresponding elements, and the shape of these matrices or vertors must be the same. ",
        "eg": "Example 1. Length can be equal or unequal in operations between indexed series, The data is aligned according to the *index*.\n"
    },
    {
        "title": "indexedTable",
        "cal": "indexedTable(keyColumns, X, [X1], [X2], .....)",
        "params": "`keyColumns` is a string scalar or vector indicating the name(s) of the primary key column(s). ",
        "exp": "Create an indexed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns.",
        "eg": "`Example 1. Create an indexed table.`\n\nThe first scenario:\n"
    },
    {
        "title": "int",
        "cal": "int(X)",
        "params": "`X` can be data of any types.",
        "exp": "Convert X to the data type of INT. ",
        "eg": "\n   $ x=int();      \n   $ x;              \n   00i                \n   $ typestr x;      \n   INT              \n\n   $ int(`10.9);\n   10\n\n   $ int(2147483647);\n   2147483647\n\n   $ int(2147483648);      \n   00i\n   // the maximum value for an INT is 2^31-1=2147483647"
    },
    {
        "title": "int128",
        "cal": "int128(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Convert STRING into INT128 data type. ",
        "eg": "\n   $ a=int128(\"e1671797c52e15f763380b45e841ec32\")\n   e1671797c52e15f763380b45e841ec32\n\n   $ typestr(a);\n   INT128\n"
    },
    {
        "title": "integral",
        "cal": "integral(func, start, end, [start2], [end2])",
        "params": "`func` is a unary function. ",
        "exp": "Return the integral of `func` from start to end.",
        "eg": "\n   $ integral(abs, -10, 10);\n   100\n\n   $ integral(acos, [0.1, -0.10], [0.3, 0.10]);\n   [0.273816,0.314159]\n\n   $ integral(acosh, [1, 2, 9, 9], 10);\n   [19.982354,19.080489,2.941187,2.941187]\n\n   $ integral(pow{,3}, 5, 9);\n   1484\n\n   $ integral(abs, NULL, NULL);\n   00F  \n\n   $ def f(x1,x2){\n   $    fx=100*(x2-x1*2)+square(1-x1)\n   $    return fx\n   $ }\n\n   $ integral(f,0,1,7,1)\n   -1802\n\n   $ integral(f,[0,1,2,3],7,2,[0,1,2,3])\n   [8255.333333, 8256, 7856.666667, 7061.333333]\n"
    },
    {
        "title": "interpolate",
        "cal": "interpolate(X, [method='linear'], [limit], [inplace=false], [limitDirection='forward'], [limitArea])",
        "params": "`X` is a numeric vector. ",
        "exp": "Fill the NULL values in a vector. ",
        "eg": "\n   $ a=[NULL,NULL,1,2,NULL,NULL,5,6,NULL,NULL];\n\n   $ interpolate(a);\n   [,,1,2,3,4,5,6,6,6]\n\n   $ interpolate(X=a, method=\"pad\");\n   [,,1,2,2,2,5,6,6,6]\n\n   $ interpolate(X=a, limitDirection='both');\n   [1,1,1,2,3,4,5,6,6,6]\n\n   $ interpolate(X=a, limit=1, limitDirection='both');\n   [,1,1,2,3,4,5,6,6,]\n\n   $ interpolate(X=a, limitDirection='both', limitArea='outside');\n   [1,1,1,2,,,5,6,6,6]\n\n   $ a;\n   [,,1,2,,,5,6,,]\n\n   $ interpolate(X=a, limitDirection='backward', inplace=true);\n   [1,1,1,2,3,4,5,6,,]\n\n   $ a;\n   [1,1,1,2,3,4,5,6,,]"
    },
    {
        "title": "intersection",
        "cal": "intersection(X, Y) or X&Y",
        "params": "`X` and `Y` can be sets, or integer scalars/vectors of the same length. ",
        "exp": "If both `X` and `Y` are sets, return the intersection of the two sets.",
        "eg": "\n   $ x=set([5,5,3,4,6])\n   $ y=set(8 9 4 4 6)\n   $ x & y;\n\n   $ set(4,6)\n\n   $ 6 7 8 & 4 5 6;\n   [4,5,0]"
    },
    {
        "title": "invBeta",
        "cal": "invBeta(alpha, beta, X)",
        "params": "The shape parameters `alpha` and `bata` are positive floating numbers.",
        "exp": "Return the value of a beta inverse cumulative distribution function. ",
        "eg": "\n   $ invBeta(2.31, 0.627, [0.001, 0.5, 0.999]);\n   [0.068102, 0.852866, 0.999994]\n\n   $ invBeta(2.31, 0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.471316, 0.717156, 0.852866, 0.939378, 0.989912]]"
    },
    {
        "title": "invBinomial",
        "cal": "invBinomial(trials, p, X)",
        "params": "`trials` is a positive integer.",
        "exp": "Return the value of a binomial inverse cumulative distribution function. ",
        "eg": "\n   $ invBinomial(10, 0.1, [0.1, 0.5, 0.9]);\n   [0, 1, 2]\n\n   $ invBinomial(12,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [5, 7, 8, 8, 10]"
    },
    {
        "title": "invChiSquare",
        "cal": "invChiSquare(df, X)",
        "params": "`df` is a positive integer indicating the degree of freedom of a chi-squared distribution.",
        "exp": "Return the value of a chi-squared inverse cumulative distribution function. ",
        "eg": "\n   $ invChiSquare(1, [0, 0.05, 0.15, 0.25]);\n   [0, 0.003932, 0.035766, 0.101531]\n\n   $ invChiSquare(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n\n   [0.015791, 0.148472, 0.454936, 1.074194, 2.705543]"
    },
    {
        "title": "invExp",
        "cal": "invExp(mean, X)",
        "params": "`mean` is the mean of an exponential distribution.",
        "exp": "Return the value of an exponential inverse cumulative distribution function. ",
        "eg": "\n   $ invExp(1, [0.05 0.15 0.25 0.35]);\n   [0.051293, 0.162519, 0.287682, 0.430783]\n\n   $ invExp(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.105361, 0.356675, 0.693147, 1.203973, 2.302585]"
    },
    {
        "title": "invF",
        "cal": "invF(numeratorDF, denominatorDF, X)",
        "params": "`numeratorDF` and `denominatorDF` are positive integers indicating degrees of freedom of an F distribution. ",
        "exp": "Return the value of an F inverse cumulative distribution function.",
        "eg": "\n   $ invF(2.31, 0.627, [0.001, 0.5, 0.7]);\n   [0.002024, 2.69427, 14.992595]\n\n   $ invF(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.146649, 0.718555, 2.69427, 14.992595, 508.444221]"
    },
    {
        "title": "invGamma",
        "cal": "invGamma(shape, scale, X)",
        "params": "The shape parameter `shape` is a positive floating number.",
        "exp": "Return the value of a gamma inverse cumulative distribution function. ",
        "eg": "\n   $ invGamma(2.31, 0.627, [0.001, 0.5, 0.999]);\n   [0.049713, 1.245583, 6.191955]\n\n   $ invGamma(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.437696, 0.843572, 1.245583, 1.760732, 2.724121]"
    },
    {
        "title": "invLogistic",
        "cal": "invLogistic(mean, s, X)",
        "params": "`mean` is the mean of a logistic distribution.",
        "exp": "Return the value of a logistic inverse cumulative distribution function. ",
        "eg": "\n   $ invLogistic( 2.31, 0.627, [0.5, 0.3, 0.5, 0.7, 0.1]);\n   [2.31, 1.778744, 2.31, 2.841256, 0.93234]"
    },
    {
        "title": "invNormal",
        "cal": "invNormal(mean, stdev, X)",
        "params": "`mean` is the mean of a normal distribution.",
        "exp": "Return the value of a normal inverse cumulative distribution function. ",
        "eg": "\n   $ invNormal(0,1,0.33);\n   -0.439913\n\n   $ invNormal(10, 20, [0.1 0.2 0.3]);\n   [-15.631031, -6.832425, -0.48801]"
    },
    {
        "title": "invPoisson",
        "cal": "invPoisson(mean, X)",
        "params": "`mean` is the mean of a Poisson distribution.",
        "exp": "Return the value of a Poisson inverse cumulative distribution function.",
        "eg": "\n   $ invPoisson(1, [0.91, 0.92, 0.93]);\n   [2, 3, 3]\n\n   $ invPoisson(3, [0.81, 0.83, 0.95, 0.97, 0.99]);\n   [4, 5, 6, 7, 8]"
    },
    {
        "title": "invStudent",
        "cal": "invStudent(df, X)",
        "params": "`df` is a positive floating number indicating the degree of freedom of a Student's t-distribution.",
        "exp": "Return the value of a Student's t inverse cumulative distribution function. ",
        "eg": "\n   $ invStudent(1, [0.15, 0.25, 0.35]);\n   [-1.962611, -1, -0.509525]\n\n   $ invStudent(1, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [-3.077684, -0.726543, 0, 0.726543, 3.077684]"
    },
    {
        "title": "invUniform",
        "cal": "invUniform(lower, upper, X)",
        "params": "`lower` and `upper` are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.",
        "exp": "Return the value of an uniform inverse cumulative distribution function. ",
        "eg": "\n   $ invUniform(0.627, 2.31, [0.001, 0.5, 0.999]);\n   [0.628683, 1.4685, 2.308317]\n\n   $ invUniform(0.627, 2.31, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.7953, 1.1319, 1.4685, 1.8051, 2.1417]"
    },
    {
        "title": "invWeibull",
        "cal": "invWeibull(alpha, beta, X)",
        "params": "The scale parameter `alpha` and the shape parameter `beta` are both positive floating numbers. ",
        "exp": "Return the value of a Weibull inverse cumulative distribution function. ",
        "eg": "\n   $ invWeibull(2.31, 0.627, [0.001, 0.5, 0.999]);\n   [0.031525, 0.535009, 1.447494]\n\n   $ invWeibull(2.31,0.627, [0.1, 0.3, 0.5, 0.7, 0.9]);\n   [0.236692, 0.401279, 0.535009, 0.679464, 0.899644]"
    },
    {
        "title": "inverse",
        "cal": "inverse(X)",
        "params": "`X` is a matrix.",
        "exp": "Return the inverse matrix of `X` if it is invertible.",
        "eg": "\n   $ x=1..4$2:2;\n   $ x;\n"
    },
    {
        "title": "ipaddr",
        "cal": "ipaddr(X)",
        "params": "`X` is a string scalar/vector. ",
        "exp": "Convert STRING into IPADDR (IP address) data type. ",
        "eg": "\n   $ a=ipaddr(\"192.168.1.13\");\n   $ a;\n   192.168.1.13\n\n   $ typestr(a);\n   IPADDR"
    },
    {
        "title": "isAlNum",
        "cal": "isAlNum(X)",
        "params": "`X` is a STRING scalar or vector.  ",
        "exp": "Return \"true\" if all characters in string X are alphanumeric (either alphabets or numbers). ",
        "eg": "\n   $ isAlNum(\"123456\");\n   true\n\n   $ isAlNum(\"1And1\");\n   true\n\n   $ isAlNum(\"10.05\");\n   false\n\n   $ isAlNum(string());\n   false\n\n"
    },
    {
        "title": "isAlpha",
        "cal": "isAlpha(X)",
        "params": "`X` is a STRING scalar or vector.  ",
        "exp": "Return \"true\" if all characters in the string are alphabets. For STRING type NULLs, return \"false\". ",
        "eg": "\n   $ isAlpha(\"hello\");\n   true\n\n   $ isAlpha(\"hello world\");\n   false\n\n   $ isAlpha(\"1And1\");\n   false\n\n   $ isAlpha(string());\n   false"
    },
    {
        "title": "isChunkNodeInit",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "isControllerInitialized",
        "cal": "isControllerInitialized()",
        "params": "None",
        "exp": "Check whether the controller is initialized. True if it is initialized, otherwise false. In a cluster, it is called only on the controller; in a cluster with high-availability enabled, it is called only on the leader.",
        "eg": "\n    $ isControllerInitialized()\n    true\n"
    },
    {
        "title": "isDataNodeInitialized",
        "cal": "isDataNodeInitialized()",
        "params": "None",
        "exp": "Return true if the current node has been started; return false otherwise. The function can only be executed on data nodes or compute nodes and cannot be executed on agent or controller nodes.",
        "eg": "\n   $ isDataNodeInitialized()\n   true"
    },
    {
        "title": "isDecimal",
        "cal": "isDecimal(X)",
        "params": "`X` is a STRING scalar or vector.  ",
        "exp": "Return \"true\" if all characters in the string are numbers. For STRING type NULLs, return \"false\". ",
        "eg": "\n   $ isDecimal(\"123456\");\n   true\n\n   $ isDecimal(\"1And1\");\n   false\n\n   $ isDecimal(\"10.05\");\n   false\n\n   $ isDecimal(string());\n   false"
    },
    {
        "title": "isDigit",
        "cal": "isDigit(X)",
        "params": "`X` is a STRING scalar or vector.  ",
        "exp": "Return \"true\" if all characters in the string are numbers. For STRING type NULLs, return \"false\". ",
        "eg": "\n   $ isDigit(\"123456\");\n   true\n\n   $ isDigit(\"1And1\");\n   false\n\n   $ isDigit(\"10.05\");\n   false\n\n   $ isDigit(string());\n   false"
    },
    {
        "title": "isDuplicated",
        "cal": "isDuplicated(X, [keep=FIRST])",
        "params": "`X` is a vector or a tuple of vectors of same length.",
        "exp": "Return a vector or a tuple of vectors of Boolean values. If an element has no duplicate values, it returns 0. ",
        "eg": "\n   $ v = [1,3,1,-6,NULL,2,NULL,1]\n   $ isDuplicated(v,FIRST);\n   [0,0,1,0,0,0,1,1]\n   // 1 appears three time in v, the locations are the 0th, the 2nd and the 7th. Since keep = FIRST, the 0th result is set to false, and the 2nd and 7th results are set to true.\n\n   $ v = [1,3,1,-6,NULL,2,NULL,1]\n   $ isDuplicated(v,LAST);\n   [1,0,1,0,1,0,0,0]\n   // 1 appears three time in v, the locations are the the 0th, the 2nd and the 7th. Since keep = LAST, the 7th result is set to false, and the 0th and 2nd results are set to true.\n\n   $ v = [1,3,1,-6,NULL,2,NULL,1]\n   $ isDuplicated(v,NONE);\n   [1,0,1,0,1,0,1,1]\n   // 1 appears three time in v, the locations are the 0th, the 2nd and the 7th. Since keep = NONE, the 0th, the 2nd and the 7th result are all set to true.\n"
    },
    {
        "title": "isIndexedMatrix",
        "cal": "isIndexedMatrix(X)",
        "params": "`X` is a matrix.",
        "exp": "Determine if `X` is an indexed matrix.",
        "eg": "\n   $ m=matrix(1..10, 11..20)\n   $ m.rename!(2020.01.01..2020.01.10, `A`B);\n\n   $ isIndexedMatrix(m);\n   0\n\n   $ m.setIndexedMatrix!()\n   $ isIndexedMatrix(m);\n   1"
    },
    {
        "title": "isIndexedSeries",
        "cal": "isIndexedSeries(X)",
        "params": "`X` is a matrix with only 1 column.",
        "exp": "Determine if `X` is an indexed series.",
        "eg": "\n   $ s=matrix(1..10).rename!(2020.01.01..2020.01.10, );\n\n   $ isIndexedSeries(s);\n   0\n\n   $ s.setIndexedSeries!()\n   $ isIndexedSeries(s);\n   1"
    },
    {
        "title": "isLeapYear",
        "cal": "isLeapYear(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is in a leap year.  ",
        "eg": "\n   $ isLeapYear(2012.06.12T12:30:00);\n   true\n\n   $ isLeapYear([2012.01.01,2013.01.01,2014.01.01,2015.01.01]);\n   [true,false,false,false]"
    },
    {
        "title": "isLoggedIn",
        "cal": "isLoggedIn(userId)",
        "params": "`userId` a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.",
        "exp": "Return a Boolean value indicating whether the specified user is logged in. ",
        "eg": "\n   $ isLoggedIn(`AlexSmith)\n   0"
    },
    {
        "title": "isLower",
        "cal": "isLower(X)",
        "params": "`X` is a STRING scalar or vector. ",
        "exp": "Check whether all the case-based characters (letters) of the string are lowercase.",
        "eg": "\n   $ isLower(\"this is string example....wow!!!\");\n   true\n\n   $ isLower(\"THIS is string example....wow!!!\");\n   false\n\n   $ isLower(\"123456abc\");\n   true\n\n   $ isLower(\"123\");\n   false\n\n   $ isLower([\"  \",string()]);\n   [false,false]\n"
    },
    {
        "title": "isMonotonic",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "isMonotonicDecreasing",
        "cal": "isMonotonicDecreasing(X)",
        "params": "`X` is a scalar/vector. ",
        "exp": "Check whether the elements in `X` are monotonically decreasing.",
        "eg": "\n   $ a = [10,8,6,4,2]\n   $ isMonotonicDecreasing(a);\n   true \n\n   $ a = [10,8,6,7,2]\n   $ isMonotonicDecreasing(a);\n   false \n\n   $ a = [10,8,6,6,4,2]\n   $ isMonotonicDecreasing(a);\n   true\n\n   $ a = [10,8,6,NULL,4,2]\n   $ isMonotonicDecreasing(a);\n   false \n\n   $ a = [10,8,6,4,2,NULL]\n   $ isMonotonicDecreasing(a);\n   true\n"
    },
    {
        "title": "isMonotonicIncreasing",
        "cal": "isMonotonicIncreasing(X)",
        "params": "`X` is a scalar/vector. ",
        "exp": "Check whether the elements in `X` are monotonically increasing.",
        "eg": "\n   $ a = [2023.01M,2023.02M,2023.03M,2023.04M,2023.05M,2023.06M]\n   $ isMonotonicIncreasing(a);\n   true\n\n   $ a = [1,3,6,5,7,9]\n   $ isMonotonicIncreasing(a);\n   false\n\n   $ a = [1,3,3,5,7,9]\n   $ isMonotonicIncreasing(a);\n   true\n\n   $ a = [NULL,1,3,5,7,9]\n   $ isMonotonicIncreasing(a);\n   true \n\n   $ a = [1,3,5,NULL,7,9]\n   $ isMonotonicIncreasing(a);\n   false\n"
    },
    {
        "title": "isMonthEnd",
        "cal": "isMonthEnd(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the last day of a month.  ",
        "eg": "\n   $ isMonthEnd(2012.05.31);\n   true\n\n   $ isMonthEnd([2012.05.30,2012.05.31]);\n   [false,true]\n"
    },
    {
        "title": "isMonthStart",
        "cal": "isMonthStart(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the first day of a month. ",
        "eg": "\n   $ isMonthStart(2012.05.01);\n   true\n\n   $ isMonthStart([2012.05.01,2012.05.02]);\n   [true,false]\n"
    },
    {
        "title": "isNanInf",
        "cal": "isNanInf(X, [includeNull=false])",
        "params": "`X` is a DOUBLE type scalar, vector or matrix.",
        "exp": "Check each element in X to see if it is a NaN/Inf value. Return a BOOLEAN type of the same length as X.",
        "eg": ""
    },
    {
        "title": "isNothing",
        "cal": "isNothing(X)",
        "params": "`X` is a scalar/vector. ",
        "exp": "\"Nothing\" is one of the two objects in VOID type. ",
        "eg": "\n   $ f=def(x,y): isNothing(y);\n   $ f(5,);\n   1\n\n   $ f(5, NULL);\n   0"
    },
    {
        "title": "isNull",
        "cal": "isNull(X)",
        "params": "`X` is a scalar/pair/vector/matrix. ",
        "exp": "Return 1 if an element is Null.",
        "eg": "\n   $ isNull(00i);\n   1\n\n   $ isNull(1 NULL NULL 6 NULL 7);\n   [0,1,1,0,1,0]\n\n   $ isNull(1/0);\n   1\n\n   $ x=1 NULL 5 NULL 4 6$2:3;\n   $ x;\n"
    },
    {
        "title": "isNumeric",
        "cal": "isNumeric(X)",
        "params": "`X` is a STRING scalar or vector.",
        "exp": "Return \"true\" if all characters in the string are numbers. For STRING type NULLs, return \"false\". ",
        "eg": "\n   $ isNumeric(\"123456\");\n   true\n\n   $ isNumeric(\"1And1\");\n   false\n\n   $ isNumeric(\"10.05\");\n   false\n\n   $ isNumeric(string());\n   false"
    },
    {
        "title": "isPeak",
        "cal": "isPeak(X, [strict=true])",
        "params": "`X` is a numeric vector/matrix/table.",
        "exp": "If *X* is a vector, check if each element in *X* is the peak. ",
        "eg": "\n    $ v = [1, 2.2, 2.2, 2.2, 2.3, 1, 1.2]\n    $ isPeak(v)\n    [0,0,0,0,1,0,0]\n\n    $ v = [1, 2.2, 2.2, 2.2, 1.6, 1, 1.2]\n    $ isPeak(v)\n    [0,0,0,0,0,0,0]\n    $ isPeak(v, false)\n    [0,1,1,1,0,0,0]\n\n    // Perform the calculations on each column in a matrix\n    $ m = matrix(3.3 2.8 5.6 NULL 2.5 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\n    $ isPeak(m)\n"
    },
    {
        "title": "isQuarterEnd",
        "cal": "isQuarterEnd(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the last day of a quarter. ",
        "eg": "\n   $ isQuarterEnd(2012.06.30);\n   true\n\n   $ isQuarterEnd([2012.06.30,2012.07.01]);\n   [true,false]\n"
    },
    {
        "title": "isQuarterStart",
        "cal": "isQuarterStart(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the first day of a quarter. ",
        "eg": "\n   $ isQuarterStart(2012.04.01);\n   true\n\n   $ isQuarterStart([2012.04.01,2012.05.01]);\n   [true,false]\n"
    },
    {
        "title": "isSorted",
        "cal": "isSorted(X, [ascending=true])",
        "params": "`X` is a vector.",
        "exp": "Check whether a vector is sorted or not. ",
        "eg": "\n   $ x=NULL 1 2 3\n   $ isSorted(x);\n   1\n\n   $ t=table(9 7 5 3 as x, 1 5 2 4 as y)\n   $ t.x.isSorted(false);\n   1\n\n   $ t.y.isSorted();\n   0"
    },
    {
        "title": "isSpace",
        "cal": "isSpace(X)",
        "params": "`X` is a STRING scalar or vector.",
        "exp": "Check whether the string `X` consists of only space. Return \"true\" if all characters in `X` are space, \"\\t\" (tab), \"\\r\" (carriage return) or \"\\n\" (newline escape). ",
        "eg": "\n   $ isSpace(\"hello world\");\n   false\n\n   $ isSpace(\" \\t \");\n   true\n\n   $ isSpace(string());\n   false"
    },
    {
        "title": "isTitle",
        "cal": "isTitle(X)",
        "params": "`X` is a STRING scalar or vector. ",
        "exp": "Check if `X` is a titlecased string, which has the first character in each word uppercase and the remaining all characters lowercase alphabets.",
        "eg": "\n   $ isTitle(\"Hello World\");\n   true\n\n   $ isTitle(\"Hello world\");\n   false\n\n   $ isTitle([\"Hello\",\"468\",\"  \"]);\n   [true,false,false]\n\n   $ isTitle(\"1And1\");\n   true\n"
    },
    {
        "title": "isUpper",
        "cal": "isUpper(X)",
        "params": "`X` is a STRING scalar or vector.  ",
        "exp": "Check whether all the case-based characters (letters) of the string are uppercase.",
        "eg": "\n   $ isUpper(\"THIS IS STRING EXAMPLE....WOW!!!\");\n   true\n\n   $ isUpper(\"THIS is string example....wow!!!\");\n   false\n\n   $ isUpper(\"123456ABC\");\n   true\n\n   $ isUpper(\"123\");\n   false\n\n   $ isUpper([\"  \",string()]);\n   [false,false]\n"
    },
    {
        "title": "isValid",
        "cal": "isValid(X)",
        "params": "`X` is a scalar/vector/matrix.  ",
        "exp": "Determine if each element of X is NULL. Return 1 if at least one element is not NULL and 0 otherwise. ",
        "eg": "\n   $ isValid(00i);\n   0\n\n   $ isValid(1 NULL NULL 6 NULL 7);\n   [1,0,0,1,0,1]\n\n   $ isValid(1/0);\n   0"
    },
    {
        "title": "isValley",
        "cal": "isValley(X, [strict=true])",
        "params": "`X` is a numeric vector/matrix/table.",
        "exp": "If *X* is a vector, check if each element in *X* is the valley.",
        "eg": "\n    $ v = [3.1, 2.2, 2.2, 2.2, 1.3, 2.1, 1.2]\n    $ isValley(v)\n    [0,0,0,0,1,0,0]\n\n    $ v = [3.1, 2.2, 2.2, 2.2, 2.6, 1, 1.2]\n    $ isValley(v)\n    [0,0,0,0,0,1,0]\n    $ isValley(v, false)\n    [0,1,1,1,0,1,0]\n\n    // Perform the calculations on each column in a matrix\n    $ m = matrix(5.3 5.8 5.6 NULL 5.7 1.2, 4.5 3.5 4.6 2.8 3.9 NULL)\n    $ isValley(m)\n"
    },
    {
        "title": "isVoid",
        "cal": "isVoid(X)",
        "params": "`X` can be of any data form.",
        "exp": "Check if an object is VOID type. There are two types of objects with VOID type: NULL object and Nothing object. Please see :doc:`isNothing`.",
        "eg": "\n   $ isVoid(NULL);\n   1\n\n   $ isVoid(1 NULL 2);\n   0\n\n   // compare with function isNull\n   $ isNull(1 NULL 2);\n   [0,1,0]"
    },
    {
        "title": "isYearEnd",
        "cal": "isYearEnd(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the last day of a year.  ",
        "eg": "\n   $ isYearEnd(2012.12.31);\n   true\n\n   $ isYearEnd([2012.12.30,2012.12.31]);\n   [false,true]\n"
    },
    {
        "title": "isYearStart",
        "cal": "isYearStart(X)",
        "params": "`X` is a scalar/vector of type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Determine if each element in `X` is the first day of a year.  ",
        "eg": "\n   $ isYearStart(2012.01.01);\n   true\n\n   $ isYearStart([2012.01.01,2012.02.01]);\n   [true,false]\n"
    },
    {
        "title": "isort",
        "cal": "isort(X, [ascending=true])",
        "params": "`X` is a vector or a tuple of vectors of the same length.",
        "exp": "Instead of returning a sorted vector like :doc:`../s/sort!`, ``isort`` returns the indexes in the original vector for each element in the sorted vector. ",
        "eg": "\n   $ x = 4 1 3 2;   \n   $ y = isort(x);\n   $ y;             \n   [1,3,2,0]\n   // for the sorted x: [1 2 3 4], the first element 1 is from position 1 of the original x, the second element 2 is from position 3 of the original x, ... etc.    \n   $ x[y];                  \n   [1,2,3,4]      \n   // equivalent to sort!(x)\n\n   $ z=isort(x, false);   \n   $ z;                      \n   [0,2,3,1]                \n   $ x[z];                   \n   [4,3,2,1]            \n\n   $ x=2 2 1 1\n   $ y=2 1 1 2\n   $ isort([x,y]);\n   [2,3,1,0]\n   $ isort([x,y],[0,0]);\n   [0,1,3,2]\n"
    },
    {
        "title": "isort!",
        "cal": "isort!(X, [ascending=true], indices)",
        "params": "`X` is a vector or a tuple of vectors of the same length. ",
        "exp": "isort!(x, ascending, y) is equivalent to y[isort(x, ascending)]. The result is assigned to y.",
        "eg": "\n   $ x=3 1 NULL 2\n   $ y=5 7 8 3\n   $ isort!(x, false, y);\n   [5, 3, 7, 8]   \n   // after sorted, x is [3, 2, 1, NULL], the first element 3 is corresponding to 5 in y, the second element 2 is corresponding to 3 in y, the third element 1 is corresponding to 7 in y, ... and so on.\n\n   $ x=2 2 1 1\n   $ y=2 1 1 2\n   $ isort!([x,y],[1,0],5 4 3 2);\n   [2,3,5,4]"
    },
    {
        "title": "isortTop",
        "cal": "isortTop(X, top, [ascending=true])",
        "params": "`X` is a vector or a tuple of vectors of the same length.",
        "exp": "Return the first few elements of the result of isort(X, [ascending]). ",
        "eg": "\n   $ isortTop(2 1 4 3 6 5, 3);\n   [1,0,3]\n\n   $ isortTop(2 1 4 3 6 5, 3, false);\n   [4,5,2]\n"
    },
    {
        "title": "iterate",
        "cal": "iterate(init, coeffs, input)",
        "params": "`init` a scalar or a vector.",
        "exp": "If `init`, `coeffs` and `input` are all scalars, return a geometric sequence [`init*coeffs, init*coeffs^2, init*coeffs^3`, ...]. The length of the sequence is input.",
        "eg": ""
    },
    {
        "title": "join",
        "cal": "join(X,Y) or X<-Y",
        "params": "`X` and `Y` can be scalar/vector/matrix/table. ",
        "exp": "Merge X and Y.",
        "eg": "If X is a scalar, Y can be a scalar/vector. The result is a vector. \n"
    },
    {
        "title": "join!",
        "cal": "join!(X, Y)",
        "params": "`X` is a vector/matrix/table. ",
        "exp": "Merge `X` and `Y`, and assign the result to `X`. The resulting object has the same data type as `X`.  ",
        "eg": "If `X` is a vector, `Y` must be a scalar/vector. The result is a vector. \n"
    },
    {
        "title": "kama",
        "cal": "kama(X, window)",
        "params": "Calculate the Kaufman Adaptive Moving Average for `X` with a rolling `window`. The length of the window is given by the parameter `window`. The result is of the same length as `X`. The first (`window`\\-1) elements of the result are NULLs.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "keyedStreamTable",
        "cal": "keyedStreamTable(keyColumn, X, [X1], [X2], .....) ",
        "params": "`keyColumn` is a string scalar or vector indicating the name of the primary key columns. ",
        "exp": "Create a stream table with one or multiple columns as the primary key. The primary key must contain a unique value for each row. ",
        "eg": "`Example 1`\n"
    },
    {
        "title": "keyedTable",
        "cal": "keyedTable(keyColumns, X, [X1], [X2], .....)",
        "params": "`keyColumn` is a string scalar or vector indicating the name(s) of the primary key column(s). ",
        "exp": "Create an keyed table, which is a special type of in-memory table with primary key. The primary key can be one column or multiple columns. ",
        "eg": "`Example 1. Create a keyed table.`\n\nThe first scenario:\n"
    },
    {
        "title": "keys",
        "cal": "keys(X)",
        "params": "`X` is a dictionary/table/set. ",
        "exp": "Return the keys of a dictionary as a vector, or return the column names of a table as a vector, or convert a set into a vector.",
        "eg": "\n   $ z=dict(`INT,`DOUBLE)\n   $ z[5]=7.9\n   $ z[3]=6\n   $ z.keys();\n   [3,5]\n\n   $ t = table(1 2 3 as id, 4 5 6 as x, `IBM`MSFT`GOOG as name);\n   $ keys(t);\n   [\"id\",\"x\",\"name\"]\n\n   $ a=set(1 2 4)\n   $ a.keys();\n   [4,2,1]\n"
    },
    {
        "title": "kmeans",
        "cal": "kmeans(X, k, [maxIter=300], [randomSeed])",
        "params": "`X` is a table. Each row is an observation and each column is a feature.",
        "exp": "Solve the k-means problem. Return a dictionary with the following keys:",
        "eg": "\n   $ t = table(100:0, `x0`x1, [DOUBLE, DOUBLE])\n   $ x0 = norm(1.0, 1.0, 50)\n   $ x1 = norm(1.0, 1.5, 50)\n   $ insert into t values (x0, x1)\n   $ x0 = norm(2.0, 1.0, 50)\n   $ x1 = norm(-1.0, 1.5, 50)\n   $ insert into t values (x0, x1)\n   $ x0 = norm(-1.0, 1.0, 50)\n   $ x1 = norm(-3.0, 1.5, 50)\n   $ insert into t values (x0, x1);\n\n   $ model = kmeans(t, 3);\n   $ model;\n\n   centers->\n\n   #0        #1\n   --------- ---------\n   -1.048027 -3.809539\n   1.110899  1.24216  \n   1.677974  -1.19158\n\n   modelName->KMeans\n   model->KMeans\n   labels->[2,2,2,2,2,2,3,2,3,2,...]"
    },
    {
        "title": "knn",
        "cal": "knn(Y, X, type, nNeighbor, [power=2])",
        "params": "`Y` is a vector with the same length as the number of rows of `X`. Each element is a label corresponding to each row in `X`. ",
        "exp": "Inplement the k-nearest neighbors algorithm (k-NN) for classification and regression. Return a dictionary with the following keys:",
        "eg": "\n   $ height = 158 158 158 160 160 163 163 160 163 165 165 165 168 168 168 170 170 170\n   $ weight = 58 59 63 59 60 60 61 64 64 61 62 65 62 63 66 63 64 68\n   $ t=table(height, weight)\n   $ labels=take(1,7) join take(2,11)\n   $ model = knn(labels,t,\"classifier\", 5);"
    },
    {
        "title": "ksTest",
        "cal": "ksTest(X, Y)",
        "params": "`X` and `Y` are numeric vectors indicating the samples for the test.",
        "exp": "Conduct Kolmogorov-Smirnov test on `X` and `Y`.",
        "eg": "\n   $ x = norm(0.0, 1.0, 50)\n   $ y = norm(0.0, 1.0, 20)\n   $ ksTest(x, y);\n\n   ksValue->0.739301\n   pValue->0.645199\n   D->0.19\n   method->Two-sample Kolmogorov-Smirnov test"
    },
    {
        "title": "kurtosis",
        "cal": "kurtosis(X, [biased=true])",
        "params": "`X` is a vector/matrix.",
        "exp": "Return the kurtosis of *X*. The calculation skips NULL values.",
        "eg": "Please note that as the example below uses a random number generator, the result is slightly different each time it is executed. \n"
    },
    {
        "title": "lasso",
        "cal": "lasso(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
        "params": "`ds` is an in-memory table or a data source usually generated by the :doc:`../s/sqlDS` function. ",
        "exp": "Estimate a Lasso regression that performs L1 regularization.",
        "eg": "\n   $ y = [225.720746,-76.195841,63.089878,139.44561,-65.548346,2.037451,22.403987,-0.678415,37.884102,37.308288];\n   $ x0 = [2.240893,-0.854096,0.400157,1.454274,-0.977278,-0.205158,0.121675,-0.151357,0.333674,0.410599];\n   $ x1 = [0.978738,0.313068,1.764052,0.144044,1.867558,1.494079,0.761038,0.950088,0.443863,-0.103219];\n   $ t = table(y, x0, x1);\n\n   $ lasso(t, `y, `x0`x1);\n"
    },
    {
        "title": "lassoBasic",
        "cal": "lassoBasic(Y, X, [mode=0], [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [positive=false], [swColName], [checkInput=true])",
        "params": "Perform lasso regression.",
        "exp": "`Y` is a numeric vector indicating the dependent variables. ",
        "eg": "\n   $ x1=1 3 5 7 11 16 23\n   $ x2=2 8 11 34 56 54 100\n   $ y=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\n   $ print(lassoBasic(y, (x1,x2), mode = 0));\n   [-9.133706333069543,2.535935196073186,0.189298948643987]\n\n\n   $ print(lassoBasic(y, (x1,x2), mode = 1));\n   factor    beta               stdError          tstat              pvalue           \n   --------- ------------------ ----------------- ------------------ -----------------\n   intercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\n   x1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\n   x2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137 \n\n\n   $ print(lassoBasic(y, (x1,x2), mode = 2));\n   Coefficient->\n   factor    beta               stdError          tstat              pvalue           \n   --------- ------------------ ----------------- ------------------ -----------------\n   intercept -9.133706333069543 5.247492365971091 -1.740584968222107 0.156730846105191\n   x1        2.535935196073186  1.835793667840723 1.38138356205138   0.239309472176311\n   x2        0.189298948643987  0.410201227095842 0.461478260277749  0.66843504931137 \n\n   RegressionStat->\n   item         statistics       \n   ------------ -----------------\n   R2           0.931480447323074\n   AdjustedR2   0.897220670984611\n   StdError     8.195817208870076\n   Observations 7                \n\n   ANOVA->\n   Breakdown  DF SS                   MS                   F                  Significance     \n   ---------- -- -------------------- -------------------- ------------------ -----------------\n   Regression 2  4165.242566095043912 2082.621283047521956 31.004574440904473 0.003672076469395\n   Residual   4  268.685678884843582  67.171419721210895                                       \n   Total      6  4471.637142857141952                                                          \n\n   Residual->\n   [6.319173239708383,4.21150915569809,-0.028258082380245,-6.254004293338318,-7.262321947798779,-6.063400030876729,9.077301958987561]"
    },
    {
        "title": "last",
        "cal": "last(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "Return the last element of a vector, or the last row of a matrix.",
        "eg": "\n   $ last(`hello `world);\n   world\n\n   $ last(1..10);\n   10\n\n   $ m = matrix(1 2 3, 4 5 6);\n   $ m;\n"
    },
    {
        "title": "lastNot",
        "cal": "lastNot(X, [k])",
        "params": "`X` is a vector or a matrix.",
        "exp": "If `X` is a vector:",
        "eg": "\n   $ lastNot(1 6 0 0 0, 0);\n   6\n\n   $ lastNot(1 6 0 0 0 2 3 0 NULL, 0);\n   3\n\n   $ lastNot(1 6 0 0 0 2 3 0 NULL);\n   0\n\n   $ t=table(1 1 1 1 1 2 2 2 2 2 as id, 1 2 0 0 0 3 NULL NULL 0 0 as x);\n   $ t;\n"
    },
    {
        "title": "lastWeekOfMonth",
        "cal": "lastWeekOfMonth(X, [weekday=0], [offset], [n=1])",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "In the calendar month of `X`, suppose the last \"weekday\" is d.",
        "eg": "\n   $ lastWeekOfMonth(2019.11.24,2);\n   2019.10.30\n   // The last Wednesday of November 2019 is 2019.11.27, 2019.11.24 is before 2019.11.27, so the function returns the last Wednesday of October 2019.\n\n   $ lastWeekOfMonth(2019.11.29,2);\n   2019.11.27\n\n   $ date=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\n   $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n   $ sym = take(`MSFT,10)        \n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n\n   $ select avg(price),sum(qty) from t1 group by lastWeekOfMonth(date,4,2012.01.01,2);\n"
    },
    {
        "title": "le",
        "cal": "le(X, Y) or X<=Y",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix/set. If *X* or *Y* is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither X nor Y is a set, return the element-by-element comparison of X<=Y.",
        "eg": "\n   $ 1 2 3 <= 2;\n   [1,1,0]\n\n   $ 1 2 3<=0 2 4;\n   [0,1,1]\n\n   $ 2:3<=1:6;\n   0 : 1\n\n   $ m1=1..6$2:3;\n   $ m1;\n"
    },
    {
        "title": "left",
        "cal": "left(X,n)",
        "params": "`X` is a string scalar or vector.",
        "exp": "Return the first *n* characters of string *X*.",
        "eg": "\n   $ left(\"I love this game!\", 6);\n   I love"
    },
    {
        "title": "lfill",
        "cal": "lfill(obj)",
        "params": "`obj` is a vector or a table with only numeric columns.",
        "exp": "* If *obj* is a vector: linearly fill the NULL values between 2 non-NULL numeric values in *obj*.",
        "eg": "\n   $ a= NULL 1.5 NULL NULL 4.5\n   $ a.lfill();\n   [NULL,1.5,2.5,3.5,4.5]\n\n   $ b=1 NULL NULL 6\n   $ b.lfill();\n   [1,3,4,6]\n\n   $ t=table(1 NULL NULL 4 5 6 as id,2.1 2.2 NULL NULL 2.4 2.6 as val);\n   $ select * from lfill(t);\n"
    },
    {
        "title": "lfill!",
        "cal": "lfill!(obj)",
        "params": "`obj` is a vector or a table with only numeric columns.",
        "exp": "Please refer to :doc:`lfill`. The only difference between *lfill* and *lfill!* is that the latter assigns the result to *X* and thus changing the value of *X* after the execution.",
        "eg": ""
    },
    {
        "title": "license",
        "cal": "license([fileName], [pubKeyFile])",
        "params": "`fileName` is optional parameters. The path of the license.",
        "exp": "Display information regarding the DolphinDB license.",
        "eg": "\n   $ license();\n   authorization->free\n   licenseType->0\n   maxMemoryPerNode->4\n   maxCoresPerNode->2\n   clientName->Trial Users\n   bindCPU->true\n   expiration->2021.09.30\n   maxNodes->3\n   version->\n   modules->-1"
    },
    {
        "title": "like",
        "cal": "like(X, pattern)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return a Boolean value scalar or vector indicating whether each element in *X* fits a specific pattern. The comparison is case sensitive.",
        "eg": "\n   $ like(`ABCDEFG, `DE);\n   0\n\n   $ like(`ABCDEFG, \"%DE%\");\n   1\n\n\n   $ a=`IBM`ibm`MSFT`Goog`YHOO`ORCL;\n   $ like(a, \"%OO%\");\n   [0,0,0,0,1,0]\n   $ a[like(a, \"%OO%\")];\n   [\"YHOO\"]\n"
    },
    {
        "title": "linearTimeTrend",
        "cal": "linearTimeTrend(X, window)",
        "params": "Calculate the moving linear regression for *X*. Return a tuple with 2 elements, alpha (the Linear regression intercept *LINEARREG_INTERCEPT*) and beta (the linear regression slope *LINEARREG_SLOPE*).",
        "exp": "",
        "eg": ""
    },
    {
        "title": "linprog",
        "cal": "linprog(f, [A], [b], [Aeq], [beq], [lb], [ub], [method='simplex'])",
        "params": "Solve the following optimization problem with a linear objective function and a set of linear constraints.",
        "exp": "`A` and `Aeq` must be matrices with the same number of columns.",
        "eg": "Example 1. Find the minimum of x+2y subject to the constraints of\n\n:math:`\\begin{cases}x\\le2\\\\y\\le2\\\\x+y\\ge2\\end{cases}`\n"
    },
    {
        "title": "listTables",
        "cal": "listTables(dbUrl)",
        "params": "`dbUrl` is a string indicating the local path or dfs path of a database.",
        "exp": "Return a table of two columns, tableName and physicalIndex. Please note that only the database with chunks of the table level can have physical indices.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "loadBackup",
        "cal": "loadBackup(backupDir, dbPath, partition, tableName)",
        "params": "`backupDir` is a string indicating the directory where the backup is saved.",
        "exp": "Load the backup of a partition in a distributed table. It must be executed by a logged-in user.",
        "eg": "\n   $ loadBackup(\"/home/DolphinDB/backup\",\"dfs://valuedb\", \"/200001M\",\"pt\");\n"
    },
    {
        "title": "loadDistributedInMemoryTable",
        "cal": "loadDistributedInMemoryTable(tableName)",
        "params": "`tableName` is a STRING scalar indicating column names of a distributed in-memory table.",
        "exp": "Delete the specified distributed in-memory table. This function can only be executed on a data node or compute node.",
        "eg": "\n\n    $ pt = createDistributedInMemoryTable(`dt, `time`id`value, `DATETIME`INT`LONG, HASH, [INT, 2],`id)\n    $ time = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\n    $ id = 0..39;\n    $ value = rand(100, 40);\n    $ tmp = table(time, id, value);\n\n    $ pt = loadDistributedInMemoryTable(`dt)\n    $ pt.append!(tmp);\n    $ select * from pt;\n"
    },
    {
        "title": "loadIPCInMemoryTable",
        "cal": "loadIPCInMemoryTable(tableName)",
        "params": "`tableName` is a STRING indicating the name of IPC in-memory table to be loaded.",
        "exp": "Load an IPC in-memory table and return its handle.",
        "eg": "  "
    },
    {
        "title": "loadModel",
        "cal": "loadModel(file)",
        "params": "`file` is a string indicating the absolute path and name of the output file.",
        "exp": "Load the specifications of a trained model into memory as a dictionary.",
        "eg": "\n   $ x1 = rand(100.0, 100)\n   $ x2 = rand(100.0, 100)\n   $ b0 = 6\n   $ b1 = 1\n   $ b2 = -2\n   $ err = norm(0, 10, 100)\n   $ y = b0 + b1 * x1 + b2 * x2 + err\n   $ t = table(x1, x2, y)\n   $ model = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\n   $ saveModel(model, \"C:/DolphinDB/Data/regressionModel.txt\");\n\n   $ model = loadModel(\"C:/DolphinDB/Data/regressionModel.txt\")\n   $ yhat = predict(model, t);"
    },
    {
        "title": "loadModule",
        "cal": "loadModule(name, [moduleDir])",
        "params": "`name` is a string indicating the module name.",
        "exp": "Load the functions in a module or plug-in as DolphinDB built-in functions. If the module relies on other modules, the system will also load these modules. It must be executed by a logged-in user.",
        "eg": "Example 1. Load modules:\n"
    },
    {
        "title": "loadMvccTable",
        "cal": "loadMvccTable(path, tableName)",
        "params": "`path` is a string indicating the absolute path of the table.",
        "exp": "Load all data of an MVCC table on disk into memory.",
        "eg": "\n   $ n=5\n   $ syms=`IBM`C`MS`MSFT`JPM`ORCL`FB`GE\n   $ timestamp=09:30:00+rand(18000,n)\n   $ sym=rand(syms,n)\n   $ qty=100*(1+rand(100,n))\n   $ price=5.0+rand(100.0,n)\n   $ temp=table(timestamp,sym,qty,price)\n   $ t1= mvccTable(1:0,`timestamp`sym`qty`price,[TIMESTAMP,SYMBOL,INT,DOUBLE],\"C:/DolphinDB/Data\",\"t1\")\n   $ t1.append!(temp);\n\n   $ loadMvccTable(\"C:/DolphinDB/Data\",t1);\n"
    },
    {
        "title": "loadNpy",
        "cal": "loadNpy(fileName)",
        "params": "`filename` is a string indicating the path and name of an NPY file.",
        "exp": "Load an NPY (Python Numpy) binary file and convert it into a DolphinDB vector or matrix. NaN in the NPY file is converted into NULL in DolphinDB.",
        "eg": "Save NPY files in Python:\n"
    },
    {
        "title": "loadNpz",
        "cal": "loadNpz(fileName)",
        "params": "`filename` is a STRING indicating the path of npz file.",
        "exp": "Read an npz binary file from Python NumPy and convert it into DolphinDB objects. NaN in npz file is converted into NULL in DolphinDB.",
        "eg": "1.30.16/2.00.4 "
    },
    {
        "title": "loadPlugin",
        "cal": "loadPlugin(metaFile)",
        "params": "`metaFile` is a string indicating the path of a text file that describes a DolphinDB plugin.",
        "exp": "Load a plugin into DolphinDB. It must be executed by a logged-in user.",
        "eg": "\n   $ loadPlugin(\"C:/DolphinDB_Win_V0.75/server/plugins/odbc/odbc.cfg\");\n   $ (query,connect,close,execute)"
    },
    {
        "title": "loadRecord",
        "cal": "loadRecord(filename, schema, [skipBytes=0], [count])",
        "params": "`filename` is a string indicating the path of a file.",
        "exp": "Load a binary file with fixed length for each column into memory.",
        "eg": "The following is a binary file sample.bin:\n"
    },
    {
        "title": "loadTable",
        "cal": "loadTable(database, tableName, [partitions], [memoryMode=false])",
        "params": "`database` is either a database handle, or the absolute path of the folder where the database is stored. The database can be located in the local file system, or the distributed file system.",
        "exp": "For a DFS table: return a table object with only the metadata.",
        "eg": "In the distributed file system:\n\n* To load a partitioned table:\n"
    },
    {
        "title": "loadTableBySQL",
        "cal": "loadTableBySQL(sql)",
        "params": "`sql` is a metacode object representing a SQL query. It can use ``where`` clause to filter partitions or rows and use ``select`` statement to select columns including calculated columns. However, it cannot use ``top`` clause, ``group by`` clause, or ``order by`` clause.",
        "exp": "Load only the rows of a partitioned table that satisfy the filtering conditions in a SQL query to memory. The result is a partitioned in-memory table with the same partitioning scheme as the database on disk.",
        "eg": "\n   $ n=1000000\n   $ t=table(rand('A'..'Z',n) as sym, 2000.01.01+rand(365,n) as date, 10.0+rand(2.0,n) as price1, 100.0+rand(20.0,n) as price2, rand(10,n) as qty1, rand(100,n) as qty2)\n   $ db = database(\"dfs://tradeDB\", VALUE, 'A'..'Z')\n   $ trades=db.createPartitionedTable(t,`trades,`sym).append!(t)\n\n   $ sample=select * from loadTableBySQL(<select * from trades where date between 2000.03.01 : 2000.05.01>)\n   $ sample=select * from loadTableBySQL(<select sym, date, price1, qty1 from trades where date between 2000.03.01 : 2000.05.01>)\n\n   $ dates = 2000.01.16 2000.02.14 2000.08.01\n   $ st = sql(<select sym, date, price1, qty1>, trades, expr(<date>, in, dates))\n   $ sample = select * from loadTableBySQL(st)\n\n   $ colNames =`sym`date`qty2`price2\n   $ st= sql(sqlCol(colNames), trades)\n   $ sample = select * from loadTableBySQL(st)"
    },
    {
        "title": "loadText",
        "cal": "loadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader])",
        "params": "`filename` the input text file name with its absolute path.",
        "exp": "Load a text file into memory as a table. *loadText* loads data in single thread. To load data in multiple threads, use :doc:`../p/ploadText` .",
        "eg": "Use the following script to generate the data file to be used for the examples:\n"
    },
    {
        "title": "loadTextEx",
        "cal": "loadTextEx(dbHandle, tableName, partitionColumns, filename, [delimiter], [schema], [skipRows=0], [transform], [sortColumns], [atomic=false], [arrayDelimiter], [containHeader])",
        "params": "`dbHandle` the distributed database where the imported data will be saved. The database can be either in the distributed file system or an in-memory database.",
        "exp": "Load a text file into DolphinDB database.",
        "eg": "Use the following script to generate the text file to be used:\n"
    },
    {
        "title": "loc",
        "cal": "loc(obj, rowFilter, [colFilter], [view=false])",
        "params": "`obj` is a matrix object. It can be a standard matrix, an indexed series or an indexed matrix.",
        "exp": "Access a group of rows and columns of a matrix by label(s) or a boolean vector. Return a copy or a view of the original matrix. ",
        "eg": "\n    $ m=rand(12, 3:4)\n    $ m;\n"
    },
    {
        "title": "localtime",
        "cal": "localtime(X)",
        "params": "`X` is a variable/vector. The data type of *X* can be datetime, timestamp, or nanotimestamp.",
        "exp": "Convert *X* in GMT (Greenwich Mean Time) to local time zone.  ",
        "eg": "The following examples were conducted in US Eastern time zone.\n"
    },
    {
        "title": "loess",
        "cal": "loess(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false], [bandwidth=0.3], [robustnessIter=4], [accuracy=1e-12])",
        "params": "`X` is a strictly increasing vector of temporal type.",
        "exp": "Resample *X* based on the specified *resampleRule*, *closed* and *origin*. Implement Local Regression Algorithm (Loess) for interpolation on *Y* based on the resampled *X*.",
        "eg": "\n    $ loess([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min, bandwidth=1)\n    \n    [1,1.0521,1.104,1.1558,1.2072,1.2582,1.3086,1.3584,1.4074,1.4556,\n    1.5027,1.5488,1.5937,1.6374,1.6795,1.7202,1.7593,1.7966,1.832,1.8655,\n    1.897,1.9263,1.9533,1.9779,2,2.0195,2.0366,2.0513,2.0637,2.0739,\n    2.082,2.0882,2.0926,2.0952,2.0962,2.0957,2.0938,2.0905,2.0861,2.0806,\n    2.0741,2.0667,2.0586,2.04982.0405,2.0308,2.0207,2.0104,2]"
    },
    {
        "title": "log",
        "cal": "log(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the natural logarithm of *X*.",
        "eg": "\n   $ log(2.718283);\n   1\n   $ log(0 1 2 3);\n   [,0,0.693147,1.098612]"
    },
    {
        "title": "log10",
        "cal": "log10(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the logarithm of *X* to the base 10.",
        "eg": "\n   $ log10(100);\n   2\n\n   $ log10(0 10 100 1000 NULL);\n   [,1,2,3,]\n\n   $ log10(10 100 1000 10000$2:2);\n"
    },
    {
        "title": "log1p",
        "cal": "log1p(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return log(1+X).",
        "eg": "\n   $ log1p(0);\n   0\n\n   $ log1p([0, e-1, pow(e,2)-1, pow(e,3)-1, NULL]);\n   [0,1,2,3,]\n\n   $ log1p([0, e-1, pow(e,2)-1, pow(e,3)-1]$2:2);\n"
    },
    {
        "title": "log2",
        "cal": "log2(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the logarithm of *X* to the base 2.",
        "eg": "\n   $ log2(4);\n   2\n\n   $ log2(0 2 4 8 NULL);\n   [,1,2,3,]\n\n   $ log2(1..4$2:2);\n"
    },
    {
        "title": "login",
        "cal": "login(userId, password, [encrypted=false])",
        "params": "`userId` a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. The length cannot exceed 30 characters.",
        "exp": "A user logs in to operate on the controller or data nodes.",
        "eg": "\n    $ login(`JohnSmith, `Qb0507);\n"
    },
    {
        "title": "logisticRegression",
        "cal": "logisticRegression(ds, yColName, xColNames, [intercept=true], [initTheta], [tolerance=1e-3], [maxIter=500], [regularizationCoeff=1.0])",
        "params": "`ds` is the data source to be trained. It can be generated with function :doc:`../s/sqlDS`.",
        "exp": "Fit a logistic regression model. The result is a dictionary with the following keys: *iterations*, *modelName*, *coefficients*, *tolerance*, *logLikelihood*, *xColNames* and *intercept*. *iterations* is the number of iterations, *modelName* is \"Logistic Regression\", *coefficients* is a vector of the parameter estimates, *logLikelihood* is the final value of the log likelihood function.",
        "eg": "Fit a logistic regression model with simulated data:\n"
    },
    {
        "title": "logout",
        "cal": "logout([userId], [sessionOnly=true])",
        "params": "`userId` a string indicating a user name. It can only contain letters, underscores, or numbers. It cannot start with numbers. Its length cannot exceed 30 characters.",
        "exp": "If userId is unspecified, the user logs out herself.",
        "eg": "\n    $ logout();\n\n    $ logout(`TomFord);\n\n    $ logout(, false);\n"
    },
    {
        "title": "long",
        "cal": "long(X)",
        "params": "`X` can be of any data type.",
        "exp": "Convert the data type of *X* to LONG.",
        "eg": "\n   $ x=long();        \n   $ x;              \n   00l                \n   $ typestr x;      \n   LONG   \n           \n   $ long(`10.9);\n   10\n\n   $ long(9223372036854775807l);\n   9223372036854775807\n\n   $ long(9223372036854775808l);        \n   9223372036854775807\n   // maximum value for a LONG is 2^63-1=9223372036854775807"
    },
    {
        "title": "loop",
        "cal": "loop(func, args...)",
        "params": "`func`  is a function.",
        "exp": "The  ``loop`` template is very similar to the ``each`` template. Their difference is about the data form and data type of the function call results.",
        "eg": "In the examples below, ``loop`` returns a tuple containing two data forms: scalar and vector.\n"
    },
    {
        "title": "lowDouble",
        "cal": "lowDouble(X)",
        "params": "`X` is a vector/scalar which must be 16-byte data type.",
        "exp": "It returns the lower 8 bytes of X, which is of DOUBLE type.",
        "eg": "\n   $ $ x=1 2 3 4\n   $ y=4 3 2 1\n   $ points = point(x, y)\n   $ x1 = lowDouble(points)\n   [1,2,3,4]\n"
    },
    {
        "title": "lowRange",
        "cal": "lowRange(X)",
        "params": "`X` is a vector/tuple/matrix/table.",
        "exp": "For each element *Xi* in *X*, count the continuous nearest neighbors to its left that are smaller than *Xi*.",
        "eg": "\n    $ lowRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n    [0,0,2,3,0,0,6,0,0,0]\n\n    $ m = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\n    $ lowRange(m)\n"
    },
    {
        "title": "lower",
        "cal": "lower(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Convert all characters in a string or a list of strings into lower cases.",
        "eg": "\n   $ x= `Ibm`C`AapL;\n   $ x.lower();\n   [\"ibm\",\"c\",\"aapl\"]\n\n   $ lower(`Chloe);\n   chloe\n"
    },
    {
        "title": "lpad",
        "cal": "lpad(str, length, [pattern])",
        "params": "`str` is a string scalar or vector. It is the string to pad characters to (the left-hand side).",
        "exp": "Pad the left-side of a string with a specific set of characters.",
        "eg": "\n   $ lpad(\"Hello\",2);\n   He\n\n   $ lpad(`Hello, 10);\n        Hello\n\n   $ lpad(`Hello, 12, `0);\n   0000000Hello"
    },
    {
        "title": "lshift",
        "cal": "lshift(X,bits) or X<<bits",
        "params": "`X` is an integral scalar/pair/vector/matrix.",
        "exp": "Shift bits to the left.",
        "eg": "\n   $ lshift(2, 10);  \n   2048                    \n\n   $ 1..10 << 1;  \n   [2,4,6,8,10,12,14,16,18,20]\n\n   $ 1..10 << 10;\n   [1024,2048,3072,4096,5120,6144,7168,8192,9216,10240]\n\n   $ 1:10<<10;\n   1024 : 10240\n"
    },
    {
        "title": "lt",
        "cal": "lt(X, Y) or X<Y",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix/set. If `X` or `Y` is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither *X* nor *Y* is a set, return the element-by-element comparison of *X*<*Y*.",
        "eg": "\n   $ 1 2 3 < 2;\n   [1,0,0]\n\n   $ 1 2 3<0 2 4;\n   [0,0,1]\n\n   $ 2:3<1:6;\n   0 : 1\n\n   $ m1=1..6$2:3;\n   $ m1;\n"
    },
    {
        "title": "ltrim",
        "cal": "ltrim(X)",
        "params": "`X` is a string scalar or vector.",
        "exp": "Remove leading spaces from a character expression.",
        "eg": "\n   $ ltrim(\"    I love this game!\");\n   I love this game!\n"
    },
    {
        "title": "lu",
        "cal": "lu(obj, [permute=false])",
        "params": "`obj` is a matrix with no NULL values.",
        "exp": "Compute pivoted LU decomposition of a matrix.",
        "eg": "\n   $ A = matrix([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]]);\n\n   $ P, L, U = lu(A);\n   $ P;\n"
    },
    {
        "title": "ma",
        "cal": "ma(X, window, maType)",
        "params": "`maType` is the type of moving averages. It is an integer in [0,8].0= :doc:`../s/sma` , 1= :doc:`../e/ema` , 2= :doc:`../w/wma` , 3= :doc:`../d/dema` , 4= :doc:`../t/tema` , 5= :doc:`../t/trima` , 6= :doc:`../k/kama` , 7=(mama), 8= :doc:`../t/t3` .",
        "exp": "Calculate the moving average (whose type is determined by maType) in a sliding window of the given length.",
        "eg": ""
    },
    {
        "title": "mad",
        "cal": "mad(X, [useMedian=false])",
        "params": "`X` is a vector, matrix or table.",
        "exp": "If *X* is a vector, return the average absolute deviation of *X*.",
        "eg": "\n   $ mad([85, 90, 95, NULL]);\n   3.333333333333333\n\n   $ m=matrix(85 90 95, 185 190 195);\n   $ m;\n"
    },
    {
        "title": "makeCall",
        "cal": "makeCall(F, args...)",
        "params": "`F` is a function.",
        "exp": "Call a function with the specified parameters to generate a piece of script. The difference between :doc:`/Functionalprogramming/TemplateFunctions/call` and *makeCall* is that *makeCall* doesn't execute the script.",
        "eg": "In the following example, we create a function *generateReport* that reports selected columns from a given table with specified format.\n"
    },
    {
        "title": "makeKey",
        "cal": "makeKey(args...)",
        "params": "`args` are multiple scalars or vectors of the same length.",
        "exp": "Combine the specified *args* as a BLOB scalar or vector, so it can used as the key(s) of a dictionary or a set. Compared with `makeSortedKey`, `makeKey` keeps the order of the inputs in the result.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "makeSortedKey",
        "cal": "makeSortedKey(args...)",
        "params": "`args` are multiple scalars or vectors of the same length.",
        "exp": "Combine the specified *args* as a BLOB scalar or vector. `makeSortedKey` stores the keys in sorted order internally, while returns the same result as `makeKey`.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "makeUnifiedCall",
        "cal": "makeUnifiedCall(func, args)",
        "params": "`func` is a function.",
        "exp": "Generate metacode for function call. Use function :doc:`../e/eval` to execute the metacode. The difference between ``makeUnifiedCall`` and the template function :doc:`/Functionalprogramming/TemplateFunctions/unifiedCall` is that ``makeUnifiedCall`` doesn't execute the metacode.",
        "eg": "\t"
    },
    {
        "title": "mannWhitneyUTest",
        "cal": "mannWhitneyUTest(X, Y, [correct=true])",
        "params": "`X` is a numeric vector.",
        "exp": "Perform the Mann-Whitney U test on `X` and `Y`. It returns a dictionary object with the following keys:",
        "eg": "\n   $ mannWhitneyUTest(5 1 4 3 5, 2 4 7 -1 0 4);\n\n   stat->\n\n   alternativeHypothesis                 pValue\n   ------------------------------------- --------\n   true location shift is not equal to 0 0.518023\n   true location shift is less than 0    0.259011\n   true location shift is greater than 0 0.797036\n\n   correct->true\n   method->Mann-Whitney U test\n   U->11"
    },
    {
        "title": "manova",
        "cal": "manova(X, group)",
        "params": "`X` is a matrix or a table whose columns are all of numeric types.",
        "exp": "Conduct multivariate analysis of variance (MANOVA).",
        "eg": "\n   $ a=29.6 24.3 1.5 20.2 2.6 44.5 2.4 20 9.5\n   $ b=27.3 68.4 3.8 34.8 4.6 26.3 5.9 20 5.6\n   $ c=50.8 60.2 1.0 30.1 2.1 27.9 2.3 20 8.8\n   $ g=1 1 2 1 2 1 2 1 2\n   $ t=table(a,b,c,g)\n   $ manova(select a,b,c from t, t.g);\n\n   dfT->8\n   dfB->1\n   gnames->[1,2]\n   gmdist->\n   #0        #1\n   --------- ---------\n   0         16.458055\n   16.458055 0\n\n   mdist->[5.35501,5.171516,0.132336,1.335303,0.043425,5.384036,0.07295,2.844008,0.661416]\n   chisq->[10.056959]\n   B->\n   #0          #1          #2\n   ----------- ----------- -----------\n   1250.307556 1601.627111 1805.355556\n   1601.627111 2051.662722 2312.636111\n   1805.355556 2312.636111 2606.805556\n\n   lambda->[0.160648]\n   W->\n   #0       #1        #2\n   -------- --------- --------\n   453.968  -151.966  16.31\n   -151.966 1477.6995 1008.395\n   16.31    1008.395  1182.63\n\n   T->\n   #0          #1          #2\n   ----------- ----------- -----------\n   1704.275556 1449.661111 1821.665556\n   1449.661111 3529.362222 3321.031111\n   1821.665556 3321.031111 3789.435556\n\n\n   chisqdf->[3]\n   P->[0.018088]\n   dfW->7\n   eigenval->[5.224779,2.757998E-16,-1.552556E-15]\n   eigenvec->\n   #0       #1        #2\n   -------- --------- ---------\n   0.099362 0.08179   0.023313\n   0.029973 -0.010892 0.107448\n   0.023044 -0.046981 -0.111469\n\n\n   canon->\n   #0        #1        #2\n   --------- --------- ---------\n   2.047837  -0.369203 -2.271294\n   2.969714  -1.691977 0.973456\n   -2.596193 -0.071875 0.09971\n   0.861618  -0.247207 0.622822\n   -2.437568 -0.042299 0.088698\n   2.970655  1.936238  0.521256\n   -2.413867 -0.082213 0.201424\n   0.165404  0.372149  0.153761\n   -1.567601 0.196387  -0.389832"
    },
    {
        "title": "mask",
        "cal": "mask(X, Y)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Apply *Y* on each element of *X*. If the result is *false*, keep the element; if the result is *true*, change it to NULL. The result is of the same length as *X*.",
        "eg": "\n   $ x=1..10\n   $ mask(x, x>6);\n   [1,2,3,4,5,6,,,,]\n\n   $ m=matrix(1 2 3, 4 5 6, 7 8 9);\n   $ m;\n"
    },
    {
        "title": "matrix",
        "cal": "matrix(dataType, rows, cols, [columnsCapacity], [defaultValue])",
        "params": "For the first case:",
        "exp": "Generate a matrix.",
        "eg": "\n   $ x=matrix(INT,3,2, ,1);                        \n   $ x;\n"
    },
    {
        "title": "mavg",
        "cal": "mavg(X, window|weights, [minPeriods])",
        "params": "If *X* is a vector, return a vector of the same length as *X*. If the second parameter is: ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mavgTopN",
        "cal": "mavgTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the average for the first *top* elements of *X* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "max",
        "cal": "max(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "For one input:",
        "eg": "\n   $ max(1 2 3);\n   3\n\n   $ max(7.8 9 5.4);\n   9\n\n   $ (5 8 2 7).max();\n   8\n\n   $ m=matrix(1 2 3, 4 5 6);\n   $ m;\n"
    },
    {
        "title": "maxPositiveStreak",
        "cal": "maxPositiveStreak(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If *X* is a vector: return the maximum value of of the sum of consecutive positive elements of *X*.   ",
        "eg": "\n   $ x=1 0 -1 1 2 2 2 1 0 -1 0 2;\n   $ cumPositiveStreak x;\n   [1,0,0,1,3,5,7,8,0,0,0,2]\n   $ maxPositiveStreak x;\n   8\n\n   $ y=x$6:2;\n   $ y;\n"
    },
    {
        "title": "mbeta",
        "cal": "mbeta(Y, X, window, [minPeriods])",
        "params": "Calculate the coefficient estimate of an ordinary-least-squares regression of *Y* on *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mbetaTopN",
        "cal": "mbetaTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function obtains the first *top* pairs of elements in *X* and *Y* in the sliding window and calculates the coefficient estimate ordinary-least-squares regressions of *Y* on *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mcorr",
        "cal": "mcorr(X, Y, window, [minPeriods])",
        "params": "Calculate the correlation of *X* and *Y* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mcorrTopN",
        "cal": "mcorrTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the correlation of the first *top* pairs of elements in *X* and *Y* in the sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mcount",
        "cal": "mcount(X, window)",
        "params": "Return the number of non-NULL values of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mcovar",
        "cal": "mcovar(X, Y, window, [minPeriods])",
        "params": "Calculate the moving covariance of *X* and *Y* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mcovarTopN",
        "cal": "mcovarTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the covariance of the first *top* pairs of elements in *X* and *Y* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "md5",
        "cal": "md5(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Create an MD5 hash from STRING. The result is of data type INT128.",
        "eg": "\n   $ a=md5(`e`f);\n   $ a;\n   [e1671797c52e15f763380b45e841ec32,8fa14cdd754f91cc6554c9e71929cce7]\n\n   $ typestr(a);\n   INT128"
    },
    {
        "title": "mean",
        "cal": "mean(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Calculate the average of *X*.",
        "eg": "\n   $ x=1 5 9;    \n   $ mean(x);      \n   5            \n\n   $ x=1 5 9 NULL;    \n   $ mean(x);      \n   5  \n\n   $ avg(x);  \n   5        \n\n   $ m=matrix(1 2 3, 4 5 6);\n   $ m;\n"
    },
    {
        "title": "med",
        "cal": "med(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If *X* is a vector, return the median of all the elements in *X*.",
        "eg": "\n   $ x=3 6 1 5 9;\n   $ med x;\n   5\n\n   $ m=matrix(1 2 10, 4 5 NULL);\n   $ m;\n"
    },
    {
        "title": "mem",
        "cal": "mem([freeUnusedBlocks=false])",
        "params": "`freeUnusedBlocks` is a Boolean value indicating whether to free unused memory blocks. The default value is false.",
        "exp": "Display the memory usage of the current node. If *freeUnusedBlocks*\\=true, free unused memory blocks.",
        "eg": "\n   $ undef all;\n   $ t1=table(1 2 3 as a, `x`y`z as b, 10.8 7.6 3.5 as c)\n   $ mem();\n"
    },
    {
        "title": "memSize",
        "cal": "memSize(obj)",
        "params": "`obj` is an object.",
        "exp": "Return the memory usage (in units of bytes) of a local or shared object.",
        "eg": "\n   $ $ n=100\n   $ ID=rand(100, n)\n   $ date=rand(2017.08.07..2017.08.11, n)\n   $ x=rand(10.0, n)\n   $ t=table(ID, date, x);\n   $ share t as tt\n   $ memSize(t)\n   1952\n   $ memSize(tt)\n   1952\n   $ memSize(t[`x])\n   800\n   $ memSize(select avg(x) as avgx from t)\n   280\n"
    },
    {
        "title": "member",
        "cal": "member(X, Y) or X.Y",
        "params": "`X` is a table/dictionary.",
        "exp": "Return the specified member/attribute of an object. ",
        "eg": "\n   $ x=1 2 3\n   $ y=4 5 6\n   $ t=table(x,y);\n\n   $ t.x;                        \n   [1,2,3]\n   $ t.y;                        \n   [4,5,6]\n\n   $ t.rows();                \n   3\n   $ t.cols();                \n   2\n   $ t.size();        \n   3\n   // a table's size is defined as the number of its rows\n\n   $ d = dict(1 2 3, 4 5 6);\n   $ d;\n   3->6\n   1->4\n   2->5\n\n   $ d.2;\n   5"
    },
    {
        "title": "merge",
        "cal": "merge(left, right, [how='inner'])",
        "params": "`left` and `right` are both indexed series, or are both indexed matrices.",
        "exp": "Merge 2 indexed series or 2 indexed matrices.",
        "eg": "\n   $ a = indexedSeries(2012.01.01..2012.01.04, 1..4)\n   $ b = indexedSeries([2012.01.01, 2012.01.03, 2012.01.05, 2012.01.06], 5..8)\n   $ merge(a, b);\n"
    },
    {
        "title": "mfirst",
        "cal": "mfirst(X, window, [minPeriods])",
        "params": "Return the first element of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "microsecond",
        "cal": "microsecond(X)",
        "params": "`X` is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.",
        "exp": "For each element in *X*, return a number from 0 to 999999 indicating which microsecond of the second it falls in. ",
        "eg": "\n   $ microsecond(13:30:10.008);\n   8000\n\n   $ microsecond([2012.12.03 01:22:01.999999000, 2012.12.03 01:22:01.000456000, 2012.12.03 01:25:08.000000234]);\n   [999999,456,0]\n"
    },
    {
        "title": "mifirstNot",
        "cal": "mifirstNot(X, window, [minPeriods])",
        "params": "Return the index of the first non-Null element of *X* in a sliding window (based on the number of elements or time).",
        "exp": "",
        "eg": ""
    },
    {
        "title": "migrate",
        "cal": "migrate(backupDir, [backupDBPath], [backupTableName], [newDBPath=backupDBPath], [newTableName=backupTableName])",
        "params": "`backupDir` is a string indicating the directory to save the backup.",
        "exp": "Restore the backup. It returns a table containing the restored data of each table. It must be executed by a logged-in user.",
        "eg": "Create two sample databases and back up them to the same directory:\n"
    },
    {
        "title": "milastNot",
        "cal": "milastNot(X, window, [minPeriods])",
        "params": "Return the index of the last non-Null element of *X* in a sliding window (based on the number of elements or time).",
        "exp": "",
        "eg": ""
    },
    {
        "title": "millisecond",
        "cal": "millisecond(X)",
        "params": "`X` is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.",
        "exp": "For each element in *X*, return a number from 0 to 999 indicating which millisecond of the second it falls in. ",
        "eg": "\n   $ millisecond(13:30:10.008);\n   8\n\n   $ millisecond([2012.12.03 01:22:01.456120300, 2012.12.03 01:25:08.000234000]);\n   [456,0]\n"
    },
    {
        "title": "mimax",
        "cal": "mimax(X, window, [minPeriods])",
        "params": "Return the position of the element with the largest value in *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mimin",
        "cal": "mimin(X, window, [minPeriods])",
        "params": "Return the position of the element with the smallest value in *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "min",
        "cal": "min(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "For one input:",
        "eg": "\n   $ min(1 2 3);\n   1;\n\n   $ min(2.0 1.1 0.1 NULL);\n   0.1\n\n   $ m=matrix(1 2 3, 4 5 6);\n   $ m;\n"
    },
    {
        "title": "minute",
        "cal": "minute(X)",
        "params": "`X` is an integer or temporal scalar/vector.",
        "exp": "Return the corresponding minute(s).",
        "eg": "\n   $ minute 2012.12.03 01:22:01;\n   01:22m\n\n   $ minute(61);\n   01:01m\n"
    },
    {
        "title": "minuteOfHour",
        "cal": "minuteOfHour(X)",
        "params": "`X` is a scalar/vector of type TIME, MINUTE, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.",
        "exp": "For each element in *X*, return a number from 0 to 59 indicating which minute of the hour it falls in.",
        "eg": "\n   $ minuteOfHour(12:32:00);\n   32\n\n   $  minuteOfHour([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n   [30,35,36,2]\n"
    },
    {
        "title": "mkdir",
        "cal": "mkdir(directory)",
        "params": "`directory` the path of the directory to be created.",
        "exp": "Create a directory. It must be executed by a logged-in user.",
        "eg": "\n    $ files(\"d:/test\");\n"
    },
    {
        "title": "mkurtosis",
        "cal": "mkurtosis(X, window, [biased=true], [minPeriods])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Calculate the moving kurtosis of *X* in a sliding window. ",
        "eg": "\n   $ m=matrix(1 9 3 100 3 2 1 -100 9 10000, 1 2 3 4 5 6 7 8 9 100);\n   $ m.mkurtosis(8);\n"
    },
    {
        "title": "mkurtosisTopN",
        "cal": "mkurtosisTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the moving kurtosis of the first top elements of X in a sliding window.",
        "eg": "    \n    $ X=1 2 3 10 100 4 3    \n    $ S = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\n    $ mkurtosisTopN(X, S, 6, 4)\n    [,,1.49,2.23,2.31,2.11,2.27]\n    \n    $ X = matrix(1..10, 11..20)\n    $ S = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\n    $ mkurtosisTopN(X, S, 6, 4)\n    \n    col1   col2\n\t\t\t\n\t\t\t\n    1.5\t\n    1.5    1.5\n    1.8457 1.5\n    1.5734 1.8457\n    1.8457 1.2215\n    1.64   2\n    1.64   1.64\n    1.64   1.8457\n\n    \n              \n    $ symbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\n    $ time = temporalAdd(2023.07.05T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\n    $ price = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\n    $ qty = [5000,400,3100,100,2400,3700,700,3700,4600,4700,3100,3300,3900,3500,3000,3000,4000,4700,2000,4400]\n    $ BSFlag = [1,0,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0]\n    $ t = table(time, symbol, price, qty, BSFlag)\n    $ select time,symbol,mkurtosisTopN(price, qty, 8, 5) as mskewTop5price from t context by symbol \n    "
    },
    {
        "title": "mlast",
        "cal": "mlast(X, window, [minPeriods])",
        "params": "Return the last element of *X* in a sliding window. ",
        "exp": "   ",
        "eg": ""
    },
    {
        "title": "mmad",
        "cal": "mmad(X, window, [useMedian=false], [minPeriods])",
        "params": "`useMedian` is a Boolean value. The default value is false and it returns the mean absolute deviation, otherwise returns the median absolute deviation. ",
        "exp": "Calculate the the average absolute deviation of *X* in a sliding window. ",
        "eg": "\n   $ x = 7 4 6 0 -5 32;\n   $ mmad(x, window=3);\n   [,,1.111111111111111,2.222222222222222,3.777777777777777,15.333333333333333]\n\n   $ mmad(x, window=3, useMedian=true)\n   [,,1,2,3.666666666666666,12.333333333333333]\n\n   $ y = NULL NULL 2 5 1 7 -3 0\n   $ mmad(y, window=3, minPeriods=2);\n   [,,,1.5,1.555555555555555,2.222222222222222,3.555555555555556,3.777777777777778]  \n\n"
    },
    {
        "title": "mmax",
        "cal": "mmax(X, window, [minPeriods])",
        "params": "Calculate the moving maximums of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mmaxPositiveStreak",
        "cal": "mmaxPositiveStreak(X, window)",
        "params": "`X` is a vector/matrix.",
        "exp": "Obtain the maximum value of the sum of consecutive positive numbers in X within a sliding window of given size (based on the number of elements).",
        "eg": "\n    $ x = 1 -1 1 -2 10 3 3 9 0 6 5\n    $ w = 5\n    $ mmaxPositiveStreak(x, w)\n    [,,,,10,13,16,25,25,15,12]\n\n    $ x = 5 NULL 3 2 1 5 10 9 NULL 9 10 -1 NULL \n    $ w = 5\n    $ mmaxPositiveStreak(x, w)\n    [,,,,6,11,21,27,25,24,19,19,19]\n\n    // use the signum function to count the maximum number of consecutive positive numbers\n    $ mmaxPositiveStreak(signum(x), w)\n    [,,,,3,4,5,5,4,3,2,2,2]"
    },
    {
        "title": "mmed",
        "cal": "mmed(X, window, [minPeriods])",
        "params": "Calculate the moving median of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mmin",
        "cal": "mmin(X, window, [minPeriods])",
        "params": "Calculate the moving minimums of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mmse",
        "cal": "mmse(Y, X, window, [minPeriods])",
        "params": "Return the coefficient estimates of *X* and mean square errors of an ordinary-least-squares regression of *Y* on *X* with intercept with a rolling window. The length of the window is given by the parameter *window*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mod",
        "cal": "mod(X, Y)",
        "params": "`X` / `Y` is a scalar/pair/vector/matrix. If `X` or `Y` is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size. If `X` is of integer type, `Y` cannot be negative integer(s).",
        "exp": "*Mod* means modulus. It returns the element-by-element remainder of *X* divided by *Y*. The modulus is always non-negative and less than *Y*. *Y* must be positive integer(s); otherwise the calculation returns a NULL value. Function *mod* is often used to group data. For example, [5,4,3,3,5,6]%3 is [2,1,0,0,2,0]; data can thereby be divided into three groups. When *X* is a negative integer, the modulus is still non-negative, for example, -10%3 is 2.",
        "eg": "\n   $ x=1 2 3;        \n   $ x % 2;\n   [1,0,1]\n\n   $ 2 % x;                \n   [0,0,2]\n\n   $ y=4 5 6;        \n   $ x mod y;\n   [1,2,3]\n   $ mod(y, x);\n   [0,1,0]\n\n   $ m=1..6$2:3;        \n   $ m;\n"
    },
    {
        "title": "mode",
        "cal": "mode(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If *X* is a vector, calculate the most frequently occurring value in *X*.",
        "eg": "\n   $ mode 2;\n   2\n\n   $ mode 1 3 3 3 4 5 5;\n   3\n\n   $ mode `test;\n   test\n\n   $ m=matrix(1 1 2 2 2 3, 4 4 5 6 6 6);\n   $ m;\n"
    },
    {
        "title": "month",
        "cal": "month(X)",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return the corresponding month(s).",
        "eg": "\n   $ month(2012.12.03);\n   2012.12M\n"
    },
    {
        "title": "monthBegin",
        "cal": "monthBegin(X, [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first day of the month that *X* belongs to.",
        "eg": "\n   $ monthBegin(2016.12.06);\n   2016.12.01\n\n   $ date=2016.04.12 2016.04.25 2016.05.12 2016.06.28 2016.07.10 2016.07.18 2016.08.02 2016.08.16 2016.09.26 2016.09.30\n   $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n   $ sym = take(`MSFT,10)\n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n\n   $ t1;\n"
    },
    {
        "title": "monthEnd",
        "cal": "monthEnd(X, [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the last day of the month that *X* belongs to.",
        "eg": "\n   $ monthEnd(2012.06.12);\n   2012.07.31\n\n   $ date=2016.04.12+(1..10)*30\n   $ time = take(09:30:00, 10)\n   $ sym = take(`MSFT,10)        \n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n\n   $ t1;\n"
    },
    {
        "title": "monthOfYear",
        "cal": "monthOfYear(X)",
        "params": "`X` is a scalar/vector of type DATE, MONTH, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "For each element in *X*, return a number from 1 to 12 indicating which month of the year it falls in.",
        "eg": "\n   $ monthOfYear(2012.07.02);\n   7\n\n   $ monthOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n   [6,10,1,4]\n"
    },
    {
        "title": "move",
        "cal": "move(X, steps)",
        "params": "`X` is a vector/matrix.",
        "exp": "``move`` is the general form of :doc:`../p/prev` and :doc:`../n/next`.",
        "eg": "\n   $ x=3 9 5 1 4 9;\n   $ move(x,3);\n   [,,,3,9,5]\n\n   $ move(x,-2);\n   [5,1,4,9,,]"
    },
    {
        "title": "moveChunksAcrossVolume",
        "cal": "moveChunksAcrossVolume(srcPath, destPath, chunkIds, [isDelSrc=true])",
        "params": "`srcPath` is a string in the format of \"volumeA/CHUNKS\", indicating the source volume of the chunks.",
        "exp": "Move the chunks from the source volume to the destination volume on the same node. When *isDelSrc* = true, chunks are moved to the destination volume, otherwise they are copied. If the transfer fails, all chunks of the source volume are retained, and chunks that have been copied are removed from the destination volume.",
        "eg": "2.00.4"
    },
    {
        "title": "moveReplicas",
        "cal": "moveReplicas(srcNode, destNode, chunkId)",
        "params": "`srcNode` is a string indicating the alias of origination node.",
        "exp": "Move replicas of one or multiple chunks from the source node to the destination node. If the destination node already has the chunk, the command is skipped.",
        "eg": "Move replicas of all chunks on \"node1\" to \"node2\".\n"
    },
    {
        "title": "moving",
        "cal": "moving(func, funcArgs, window, [minPeriods])",
        "params": "",
        "exp": "`funcArgs` are the parameters of `func`. They can be vectors/dictionaries/tables. It is a tuple if there are more than one parameter of `func`, and all parameters must have the same size.",
        "eg": "Apply the function/operator to a moving window of the given objects.\n\nThe ``moving`` template always returns a vector with the same number of elements as the number of rows in the input arguments. It starts calculating when the moving window size is reached for the first time, and the moving window is always shifted by 1 element to the right thereafter.\n\nEach of the built-in moving functions such as :doc:`/FunctionsandCommands/FunctionReferences/m/msum`, :doc:`/FunctionsandCommands/FunctionReferences/m/mcount` and :doc:`/FunctionsandCommands/FunctionReferences/m/mavg` is optimized for its specific task. Therefore, they have much better performance than the ``moving`` template."
    },
    {
        "title": "movingTopNIndex",
        "cal": "movingTopNIndex(X, window, top, [ascending=true], [fixed=false], [tiesMethod='oldest'])",
        "params": "`X` is a numeric/temporal vector. Note: Starting from version 2.00.10, the NULL values in X do not participate in data sorting.",
        "exp": "Return an array vector indicating the indices of the first *top* elements of *X* after sorted within each sliding window.",
        "eg": "2.00.4"
    },
    {
        "title": "movingWindowIndex",
        "cal": "movingWindowIndex(X, window, [fixed=false])",
        "params": "`X` is a vector.",
        "exp": "Return an array vector indicating the indices of the elements of *X* within each sliding window.",
        "eg": "2.00.4"
    },
    {
        "title": "mpercentile",
        "cal": "mpercentile(X, percent, window, [interpolation='linear'], [minPeriods])",
        "params": "`X` is a vector or a matrix.",
        "exp": "Return the percentile rank of each element of *X* in a sliding window. ",
        "eg": "\n   $ x=2 1 3 7 6 5 4;\n   $ mpercentile(x, percent=50, window=3);\n   [,,2,3,6,6,5]\n\n   $ mpercentile(x, percent=25, window=3, interpolation=\"lower\");\n   [,,1,1,3,5,4]\n\n   $ mpercentile(x, percent=75, window=3, interpolation=\"higher\")\n   [,,3,7,7,7,6]\n\n   $ mpercentile(x, percent=5, window=3, interpolation=\"nearest\")\n   [,,1,1,3,5,4]\n\n   $ mpercentile(x, percent=15, window=3, interpolation=\"midpoint\")\n   [,,1.5,2,4.5,5.5,4.5]\n\n   $ mpercentile(x, percent=50, window=3, interpolation=\"linear\", minPeriods=1);\n   [2,1.5,2,3,6,6,5]\n\n   $ m=matrix(2 1 3 7 6 5 4, 1..7);\n   $ m;\n"
    },
    {
        "title": "mprod",
        "cal": "mprod(X, window, [minPeriods])",
        "params": "Calculate the moving products of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mr",
        "cal": "mr(ds, mapFunc, [reduceFunc], [finalFunc], [parallel=true])",
        "params": "`ds` the list of data sources. This required parameter must be a tuple and each element of the tuple is a data source object. Even if there is only one data source, we still need a tuple to wrap the data source.",
        "exp": "The Map-Reduce function is the core function of DolphinDB's generic distributed computing framework.",
        "eg": "The following is an example of distributed linear regression. Suppose `X` is the matrix of independent variables and `y` is the dependent variable. `X` and `y` are stored in multiple data sources. To estimate the ordinary least square parameters, we need to calculate X :sup:`T`\\X and X :sup:`T`\\y. We can calculate the tuple of (X :sup:`T`\\X, X :sup:`T`\\y) from each data source, then aggregate the results from all data sources to get X :sup:`T`\\X and X :sup:`T`\\y for the entire dataset.\n"
    },
    {
        "title": "mrank",
        "cal": "mrank(X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false])",
        "params": "`X` is a vector or a matrix.",
        "exp": "Return the rank of each element of *X* in a sliding window. ",
        "eg": "\n    $ X = 3 2 4 4 4 NULL 1\n\n    $ mrank(X, ascending=false, window=3, ignoreNA=true);\n    [,,0,0,0,,1]\n    \n    $ mrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='max');\n    [,,0,1,2,2,1]\n\n    $ mrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='min');\n    [,,0,0,0,2,1]\n\n    $ mrank(X, ascending=false, window=3, ignoreNA=false, tiesMethod='average');\n    [,,0,0.5,1,2,1]\n"
    },
    {
        "title": "mskew",
        "cal": "mskew(X, window, [biased=true], [minPeriods])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Calculate the moving skewness of *X* in a sliding window. ",
        "eg": "\n    $ mskew(1 2 3 10 100 4 3, 3);\n    [,,0,0.665469,0.693810, 0.697217,0.706851]\n    "
    },
    {
        "title": "mskewTopN",
        "cal": "mskewTopN(X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the moving skewness of the first top elements of X in a sliding window.",
        "eg": "    \n    $ X=1 2 3 10 100 4 3    \n    $ S = 0.3 0.5 0.1 0.1 0.5 0.2 0.4\n    $ mskewTopN(X, S, 6, 4)\n    [,0,0,1.01,1.13,0.79,1.08]\n    \n    $ X = matrix(1..10, 11..20)\n    $ S = matrix(2022.01.01 2022.02.03 2022.01.23 NULL 2021.12.29 2022.01.20 2022.01.23 2022.01.22 2022.01.24 2022.01.24, NULL 2022.02.03 2022.01.23 2022.04.06 NULL 2022.02.03 2022.02.03 2022.02.05 2022.02.08 2022.02.03)\n    $ mskewTopN(X, S, 6, 4)\n    \n    col1  col2\n\t\t\t\n    0\t\n    0       0\n    0       0\n    0.4347  0\n    -0.278  0.4347\n    -0.4347 0\n    0       -0.6872\n    0       0\n    0       0.4347\n\n              \n    $ symbol = [\"A\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"A\",\"B\",\"B\",\"B\",\"A\",\"B\",\"A\",\"B\",\"B\",\"A\",\"B\",\"A\"]\n    $ time = temporalAdd(2023.07.03T09:30:00.000,[10,20,40,60,70,80,90,140,160,170,180,190,200,210,220,230,250,360,390,400],\"ms\")\n    $ price = [28.11,28.25,28.44,52.31,28.98,28.89,52.22,28.16,28.52,52.62,52.56,52.2,28.01,52.43,28.57,52.42,52.19,28.16,52.84,28.18]\n    $ qty = [1900,3300,100,3000,3500,800,3400,4400,3900,4600,2200,2100,2300,4100,400,300,3100,2500,1000,2700]\n    $ BSFlag = [1,0,1,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1]\n    $ t = table(time, symbol, price, qty, BSFlag)\n    $ select time,symbol,BSFlag,mskewTopN(price, qty, 8, 5) as mskewTop5Price from t context by symbol,BSFlag\n    "
    },
    {
        "title": "mslr",
        "cal": "mslr(Y, X, window, [minPeriods])",
        "params": "Conduct the simple least-squares regressions of *Y* on *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mstd",
        "cal": "mstd(X, window, [minPeriods]",
        "params": "Calculate the standard deviation of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mstdTopN",
        "cal": "mstdTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the unbiased sample standard deviation of the first *top* elements of *X* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mstdp",
        "cal": "mstdp(X, window, [minPeriods])",
        "params": "Calculate the population standard deviation of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mstdpTopN",
        "cal": "mstdpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the population standard deviation of the first *top* elements of *X* in the sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "msum",
        "cal": "msum(X, window, [minPeriods])",
        "params": "Calculate the moving sum of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "msum2",
        "cal": "msum2(X, window, [minPeriods])",
        "params": "Calculate the sum of squares of all elements of *X* in a sliding window (based on the number of elements or time). Please note that the return is always of DOUBLE type.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "msumTopN",
        "cal": "msumTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the sum of the first *top* elements of *X* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mul",
        "cal": "mul(X, Y) or X*Y",
        "params": "`X` and  `Y` is a scalar/pair/vector/matrix. If one of X and Y is a pair/vector/matrix, the other must be a scalar or a pair/vector/matrix of the same size.",
        "exp": "Return the element-by-element product of X and Y. ",
        "eg": "\n    $ 1:2*3;\n    3 : 6\n\n    $ 1:2*3:4;\n    3 : 8\n\n    $ x=1 2 3;\n    $ x * 2;\n    [2,4,6]\n\n    $ y=4 5 6;\n    $ x * y;\n    [4,10,18]\n"
    },
    {
        "title": "multiTableRepartitionDS",
        "cal": "multiTableRepartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
        "params": "`query` is metacode of SQL statements or a tuple of metacode of SQL statements.",
        "exp": "Generate a tuple of data sources from multiple tables with a new partitioning design.",
        "eg": "\n    $ n=100000\n    $ date=rand(2019.06.01..2019.06.05,n)\n    $ sym=rand(`AAPL`MSFT`GOOG,n)\n    $ price=rand(1000.0,n)\n    $ t1=table(date,sym,price)\n    $ db=database(\"dfs://value\",VALUE,2019.06.01..2019.06.05)\n    $ db.createPartitionedTable(t1,`pt1,`date).append!(t1);\n\n    $ n=100000\n    $ date=rand(2019.06.01..2019.06.05,n)\n    $ sym=rand(`AAPL`MSFT`GOOG,n)\n    $ price=rand(1000.0,n)\n    $ qty=rand(500,n)\n    $ t2=table(date,sym,price,qty)\n    $ db1=database(\"\",VALUE,2019.06.01..2019.06.05)\n    $ db2=database(\"\",VALUE,`AAPL`MSFT`GOOG)\n    $ db=database(\"dfs://compo\",COMPO,[db1,db2])\n    $ db.createPartitionedTable(t2,`pt2,`date`sym).append!(t2);\n\n    $ pt1=loadTable(\"dfs://value\",\"pt1\")\n    $ pt2=loadTable(\"dfs://compo\",\"pt2\");\n"
    },
    {
        "title": "multinomialNB",
        "cal": "multinomialNB(Y, X, [varSmoothing=1.0])",
        "params": "`Y` is a vector with the same length as table X. Each element of labels indicates the class that the correponding row in X belongs to. ",
        "exp": "Conduct the multinomial Naive Bayesian classification. Return a dictionary with the following keys:",
        "eg": "The dataset iris.data used in the following example can be downloaded from `<https://archive.ics.uci.edu/ml/datasets/iris>`_.\n"
    },
    {
        "title": "mutualInfo",
        "cal": "mutualInfo(X, Y)",
        "params": "`X` is a scalar/vector/ matrix.",
        "exp": "Calculate the mutual information of `X` and `Y`. ",
        "eg": "\n    $ a = [NULL,4,NULL,NULL,-82,97,NULL,56,5,-92]\n    $ b = [NULL,53,NULL,18,97,-4,-73,NULL,NULL,24]\n    $ mutualInfo(a, b)\n    2.302585\n\n    $ t=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10,10000000) as y);\n    $ mutualInfo(t.x, t.y)\n    0.000004\n\n    $ m1 = 1..12$3:4\n    $ m2 = 1..3\n    $ mutualInfo(m1, m2)\n    [1.0986, 1.0986, 1.0986, 1.0986]\n"
    },
    {
        "title": "mvar",
        "cal": "mvar(X, window, [minPeriods])",
        "params": "Calculate the moving variances of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mvarTopN",
        "cal": "mvarTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the unbiased sample variance of the first *top* elements of *X* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mvarp",
        "cal": "mvarp(X, window, [minPeriods])",
        "params": "Calculate the moving population variances of *X* in a sliding window. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mvarpTopN",
        "cal": "mvarpTopN(X, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function calculates the population variance of the first *top* elements of *X* in the sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mvccTable",
        "cal": "mvccTable(X, [X1], [X2], .....)",
        "params": "For the first scenario:",
        "exp": "Create an MVCC (Multi Version Concurrency Control) table. When appending, updating or deleting rows of a table, another version of the table is created so that concurrent read will not be blocked. The mvcc table is optimal for the use case with frequent read and append, but few update and delete operations.",
        "eg": "\n    $ id=`XOM`GS`AAPL\n    $ x=102.1 33.4 73.6\n    $ mvccTable(id, x);\n"
    },
    {
        "title": "mwavg",
        "cal": "mwavg(Y, X, window, [minPeriods])",
        "params": "Calculate the moving averages of *X* with *Y* as weights in a sliding window.",
        "exp": "Function ``mwavg`` can be used to calculate VWAP (volume-weighted average price):",
        "eg": ""
    },
    {
        "title": "mwsum",
        "cal": "mwsum(Y, X, window, [minPeriods])",
        "params": "Calculate the moving sums of *X* with *Y* as weights in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "mwsumTopN",
        "cal": "mwsumTopN(X, Y, S, window, top, [ascending=true], [tiesMethod='oldest'])",
        "params": "After stably sorting *S* in the specified *ascending* order, the function obtains the first *top* pairs of elements in *X* and *Y* in the sliding window and calculates the cumulative weighted sum of *X* with *Y* as the weights.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "nanosecond",
        "cal": "nanosecond(X)",
        "params": "`X` is a scalar/vector of type TIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.",
        "exp": "For each element in `X`, return a number from 0 to 999999999 indicating which nanosecond of the second it falls in.  ",
        "eg": "  \n   $ nanosecond(13:30:10.008);\n   8000000\n\n   $ nanosecond([2012.12.03 01:22:01.999999999, 2012.12.03 01:25:08.000000234]);\n   [999999999,234]\n"
    },
    {
        "title": "nanotime",
        "cal": "nanotime(X)",
        "params": "`X` is an integer or temporal scalar/vector.",
        "exp": "Convert the data type of X to NANOTIME. ",
        "eg": "\n    $ nanotime(1000000000);\n    00:00:01.000000000\n\n    $ nanotime(12:06:09 13:08:01);\n    [12:06:09.000000000,13:08:01.000000000]\n\n    $ nanotime(2012.12.03 01:22:01.123456789);\n    01:22:01.123456789\n\n    $ nanotime('13:30:10.008007006');\n    13:30:10.008007006\n"
    },
    {
        "title": "nanotimestamp",
        "cal": "nanotimestamp(X)",
        "params": "`X` is an integer or temporal scalar/vector.",
        "exp": "Convert the data type of X to NANOTIMESTAMP. If there is no date in the argument X, return a timestamp from 1999.12.31 00:00:00.000000000 + X (nanoseconds).",
        "eg": "\n    $ nanotimestamp(1000000000);\n    1999.12.31T00:00:01.000000000\n\n    $ nanotimestamp(2012.12.03 12:06:09 2012.12.03 13:08:01);\n    [2012.12.03T12:06:09.000000000,2012.12.03T13:08:01.000000000]\n\n    $ nanotimestamp(2012.12.03 01:22:01.123456789);\n    2012.12.03T01:22:01.123456789\n\n    $ nanotimestamp('2012.12.03 13:30:10.008007006');\n    2012.12.03T13:30:10.008007006\n"
    },
    {
        "title": "ne",
        "cal": "ne(X, Y) or X!=Y",
        "params": "`X` and `Y` is a scalar/pair/vector/matrix/set. If X or Y is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "If neither X nor Y is a set, conduct the element-by-element comparison of X and Y; return 1 if the elements in X and Y are not the same.",
        "eg": "\n    $ 1 2 3 != 2;\n    [1,0,1]\n\n    $ 1 2 3 ne 0 2 4;\n    [1,0,1]\n\n    $ 1:2 != 1:6;\n    0 : 1\n"
    },
    {
        "title": "neg",
        "cal": "neg(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Return the negative of `X`.",
        "eg": "\n    $ x=1:2;\n    $ -x;\n    -1 : -2\n\n    $ x=1 0 1;                        \n    $ -x;\n    [-1,0,-1]\n"
    },
    {
        "title": "neville",
        "cal": "neville(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
        "params": "`X` is a strictly increasing vector of temporal type.",
        "exp": "Resample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform neville interpolation on *Y* based on the resampled *X*.",
        "eg": "\n    $ neville([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n    [1,1.0217,1.0451,1.0703,1.0972,1.1259,1.1562,1.1884,1.2222,1.2578,\n    1.2951,1.3342,1.375,1.4175,1.4618,1.5078,1.5556,1.605,1.6562,1.7092,\n    1.7639,1.8203,1.8785,1.9384,2,2.0634,2.1285,2.1953,2.2639,2.3342,\n    2.4062,2.48,2.5556,2.6328,2.7118,2.7925,2.875,2.9592,3.0451,3.1328,\n    3.2222,3.3134,3.4062,3.5009,3.5972,3.6953,3.7951,3.8967,4]"
    },
    {
        "title": "next",
        "cal": "next(X)",
        "params": "`X` is a vector. ",
        "exp": "Shift the elements of a vector to the left for one position. In comparison, :doc:`../p/prev` shifts the elements of a vector to the right for one position; :doc:`../m/move` shifts the elements of a vector for multiple positions.",
        "eg": "\n    $ x = 1..5;\n    $ x;\n    [1,2,3,4,5]\n\n    $ next(x);\n    [2,3,4,5,]"
    },
    {
        "title": "nextState",
        "cal": "nextState(X)",
        "params": "`X` is a vector or matrix of temporal/Boolean/numeric type.",
        "exp": "Consecutive elements in *X* with the same value feature the same state, and a NULL value has no state. The state of each element is equal to its value. Return the next state of the current state for each element in X. If it is NULL, return the next adjacent state.",
        "eg": "\n    $ X = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\n    $ next(X)\n    [2.2,,2.2,2.3,1,1.2,]\n    \n    $ nextState(X)\n    [2.2,2.2,2.2,2.3,1,1.2,]\n\n    $ X = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\n    $ nextState(X)\n"
    },
    {
        "title": "norm",
        "cal": "norm(mean, std, count)",
        "params": "`mean` is a numeric scalar indicating the mean of a normal distribution.",
        "exp": "Return a vector(matrix) that follows a normal distribution. ",
        "eg": "\n    $ norm(2.0,0.1,3);\n    [2.026602,1.988621,2.101107]\n\n    $ mean norm(3,1,10000);\n    3.007866\n\n\n    $ std norm(10000);\n    0.995806\n\n    //Generate a random matrix\n    $ norm(0, 1, 3:2)\n"
    },
    {
        "title": "normal",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "not",
        "cal": "not(X) or !(X)",
        "params": "`X` is a scalar/pair/vector/matrix.",
        "exp": "Return NOT of each element of X. Returned values are 0, 1, or NULL. NOT of 0 is 1; NOT of NULL is still NULL; NOT of all other values is 0.  ",
        "eg": "\n    $ !1.5;\n    0\n\n    $ not 0;\n    1\n\n    $ x=1 0 2;\n    $ not x;\n    [0,1,0]\n"
    },
    {
        "title": "now",
        "cal": "now([nanoSecond=false])",
        "params": "`nanoSecond` a Boolean value indicating whether to display the result with nanosecond precision.",
        "exp": "Return the current timestamp.",
        "eg": "\n    $ now();\n    2016.05.12T19:32:49.613\n\n    $ now(true);\n    2016.05.12T19:32:49.614243000"
    },
    {
        "title": "nullCompare",
        "cal": "nullCompare(func, X, Y)",
        "params": "`func` is the operator, <, >, >=, <=, or the function between, in.",
        "exp": "Return a Boolean value which is the result of \"func(X,Y)\". Return NULL if the calculation involves NULL values. This function is not affected by the configuration paramter *nullAsMinValueForComparison*.",
        "eg": "When nullAsMinValueForComparison=true, a NULL value is treated as the minimum value in data comparison. Function ``nullCompare``, however, returns NULL values, which is not affected by the configuration paramter *nullAsMinValueForComparison*.\n"
    },
    {
        "title": "nullFill",
        "cal": "nullFill(X, Y)",
        "params": "`X` is a vector/matrix/table.",
        "exp": "When `X` is a vector/matrix:",
        "eg": "Ex 1. For vectors:\n"
    },
    {
        "title": "nullFill!",
        "cal": "nullFill!(X, newValue)",
        "params": "Please refer to :doc:`nullFill`. The only difference between ``nullFill`` and ``nullFill!`` is that the latter assigns the result to `X` and thus changing the value of `X` after the execution. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "nunique",
        "cal": "nunique(X)",
        "params": "`X` is a vector or a tuple composed of multiple vectors with same length.",
        "exp": "If *X* is a vector, return the number of unique elements in *X*.",
        "eg": "\n    $ v = [1,3,1,-6,NULL,2,NULL,1];\n    $ nunique(v);\n    5\n"
    },
    {
        "title": "objByName",
        "cal": "objByName(name, [sharedVar])",
        "params": "`name` is a string indicating a table name.",
        "exp": "DolphinDB parses script before execution. The parsing procedure checks if a variable has been defined locally. If not, it will throw an exception. Assume we execute a locally defined function at remote nodes and the function queries a shared table that exists at remote nodes but not at the local node. If we directly call the table name in SQL statements, the system will fail to parse.",
        "eg": "At the local node we have a table `EarningsDates` with 2 columns: `TICKER` and `date`. date is the earning announcement date. There is a table `USPrices` at a remote node with machine name \"localhost\" and port number 8081. It contains daily stock prices for all US stocks. We would like to get the stock prices from the remote node for all stocks in `EarningsDates` for the week after they announced earnings.\n\nAt the remote node, we import the data file to create the table `USPrices`, and then share it across all nodes as `sharedUSPrices`.\n"
    },
    {
        "title": "objectChecksum",
        "cal": "objectChecksum(vector, [prev])",
        "params": "`vector` is a vector that is used for calculating checksums.",
        "exp": "Calculate the checksum of a vector. The result is an integer. It is often used to verify data integrity.",
        "eg": "\n    $ print objectChecksum(take(`A`B`C, 10))\n    -268298654\n    \n    $ print objectChecksum(2.3 6.5 7.8)\n    -430996932\n\n    //calculate checksum section by section\n    $ print objectChecksum(1..15)\n    -1877567753\n\n    $ t0 = objectChecksum(1..5)\n    $ t1 = objectChecksum(6..10, t0)\n    $ t2 = objectChecksum(11..15, t1)\n    $ print t2 \n    -1877567753"
    },
    {
        "title": "objs",
        "cal": "objs([shared=false])",
        "params": "`shared` is Boolean variable. ",
        "exp": "Obtain the information on the variables in memory. Return a table with the following columns:",
        "eg": "\n    //create a DFS database\n    $ if(existsDatabase(\"dfs://listdb\")){\n    $         dropDatabase(\"dfs://listdb\")\n    $ }\n    $ n=1000000\n    $ ticker = rand(`MSFT`GOOG`FB`ORCL`IBM,n);\n    $ ticker[0..5]\n    $ x=rand(1.0, n)\n    $ t=table(ticker, x)\n    $ db=database(directory=\"dfs://listdb\", partitionType=HASH, partitionScheme=[STRING, 5])\n    $ pt=db.createPartitionedTable(t, `pt, `ticker)\n    $ pt.append!(t)\n\n    // shared in-memory table\n    $ time = take(2021.08.20 00:00:00..2021.08.30 00:00:00, 40);\n    $ id = 0..39;\n    $ value = rand(100, 40);\n    $ tmp = table(time, id, value);\n    $ share tmp as st\n\n    // create set\n    $ s = set([1,2,3,4,5])\n\n    // create dict\n    $ x=1 2 3\n    $ y=4.5 7.8 4.3\n    $ z=dict(x,y);\n\n    // create matrix\n    $ m = matrix(1 2 3, 4 5 6)\n\n    // create pair\n    $ p = 1:2\n"
    },
    {
        "title": "ols",
        "cal": "ols(Y, X, [intercept=true], [mode=0])",
        "params": "`Y` is the dependent variable; `X` is the independent variable(s). ",
        "exp": "Return the result of an ordinary-least-squares regression of *Y* on *X*. ",
        "eg": "\n    $ x1=1 3 5 7 11 16 23\n    $ x2=2 8 11 34 56 54 100\n    $ y=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n\n    $ ols(y, x1);\n    [-9.912821,3.378632]\n\n    $ ols(y, (x1,x2));\n    [-9.494813,2.806426,0.13147]\n"
    },
    {
        "title": "olsEx",
        "cal": "olsEx(ds, Y, X, [intercept=true], [mode=0])",
        "params": "`ds` a set of data sources stored in a tuple. It is usually generated by the function :doc:`../s/sqlDS`.",
        "exp": "Return the result of an ordinary-least-squares regression of *Y* on *X*. *Y* and *X* are columns in a partitioned table. ",
        "eg": "\n    $ n=10000\n    $ ID=rand(100, n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ vol=rand(1..10 join int(), n)\n    $ price=rand(100,n)\n    $ t=table(ID, date, vol,price)\n    $ saveText(t, \"D:/DolphinDB/Data/t.txt\");\n    $ if(existsDatabase(\"dfs://rangedb\")){\n    $ \tdropDatabase(\"dfs://rangedb\")\n    $ }\n    $ db = database(directory=\"dfs://rangedb\", partitionType=RANGE, partitionScheme=0 51 101)\n    $ USPrices=loadTextEx(dbHandle=db,tableName=`USPrices, partitionColumns=`ID, filename=\"D:/DolphinDB/Data/t.txt\");\n\n    $ ds=sqlDS(<select vol as VS, price as SBA from USPrices where vol>5>)\n    $ rs=olsEx(ds, `VS, `SBA, true, 2)\n    $ rs;\n    \n    RegressionStat->\n    item         statistics\n    ------------ ----------\n    R2           0.000848  \n    AdjustedR2   0.000628  \n    StdError     1.404645  \n    Observations 4535      \n\n    ANOVA->\n    Breakdown  DF   SS          MS       F        Significance\n    ---------- ---- ----------- -------- -------- ------------\n    Regression 1    7.592565    7.592565 3.848178 0.049861    \n    Residual   4533 8943.739298 1.973029                      \n    Total      4534 8951.331863                               \n\n    Coefficient->\n    factor    beta     stdError tstat      pvalue  \n    --------- -------- -------- ---------- --------\n    intercept 7.953084 0.04185  190.039423 0       \n    SBA       0.001422 0.000725 1.961677   0.049861\n"
    },
    {
        "title": "oneHot",
        "cal": "oneHot(obj, encodingColumns)",
        "params": "`obj` is an in-memory table.",
        "exp": "Perform one-hot encoding on the specified columns in an in-memory table. It returns a table with columns in the order of encoded columns and non-encoded columns. The name of the encoded columns is original column name_value.",
        "eg": "\n    $ t = table( take(`Tom`Lily`Jim, 10) as name, take(true false, 10) as gender, take(21..23,10) as age);\n    $ oneHot(t, `name`gender);\n"
    },
    {
        "title": "pack",
        "cal": "pack(format, args)",
        "params": "`format` is a format string. See appendix 1 Format Characters.",
        "exp": "Return a bytes object packed according to the format string format. ",
        "eg": "\n    $ res = pack(\"N\",1);\n    $ res1 = unpack(\"N\", res);\n    $ print(res1)\n    (1)\n\n    $ res = pack(\"iii\", 1, 2, 3)\n    $ res1 = unpack(\"iii\",  res);\n    $ print(res1)  \n    (1,2,3)\n\n    $ res = pack(\"x\",NULL)\n    $ res = unpack(\"x\",pack(\"x\",NULL))\n    $ typestr(res[0])  \n    VOID\n    \n    $ res = pack(\"3si\", `123, 3)\n    $ res1 = unpack(\"3si\",  res);\n    $ print(res1)  \n    (\"123\",3)"
    },
    {
        "title": "pair",
        "cal": "pair(a, b) or a:b ",
        "params": "`a` and `b` must be scalar.",
        "exp": "Return a data pair.",
        "eg": "\n    $ 1:3+1;\n    2:4\n\n    $ 1:3<0:6;\n    0 : 1"
    },
    {
        "title": "panel",
        "cal": "panel(row, col, metrics, [rowLabel], [colLabel], [parallel=false])",
        "params": "`row` is a vector. Each element corresponds to a row in a matrix in the result. ",
        "exp": "Rearrange *metrics* as a matrix (or multiple matrices). For each vector in *metrics*, return a matrix. ",
        "eg": "\n    $ t = table(1 1 2 2 2 3 3 as id, 2020.09.01 + 1 3 1 2 3 2 3 as date, 1..7 as value);\n    t;\n"
    },
    {
        "title": "parseExpr",
        "cal": "parseExpr(X, [varDict], [modules], [overloadedOperators])",
        "params": "`X` is a string scalar/vector. ",
        "exp": "Convert string into metacode, which can be executed by function :doc:`../e/eval`.",
        "eg": "\n    $ a=parseExpr(\"1+2\")\n    $ a;\n    < 1 + 2 >\n\n    $ typestr(a);\n    CODE\n\n    $ a.eval();\n    3"
    },
    {
        "title": "partial",
        "cal": "partial(func, args...)",
        "params": "`func` is a function.",
        "exp": "Create a partial application. ",
        "eg": "\n    $ partial(add,1)(2);\n    3\n\n    $ def f(a,b):a pow b\n    $ g=partial(f, 2)\n    $ g(3);\n    8"
    },
    {
        "title": "pca",
        "cal": "pca(X, [colNames], [k], [normalize], [maxIter], [svdSolver], [randomState])",
        "params": "`ds` is one or multiple data source. It is usually generated by function :doc:`../s/sqlDS`.",
        "exp": "Conduct principal component analysis for the specified columns of the data source. Return a dictionary with the following keys:",
        "eg": "\n    $ x = [7,1,1,0,5,2]\n    $ y = [0.7, 0.9, 0.01, 0.8, 0.09, 0.23]\n    $ t=table(x, y)\n    $ ds = sqlDS(<select * from t>);\n\n    $ pca(ds);\n\n    components-> \n    #0        #1\n    --------- ---------\n    -0.999883 0.015306\n    -0.015306 -0.999883\n"
    },
    {
        "title": "pcall",
        "cal": "pcall(func, args...)",
        "params": "`func` is an aggregate function. The output of the function must be a vector or a table with the same length as all vectors or table columns in args.",
        "exp": "Conduct parallel computing of a vector function. ``pcall`` divides each argument into multiple parts and conducts the calculation in parallel. If the length of the vectors or table columns of the input variables is less than 100,000, ``pcall`` will not conduct the calculation in parallel.",
        "eg": "\n    $ x = rand(1.0, 10000000);\n    $ timer(10) sin(x);\n    Time elapsed: 739.561 ms\n\n    $ timer(10) pcall(sin, x);\n    Time elapsed: 404.56 ms"
    },
    {
        "title": "pcross",
        "cal": "pcross(func, X, [Y])",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "peach",
        "cal": "peach(func, args...)",
        "params": "``peach`` is the parallel computing version of template function ``each``. For tasks that take a long time to finish, ``peach`` can save a significant amount of time over ``each``. For light tasks, however, ``peach`` may take longer than each as the overhead of parallel function call is not trivial.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "percentChange",
        "cal": "percentChange(X)",
        "params": "`X` is a vector or a matrix.",
        "exp": "If `X` is a vector, for each element in `X`, compute the percentage change relative to the previous element. The first element of the result is always NULL.",
        "eg": "\n    $ percentChange([1,2,3]);\n    [,1,0.5]\n\n    $ percentChange(85 90 95);\n    [,0.058824,0.055556]\n"
    },
    {
        "title": "percentile",
        "cal": "percentile(X, percent, [interpolation='linear'])",
        "params": "`X` is a vector or a matrix.",
        "exp": "If `X` is a vector, return the given percentile of `X`. The calculation ignores NULL values.",
        "eg": "\n    $ a=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\n\n    $ percentile(a,50);\n    40\n\n    $ percentile(a,54);\n    40.4\n\n    $ percentile(a,25,\"lower\");\n    15\n\n    $ percentile(a,75,\"higher\");\n    43\n\n    $ percentile(a,5,\"midpoint\");\n    6.5\n\n    $ percentile(a,5,\"nearest\");\n    6\n"
    },
    {
        "title": "percentileRank",
        "cal": "percentileRank(X, score, [method='excel'])",
        "params": "`X` is a vector/matrix. If it is a matrix, calculate the percentile for each column and output a vector.",
        "exp": "Calculate the percentile (0~100) of a \"score\" in a vector with NULL values ignored.",
        "eg": "\n    $ a = 2 3 4 4 5;\n    $ percentileRank(a, 4);\n    66.666667\n    $ percentileRank(a, 3);\n    25\n    $ percentileRank(a, 4, \"rank\");\n    70\n    $ percentileRank(a,75,\"weak\");\n    80\n    $ percentileRank(a,5,\"strict\");\n    40\n    $ percentileRank(a,5,\"mean\");\n    60\n\n    $ percentileRank(1 5 8, 6, \"excel\")  \n    66.666667"
    },
    {
        "title": "pipeline",
        "cal": "pipeline(initTasks, followers, [queueDepth=2])",
        "params": "`initTasks` is the collection of the initial steps of all tasks, which is represented by a zero-argument function. For example, if we have 10 tasks then `initialTasks` is a tuple of 10 zero-argument functions.",
        "exp": "Optimize tasks that meet the following conditions through multithreading:",
        "eg": "In the following example, we need to convert the partitioned table `stockData` into a csv file. This table contains data from 2008 to 2018 and exceeds the available memory of the system, so we cannot load the entire table into memory and then converted it into a csv file. The task can be divided into multiple sub-tasks, each of which consists of two steps: load one month of data into memory, and then store the data in the csv file. To store the data of a month in the csv file, it must be ensured that the data of the month has been loaded into the memory, and the that data of the previous month has been stored in the csv file.\n"
    },
    {
        "title": "pivot",
        "cal": "pivot(func, funcArgs, rowAlignCol, colAlignCol)",
        "params": "`func` is an aggregate function.",
        "exp": "Rearrange the results of an aggregate function as a matrix.",
        "eg": "A trader needs to calculate the volume-weighted average prices (vwap) for each stock in every minute, and the pair-wise correlations of stock returns based on the vwap price series. The data are in a table with 4 columns: sym, price, qty, and trade_time.\n\nWe first use the ``pivot`` template to pivot the data to a vwap price matrix with the time as row label and the stock symbol as column label. Then we use the :doc:`cross <cross>` template to calculate the pairwise correlation.\n"
    },
    {
        "title": "ploadText",
        "cal": "ploadText(filename, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader])",
        "params": "Please refer to function :doc:`../l/loadText`.",
        "exp": "Load a text data file in parallel as an in-memory partitioned table. It returns a in-memory table with sequential partitions. ``ploadText`` is faster than ``loadText``. ",
        "eg": "\n    $ n=1000000\n    $ timestamp=09:30:00+rand(18000,n)\n    $ ID=rand(100,n)\n    $ qty=100*(1+rand(100,n))\n    $ price=5.0+rand(100.0,n)\n    $ t1 = table(timestamp,ID,qty,price)\n    $ saveText(t1, \"C:/DolphinDB/Data/t1.txt\");\n\n    $ timer tt1=loadText(\"C:/DolphinDB/Data/t1.txt\");\n    Time elapsed: 437.236 ms\n\n    $ timer tt2=ploadText(\"C:/DolphinDB/Data/t1.txt\");\n    $ Time elapsed: 241.126 ms\n\n    $ typestr(tt2);\n    $ SEGMENTED IN-MEMORY TABLE\n"
    },
    {
        "title": "ploop",
        "cal": "ploop(func, args...)",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "plot",
        "cal": "plot(data, [labels], [title], [chartType=LINE], [stacking=false], [extras])",
        "params": "`data` could be a vector, tuple, matrix, or table.",
        "exp": "Generate a chart object.",
        "eg": "Example 1: plot a table\n"
    },
    {
        "title": "plotHist",
        "cal": "plotHist(data, [binNum], [range], [title])",
        "params": "`data` is a vector, or a matrix column, or a table column.",
        "exp": "Generate a histogram chart object.",
        "eg": "\n    $ x=norm(0.0, 1.0, 10000);\n    $ plotHist(x, 10)\n"
    },
    {
        "title": "pnodeRun",
        "cal": "pnodeRun(function, [nodes], [addNodeAlias=true])",
        "params": "`function` the local function to call. It must not be quoted. It can be a function with no parameters by definition, or a partial application that wraps the orginal function and its parameters to a function with no parameters. It can be a built-in function or a user-defined function.",
        "exp": "Call a local function on all data nodes and compute nodes in a cluster in parallel and then merge the results. ",
        "eg": "Ex. 1 Call function ``getChunksMeta`` without specifying parameters\n"
    },
    {
        "title": "point",
        "cal": "point(X, Y)",
        "params": "`X` and `Y` are numeric scalars, pairs, vectors or matrices. They can be of integral (compress or INT128 not included) or floating type.",
        "exp": "Generate a POINT type data to store the location of a midpoint in the coordinate system.",
        "eg": "\n    $ point(117.60972, 24.118418)\n    (117.60972, 24.118418)\n\n    $ point(1..5,6..10)\n"
    },
    {
        "title": "polynomial",
        "cal": "polynomial(X, coeffs)",
        "params": "`X` is a scalar/vector. ",
        "exp": "Apply the polynomial coefficient vector coeffs on each element of `X`. Return a vector of the same length as `X`.",
        "eg": "The following example calculates :math:`1+2*x + 3*x^2` for each number from 1 to 10.\n"
    },
    {
        "title": "pop!",
        "cal": "pop!(X)",
        "params": "`X` is a vector. ",
        "exp": "Remove the last element of `X`. ",
        "eg": "\n    $ x = 1 2 3;\n    $ pop!(x); \n    3\n\n    $ x;\n    [1,2]"
    },
    {
        "title": "pow",
        "cal": "pow(X, Y)",
        "params": "`X` and `Y` is a scalar/vector/matrix.",
        "exp": "Raise all elements of `X` to the power of `Y`.",
        "eg": "\n    $ x=1 2 3;\n    $ pow(x,3);\n    [1,8,27]\n    $ pow(3,x);\n    [3,9,27]\n\n    $ y=4.5 5.5 6.5;\n    $ pow(x,y);\n    [1,45.254834,1262.665039]\n\n    $ pow(y,x);\n    [4.5,30.25,274.625]\n"
    },
    {
        "title": "predict",
        "cal": "predict(model, X)",
        "params": "`model` is a dictionary of the specifications of a prediction model. It is generated by functions such as :doc:`../r/randomForestClassifier` or :doc:`../r/randomForestRegressor`.",
        "exp": "Make a prediction with the specified prediction model and data. The result is a vector with the same number of elements as the the number of rows in `X`. Each element of the vector corresponds to the predicted value of a row in `X`.",
        "eg": "The following example uses the model generated by randomForestRegressor for prediction.\n"
    },
    {
        "title": "prev",
        "cal": "prev(X)",
        "params": "`X` is a vector.",
        "exp": "Shift the elements of a vector to the right for one position. In comparison, :doc:`../n/next` shifts the elements of a vector to the left for one position; :doc:`../m/move` shifts the elements of a vector for multiple positions.",
        "eg": "\n    $ x=3 9 5 1 4;\n    $ prev(x);\n    [,3,9,5,1]"
    },
    {
        "title": "prevState",
        "cal": "prevState(X)",
        "params": "`X` is a vector or matrix of temporal/Boolean/numeric type.",
        "exp": "Consecutive elements in *X* with the same value feature the same state, and a NULL value has no state. The state of each element refers to its value. Return the previous state of the current element. If it is NULL, return the previous adjacent state.",
        "eg": "\n    $ X = [1, 2.2, NULL, 2.2, 2.3, 1, 1.2]\n    $ prev(X)\n    [,1,2.2,,2.2,2.3,1]\n    \n    $ prevState(X)\n    [,1,2.2,2.2,2.2,2.3,1]\n\n    $ X = matrix([1.0, 1.1, 1.0, 0.9], [NULL, 1.3, 2.5, 5.5], [5.5, 4.2, 1.6, 1.8])\n    $ prevState(X)\n"
    },
    {
        "title": "print",
        "cal": "print(X)",
        "params": "`X` is arbitrary data.",
        "exp": "Print out results and variable contents.",
        "eg": "\n    $ x=rand(10000,10);\n    $ print x;\n    [9786,9501,8116,1266,1719,789,8162,3113,2740,6323]"
    },
    {
        "title": "prod",
        "cal": "prod(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "If `X` is a vector, return the product of all the elements in `X`.",
        "eg": "\n    $ prod(1 2 NULL 3);\n    6\n"
    },
    {
        "title": "push!",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "qclp",
        "cal": "qclp(r, V, k, [A], [b], [Aeq], [beq], [x0], [c], [eps], [alpha])",
        "params": "`V`, `A` and `Aeq` must be matrices with the same number of columns. ",
        "exp": "Solve the following optimization problem with a linear objective function and a set of constraints including a quadratic constraint. ",
        "eg": "Determine the optimal portfolio based on expected average returns (r) and the variance-covariance matrix (V) of selected stocks, and the constraints that the volatility of the portfolio should be no more than 11% and the weight of each stock in the portfolio is between 10% and 50%.\n"
    },
    {
        "title": "qr",
        "cal": "qr(obj, [mode='full'], [pivoting=false])",
        "params": "`obj` is a matrix.",
        "exp": "Perform the QR decomposition of a matrix. Decompose a matrix A into an orthogonal matrix Q and an upper triangular matrix R, with A=Q*R.",
        "eg": "\n    $ A = matrix([2,5,7,5], [5,2,5,4], [8,2,6,4]);\n\n    $ Q,R = qr(A);\n    $ Q;\n"
    },
    {
        "title": "quadprog",
        "cal": "quadprog(H, f, [A], [b], [Aeq], [beq])",
        "params": "`H`, `A` and `Aeq` must be matrices with the same number of columns. ",
        "exp": "Solve the following optimization problem with a quadratic objective function and a set of linear constraints.",
        "eg": "Example 1: Find the minimum of\n\n:math:`x_1^2 + 3x_2^2 - 2x_1x_2 - 5x_1 + 4x_2`\n"
    },
    {
        "title": "quantile",
        "cal": "quantile(X, q, [interpolation='linear'])",
        "params": "`X` is a numeric vector.",
        "exp": "Return values at the given quantile in `X`. ",
        "eg": "\n    $ a=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\n    $ quantile(a,0.25);\n    25.5\n\n    $ quantile(a,0.5);\n    40\n\n    $ quantile(a,0.75);\n    42.5\n\n    $ quantile(a,0.75, 'lower');\n    42\n"
    },
    {
        "title": "quantileSeries",
        "cal": "quantileSeries(X, q, [interpolation='linear'])",
        "params": "`X` is a numeric vector.",
        "exp": "Return values at the given quantile in `X`. ",
        "eg": "\n    $ a=[6, 47, 49, 15, 42, 41, 7, 39, 43, 40, 36];\n    $ quantileSeries(a,[0.25,0.5,0.75]);\n    [25.5,40,42.5]\n\n    $ quantileSeries(a,[0.25,0.5,0.75], 'higher');\n    [36,40,43]\n"
    },
    {
        "title": "quarterBegin",
        "cal": "quarterBegin(X, [startingMonth=1], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first day of the quarter that `X` belongs to. The first months of the quarters are determined by `startingMonth`. Note that `startingMonth`\\=1 is equivalent to `startingMonth`\\=4, 7 or 10.",
        "eg": "\n    $ quarterBegin(2012.06.12);\n    2012.04.01\n\n    $ quarterBegin(2012.06.13 10:10:10.008,5);\n    2012.05.01\n\n    $ date=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\n    $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ select avg(price),sum(qty) from t1 group by quarterBegin(date,1,2016.01.01,2)\n"
    },
    {
        "title": "quarterEnd",
        "cal": "quarterEnd(X, [endingMonth=12], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first day of the quarter that `X` belongs to. The first months of the quarters are determined by `startingMonth`. Note that `startingMonth`\\=1 is equivalent to `startingMonth`\\=4, 7 or 10.",
        "eg": "\n    $ quarterEnd(2012.06.12);\n    2012.06.30\n\n    $ quarterEnd(2012.06.13 10:10:10.008,5);\n    2012.08.31\n\n    $ date=2016.01.12 2016.02.25 2016.05.12 2016.06.28 2016.07.10 2016.08.18 2016.09.02 2016.10.16 2016.11.26 2016.12.30\n    $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n    $ sym = take(`MSFT,10)        \n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ select avg(price),sum(qty) from t1 group by quarterEnd(date,12,2016.01.01,2)\n"
    },
    {
        "title": "quarterOfYear",
        "cal": "quarterOfYear(X)",
        "params": "`X` is a scalar/vector of type DATE, MONTH, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "For each element in `X`, return a number from 1 to 4 indicating which quarter of the year it falls in.  ",
        "eg": "\n    $ quarterOfYear(2012.07.02);\n    3\n\n    $ quarterOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n    [2,4,1,2]\n"
    },
    {
        "title": "rad2deg",
        "cal": "rad2deg(X)",
        "params": "`X` is a scalar/vector.",
        "exp": "Convert angle units from radians to degrees for each element of `X`.",
        "eg": "\n    $ rad2deg(pi);\n    180\n"
    },
    {
        "title": "rand",
        "cal": "rand(X, count)",
        "params": "`X` is a scalar/vector. ",
        "exp": "Return a vector/matrix of random values.",
        "eg": "\n    $ x=rand(10, 20); \n\n    // generate 20 random nonnegative integers less than 10  \n    $ x;                                              \n    [9,9,8,1,1,0,8,3,2,6,4,6,9,6,8,9,3,2,1,5]      \n\n    // generate 10 random nonnegative double values less than 9.8\n    $ rand(9.8, 10);          \n    [3.653754,1.750518,0.055747,5.219222,2.473778,6.337576,7.797493,1.392241,0.149499,5.697612]\n\n    // generate 3 random values drawn from vector x\n    $ x=3 5 4 6 9;\n    $ rand(x, 3);                \n    [9,3,6]\n\n    $ rand(10.0, 2:2) // generate a 2*2 random matrix less than 10\n"
    },
    {
        "title": "randBeta",
        "cal": "randBeta(alpha, beta, count)",
        "params": "The shape parameters `alpha` and `bata` are positive floating numbers.",
        "exp": "Return a vector of random values with beta distribution.",
        "eg": "\n    $ randBeta(2.31, 0.627, 2);\n    [0.781246, 0.951372]\n"
    },
    {
        "title": "randBinomial",
        "cal": "randBinomial(trials, p, count)",
        "params": "`trials` is a positive integer.",
        "exp": "Return a vector of random values with binomial distribution.",
        "eg": "\n    $ randBinomial(2, 0.627, 2);\n    [1, 1]\n"
    },
    {
        "title": "randChiSquare",
        "cal": "randChiSquare(df, count)",
        "params": "`df` is a positive integer indicating the degree of freedom of a chi-squared distribution.",
        "exp": "Return a vector of random values with chi-squared distribution.",
        "eg": "\n    $ randChiSquare(2.31, 2);\n    [2.78303, 2.868523]\n"
    },
    {
        "title": "randDiscrete",
        "cal": "randDiscrete(v, p, count)",
        "params": "`v` is a vector/tuple indicating the sample data.",
        "exp": "Generate a sample of size count with random values sampling from v based on the specified probability distribution p.",
        "eg": "\n    $ randDiscrete(1..5, [0.1, 0.1, 0.2, 0.2, 0.4], 10)\n    [2,3,5,2,5,5,2,1,1,2]\n\n    //If the sum of p is not 1, it will be normalized automatically.\n    $ randDiscrete(1..5, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n    [5,1,2,3,5]\n\n    $ randDiscrete(`A`B`C`E`F, [0.1, 0.2, 0.3, 0.4, 0.5], 5)\n    [\"C\",\"E\",\"B\",\"C\",\"F\"]\n\n    // Sample from each element in a tuple.\n    $ randDiscrete([[1,2], [2,3,4], 'S', 'abc'], [0.3, 0.3, 0.2, 0.1], 10)\n    ('S',[2,3,4],[1,2],[2,3,4],[1,2],'S','S',[2,3,4],[2,3,4],[2,3,4])\n\n    // Sample from each vector in an array vector.\n    $ a = array(INT[], 0, 10).append!([1 2 3, 4 5,6 7 8, 9 NULL])\n    $ randDiscrete(a, [0.1, 0.2, 0.3, 0.4], 10)\n    [[9,00i],[9,00i],[9,00i],[4,5],[9,00i],[1,2,3],[9,00i],[6,7,8],[9,00i],[9,00i]]"
    },
    {
        "title": "randExp",
        "cal": "randExp(mean, count)",
        "params": "`mean` is the mean of an exponential distribution.",
        "exp": "Return a vector of random values with exponential distribution.",
        "eg": "\n    $ randExp(2.31, 2);\n    [0.732791, 0.732791]\n"
    },
    {
        "title": "randF",
        "cal": "randF(numeratorDF, denominatorDF, count)",
        "params": "`numeratorDF` are `denominatorDF` are positive integers indicating degrees of freedom of an F distribution. ",
        "exp": "Return a vector of random values with F distribution.",
        "eg": "\n    $ randF(2.31, 0.671, 2);\n    [0.41508, 0.642609]\n"
    },
    {
        "title": "randGamma",
        "cal": "randGamma(shape, scale, count)",
        "params": "The shape parameter `shape` is a positive floating number.",
        "exp": "Return a vector of random values with gamma distribution.",
        "eg": "\n    $ randGamma(2.31, 0.671, 2);\n    [0.784424, 0.716934]\n"
    },
    {
        "title": "randLogistic",
        "cal": "randLogistic(mean, s, count)",
        "params": "`mean` is the mean of a logistic distribution.",
        "exp": "Return a vector of random values with logistic distribution.",
        "eg": "  \n   $ randLogistic(2.31, 0.671, 2);\n   [2.465462, 2.577171]\n"
    },
    {
        "title": "randMultivariateNormal",
        "cal": "randMultivariateNormal(mean, covar, count, [sampleAsRow=true])",
        "params": "`mean` is a vector indicating the mean of a normal distribution.",
        "exp": "Return a matrix of random values that follow a multivariate normal distribution.",
        "eg": "\n    $ multivariateNormal([2, 3], [1.0, 1.5, 1.5, 3.0]$2:2, 5);\n"
    },
    {
        "title": "randNormal",
        "cal": "randNormal(mean, stdev, count)",
        "params": "`mean`  is the mean of a normal distribution.",
        "exp": "Return a vector of random values with normal distribution.",
        "eg": "  \n   $ randNormal(2.31, 0.671, 2);\n   [2.805524, 2.148019]\n"
    },
    {
        "title": "randPoisson",
        "cal": "randPoisson(mean, count)",
        "params": "`mean`  is the mean of a Poisson distribution.",
        "exp": "Return a vector of random values with Poisson distribution.",
        "eg": "  \n   $ randPoisson(2.31, 2);\n   [7, 2]\n"
    },
    {
        "title": "randStudent",
        "cal": "randStudent(df, count)",
        "params": "`df`  is a positive floating number indicating the degree of freedom of a Student's t-distribution.",
        "exp": "Return a vector of random values with Student's t-distribution.",
        "eg": "  \n   $ randStudent(2.31, 2);\n\n   [-0.543993, 0.375804]\n"
    },
    {
        "title": "randUniform",
        "cal": "randUniform(lower, upper, count)",
        "params": "`lower` and `upper` are numeric scalars indicating the lower bound and upper bound of a continuous uniform distribution.",
        "exp": "Return a vector of random values with continuous uniform distribution.",
        "eg": "  \n   $ randUniform(0.61, 2.31, 2);\n\n   [2.064851, 2.263172]\n"
    },
    {
        "title": "randWeibull",
        "cal": "randWeibull(alpha, beta, count)",
        "params": "The scale parameter `alpha` and the shape parameter `beta`  are both positive floating numbers. ",
        "exp": "Return a vector of random values with Weibull distribution.",
        "eg": "  \n   $ randWeibull(2.31,0.61, 2);\n\n   [0.524197, 0.51402]\n"
    },
    {
        "title": "randomForestClassifier",
        "cal": "randomForestClassifier(ds, yColName, xColNames, numClasses, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], [randomSeed])",
        "params": "`ds` is the data sources to be trained. It can be generated with function :doc:`../s/sqlDS`.",
        "exp": "Fit a random forest classification model. The result is a dictionary with the following keys: numClasses, minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName and xColNames. model is a tuple with the result of the trained trees; modelName is \"Random Forest Classifier\".",
        "eg": "Fit a random forest classification model with simulated data:\n"
    },
    {
        "title": "randomForestRegressor",
        "cal": "randomForestRegressor(ds, yColName, xColNames, [maxFeatures=0], [numTrees=10], [numBins=32], [maxDepth=32], [minImpurityDecrease=0.0], [numJobs=-1], randomSeed)",
        "params": "`ds` is the data sources to be trained. It can be generated with function :doc:`../s/sqlDS` .",
        "exp": "Fit a random forest regression model. The result is a dictionary with the following keys: minImpurityDecrease, maxDepth, numBins, numTress, maxFeatures, model, modelName and xColNames. model is a tuple with the result of the trained trees; modelName is \"Random Forest Regressor\".",
        "eg": "Fit a random forest regression model with simulated data:\n"
    },
    {
        "title": "rank",
        "cal": "rank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false], [precision])",
        "params": "`X` is a vector/matrix/table.",
        "exp": "Based on the sort order specified by *ascending*, this function returns the ranking (starting from 0) of each element in *X*.",
        "eg": "\n    $ rank(45 16 32 21);\n    [3,0,2,1]\n\n    $ rank(45 16 32 21, false);\n    [0,3,1,2]\n\n    $ rank(9 1 6 1 3 3);\n    [5,0,4,0,2,2]\n    // two identical elements have the same ranking.\n\n    $ rank(X=9 5 4 8 1 3 6 2 7, groupNum=3);\n    [2,1,1,2,0,0,1,0,2]\n\n    $ rank(X=9 5 4 8 1 3 6 2 7, ascending=false, groupNum=3);\n    [0,1,1,0,2,2,1,2,0]\n\n    $ rank(X=1 2 2 3, tiesMethod='min');\n    [0,1,1,3]\n\n    $ rank(X=1 2 2 3, tiesMethod='average');\n    [0,1.5,1.5,3]\n\n    $ rank(X=1 2 2 3, tiesMethod='first');\n    [0,1,2,3]\n\n    $ rank(1 NULL NULL 3);\n    [0,,,1]\n\n    $ rank(X=1 NULL NULL 3, ignoreNA=false);\n    [2,0,0,3]\n\n    $ t=table(1 1 1 2 2 2 2 as id, 3 5 4 6 2 7 1 as x)\n    $ t\n"
    },
    {
        "title": "ratio",
        "cal": "ratio(X, Y) or X\\\\Y",
        "params": "`X` and `Y` is a scalar/pair/vector/matrix.",
        "exp": "Returns element-by-element ratio of X to Y. Function ``ratio`` always returns floating numbers. ",
        "eg": "\n    $ 9\\2:5;\n    4.5 : 1.8\n    $ 11:25\\3:4;\n    3.666667 : 6.25\n\n    $ x=1 2 3;\n    $ x \\ 2;\n    [0.5,1,1.5]\n    $ 2 \\ x;\n    [2,1,0.666667]\n\n    $ y=4 5 6;\n    $  x \\ y;\n    [0.25,0.4,0.5]\n    $ y \\ x;\n    [4,2.5,2]\n\n    $ m1=1..6$2:3;\n    $ m1\n"
    },
    {
        "title": "ratios",
        "cal": "ratios(X)",
        "params": "`X` is a vector or a matrix.",
        "exp": "If X is a vector, return X(n)\\\\X(n-1) by scanning X. The first element of the result is always NULL. ",
        "eg": "\n    $ x=3 12 0 -5 32;\n    $ ratios x;\n    [,4,0,,-6.4]\n\n    $ x=2 3 6 NULL 28 7;\n    $ ratios x;\n    [,1.5,2,,,0.25]\n\n    $ m=matrix(100 105 109 112 108 116, 200 212 208 199 206 210);\n    $ m;\n"
    },
    {
        "title": "rdp",
        "cal": "rdp(pointList, epsilon)",
        "params": "`pointList` is a POINT vector which cannot contain NULL.",
        "exp": "Use RDP (Ramer-Douglas-Peucker) vector compression algorithm to compress the POINT type vector.",
        "eg": "\n    $ pt = point(1 2 3 4, 1 2 3 4)\n    $ rdp(pt, 0.1)\n    [(1.0, 1.0), (4.0, 4.0)]\n    \n    $ pt = point(1 2 3 4, 1 3 3 4)\n    $ rdp(pt, 0.1)\n    [(1.0, 1.0), (2.0, 3.0), (3.0, 3.0), (4.0, 4.0)]\n\n    $ temp = array(POINT,0)\n    $ n=90000\n    $ x_data = rand(10.0,n)\n    $ y_data = rand(10.0,n)\n    $ index=0\n    $ do{\n    $ temp.append!(point(x_data[index], y_data[index]))\n    $ index += 1\n    $ }while(index<n)\n    $ s=rdp(temp, 0.8)\n    $ print(s.size())   \n    82002\n    $ print(temp.size())  \n    90000\n\n\n"
    },
    {
        "title": "read!",
        "cal": "read!(handle, holder, [offset=0], [length=1])",
        "params": "`handle` is the handle of the file to read.",
        "exp": "Read a given number of data points from the handle and save them to the holder starting from the given offset, and return the number of data points read. ",
        "eg": "This example defines a function to copy a file:\n"
    },
    {
        "title": "readBytes",
        "cal": "readBytes(fileHandle, sizeInByte)",
        "params": "`fileHandle` is the handle of the file to read.",
        "exp": "Read the given number of bytes from the handle. If the file reaches the end or an IO error occurs, an IOException will be raised; otherwise a buffer containing the given number of bytes will return. We must know the exact number of bytes to read before calling this function.",
        "eg": "This example defines a function to copy a file:\n"
    },
    {
        "title": "readLine",
        "cal": "readLine(handle)",
        "params": "`handle` is the handle of the file to read.",
        "exp": "Read a line from the given file. The return line doesn't include the line delimiter. If the file reaches the end, the function will return a NULL object which can be tested by the  :doc:`../i/isNull` function. ",
        "eg": "\n    $ x=`IBM`MSFT`GOOG`YHOO`ORCL;\n    $ eachRight(writeLine, file(\"test.txt\",\"w\"), x);\n    [1,1,1,1,1]\n    $  fin = file(\"test.txt\")\n    $  do{\n    $  x=fin.readLine()\n    $  if(x.isNull()) break\n    $  print x\n    $  }while(true);\n    \n    IBM\n    MSFT\n    GOOG\n    YHOO\n    ORCL\n\n"
    },
    {
        "title": "readLines",
        "cal": "readLines(handle, [length=1024])",
        "params": "`handle` is the handle of the file to read.",
        "exp": "Read a given number of lines from the handle.  The function returns if the handle reaches the end or the given number of lines has been read. ",
        "eg": "\n     $ timer(10){\n     $ x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n     $ eachRight(writeLine, file(\"test.txt\",\"w\"),x)\n     $ fin = file(\"test.txt\")\n     $ do{\n     $    y=fin.readLine()\n     $ } while(!y.isVoid())\n     $ fin.close()\n     $ };\n\n    Time elapsed: 277.548 ms ms\n\n     $ timer(10){\n     $ x=rand(`IBM`MSFT`GOOG`YHOO`ORCL,10240)\n     $ file(\"test.txt\",\"w\").writeLines(x)\n     $ fin = file(\"test.txt\")\n     $ do{\n     $    y=fin.readLines(1024)\n     $ } while(y.size()==1024)\n     $  fin.close()\n     $ };\n\n    Time elapsed: 28.003 ms"
    },
    {
        "title": "readLines!",
        "cal": "readLines!(handle, holder, [offset=0], [length=1])",
        "params": "`handle` is the handle of the file to read.",
        "exp": "Read a number of lines from the handle and save them to holder starting from the given offset, and return the number of lines read.",
        "eg": "\n     $ timer(100){\n     $ fin = file(\"test.txt\")\n     $ do{ y=fin.readLines(1024) } while(y.size()==1024)\n     $ fin.close()\n     $ };\n\n    Time elapsed: 79.511 ms\n    \n     $ timer(100){\n     $ fin = file(\"test.txt\")\n     $ y=array(STRING,1024)\n     $ do{ lines = fin.readLines!(y,0,1024) } while(lines==1024)\n     $ fin.close()\n     $ };\n\n    Time elapsed: 56.034 ms\n"
    },
    {
        "title": "readObject",
        "cal": "readObject(handle)",
        "params": "`handle` is the handle of the object to read.",
        "exp": "Can read all data structures including scalar, vector, matrix, set, dictionary and table to the handle. It must be executed by a logged-in user.",
        "eg": ""
    },
    {
        "title": "readRecord!",
        "cal": "readRecord!(handle, holder, [offset=0], [length])",
        "params": "`handle` is a binary file handle.",
        "exp": "Convert binary files to DolphinDB data objects. DolhinDB also provides the function :doc:`../w/writeRecord`  to covert DolphinDB data objects to binary files that can be used by other programs. ",
        "eg": "\n    // create a file handle for reading records. The binary file a.bin contains 1000 records\n    $ f=file(\"c:/DB/a.bin\")\n    $ t=table(1000:0, `PERMNO`PRC`VOL`SHROUT, `int`double`int`double)\n    $ f.readRecord!(t);\n    1000\n\n    // similarily, we can load a binary file to a DolphinDB tuple object\n    $ f=file(\"c:/DB/a.bin\")\n    $ t=loop(array, [int, double, int, double], 0, 500)  \n    // create tuple t with 4 array elements. The size of each array is 500. \n    $  f.readRecord!(t, 0, 500);                                  \n    // read the first 500 rows\n    500"
    },
    {
        "title": "rebalanceChunksAmongDataNodes",
        "cal": "rebalanceChunksAmongDataNodes([exec = false])",
        "params": "`exec` is a Boolean value indicating whether to initiate data rebalancing among data nodes. The default value is false indicating that data rebalancing will not be initiated.",
        "exp": "This function is used to rebalance data among data nodes for optimal performance after one or more data nodes are added to a DolphinDB cluster. It can only be executed on a controller by an administrator.",
        "eg": "\n    $ rebalanceChunksAmongDataNodes()\n"
    },
    {
        "title": "rebalanceChunksWithinDataNode",
        "cal": "rebalanceChunksWithinDataNode(nodeAlias, [exec=false])",
        "params": "`nodeAlias` is a string indicating the alias of a node.",
        "exp": "After volumes are added in a data node, partitions on the other volumes need to be rebalanced for optimal performance. This function is used to rebalance data among volumes within a data node. It can only be executed on a controller by an administrator in cluster mode.",
        "eg": "\n    $ rebalanceChunksWithinDataNode(\"node1\")\n"
    },
    {
        "title": "reciprocal",
        "cal": "reciprocal(X)",
        "params": "`X` is a scalar/vector/matrix. ",
        "exp": "Return element-by-element reciprocal of X. The data type of the result is always DOUBLE. ",
        "eg": "\n    $ reciprocal(10);\n    0.1\n\n    $ reciprocal(1 2 4 8);\n    [1,0.5,0.25,0.125]\n\n    $ reciprocal(1 2 4 8$2:2);\n"
    },
    {
        "title": "reduce",
        "cal": "reduce(func, X, [init], [consistent=false])",
        "params": "`func` is a binary function.",
        "exp": "The function of ``reduce`` is the same as ``accumulate``. Unlike the template ``accumulate`` that returns result of each iteration, the template ``reduce`` outputs only the last result. Refer to :doc:`accumulate` for more information.",
        "eg": "When *func* is a unary function:\n"
    },
    {
        "title": "refCount",
        "cal": "refCount(varname)",
        "params": "`varname` is a string indicating a variable name. ",
        "exp": "Return the number of times a variable is referred to. ",
        "eg": "\n    $ db=database(\"\",VALUE,1 2 3)\n    $ refCount(`db);\n    1\n\n    $ db1=db\n    $ db2=db\n    $ refCount(`db);\n    3\n"
    },
    {
        "title": "regexCount",
        "cal": "regexCount(str, pattern, [offset=0])",
        "params": "Return an integer indicating how many times pattern (a string or a regular expression pattern) occurs in str (a string).",
        "exp": "`str` is a string scalar or vector.",
        "eg": "\n    $ regexCount(\"FB IBM FB IBM AMZN\", `IBM);\n    2\n\n    $ regexCount(\"FB IBM FB IBM AMZN\", `IBM, 7);\n    1\n\n    $ regexCount(\"FB IBM FB IBM AMZN\", `AAPL);\n    0\n\n\n"
    },
    {
        "title": "regexFind",
        "cal": "regexFind(str, pattern, [offset])",
        "params": "`str` is a string scalar or vector.",
        "exp": "Search in a string for another string or a regular expression pattern and return an integer that indicates the beginning position of the first matched substring. If no substring matches, return -1.",
        "eg": "\n    $ regexFind(\"FB IBM FB IBM AMZN\", `IBM);\n    3\n\n    $ regexFind(\"FB IBM FB IBM AMZN\", `IBM, 7);\n    10\n\n    $ regexFind(\"FB IBM FB IBM AMZN\", `AAPL);\n    -1\n\n\n"
    },
    {
        "title": "regexReplace",
        "cal": "regexReplace(str, pattern, replacement, [offset])",
        "params": "`str` is a string scalar or vector.",
        "exp": "Search in a string for another string or a regular expression pattern and replace every occurrence of the matched string or pattern with the specified string. ",
        "eg": "\n    $ regexReplace(\"IBM FB IBM AMZN\", `IBM, `GOOG);\n    GOOG FB GOOG AMZN\n\n    $ regexReplace(\"IBM FB IBM AMZN\", `IBM, `GOOG, 5);\n    IBM FB GOOG AMZN\n\n    $ regexReplace(\"IBM FB IBM AMZN\", `IBM, `GOOG, 10);\n    IBM FB IBM AMZN\n\n\n"
    },
    {
        "title": "registerSnapshotEngine",
        "cal": "registerSnapshotEngine(dbName, tableName, keyColumnName)",
        "params": "`dbName` is a string indicating the name of a distributed database. ",
        "exp": "Register a snapshot engine for a distributed table. After registering the snapshot engine, we can get the most recent row of each group specified by keyColumnName with the following SQL statement: ",
        "eg": "Create a partitioned table:\n"
    },
    {
        "title": "regroup",
        "cal": "regroup(X, label, func, [byRow=true])",
        "params": "`X` is a matrix.",
        "exp": "Group the data of a matrix based on user-specified column/row labels and apply aggregation on each group.",
        "eg": "Example 1. Perform grouped aggregation on a matrix by row/column labels.\n"
    },
    {
        "title": "remoteRun",
        "cal": "remoteRun(conn, script, args)",
        "params": "`conn` represents a database connection. ",
        "exp": "Send a script or function to a remote database for execution.",
        "eg": "The first use case: execute script on a remote node. \n"
    },
    {
        "title": "removeHead!",
        "cal": "removeHead!(obj, n)",
        "params": "`obj` is a vector. ",
        "exp": "Delete the first `n` elements from a vector.",
        "eg": "\n    $ x=11..20;\n    $ x.removeHead!(3);\n    [14,15,16,17,18,19,20]\n"
    },
    {
        "title": "removeTail!",
        "cal": "removeTail!(obj, n)",
        "params": "`obj` is a vector. ",
        "exp": "Delete the last `n` elements from a vector.",
        "eg": "\n    $ x=11..20;\n    $ x.removeTail!(3);\n    [11,12,13,14,15,16,17]\n\n\n"
    },
    {
        "title": "removeTopicOffset",
        "cal": "removeTopicOffset(topic)",
        "params": "`topic` is the subscription topic returned by the :doc:`../../FunctionReferences/s/subscribeTable` function.",
        "exp": "Delete the persisted offset of the last processed message in the specified subscription topic. (The offset is persisted if the *persistOffset* parameter is enabled when calling :doc:`../../FunctionReferences/s/subscribeTable`.) ",
        "eg": ""
    },
    {
        "title": "rename!",
        "cal": "rename!(X, Y, [Z])",
        "params": "`X` is a vector/matrix/in-memory table/DFS table (for OLAP engine only).",
        "exp": "For a vector, assign a new name.",
        "eg": "\n    $ k=3 6 9;\n    $ k.rename!(`rk);\n    [3,6,9]\n\n    // one way to check name is to use function stat to get the descriptive statistics of data\n    >stat k;\n    Median->6\n    Avg->6\n    Min->3\n    Stdev->3\n    Count->3\n    Size->3\n    Name->rk        // the new name for k\n    Max->9\n"
    },
    {
        "title": "renameTable",
        "cal": "renameTable(dbHandle, tableName, newTableName)",
        "params": "`dbHandle` is a DFS database handle. ",
        "exp": "Rename a table in a DFS database.",
        "eg": ""
    },
    {
        "title": "reorderColumns!",
        "cal": "reorderColumns!(table, reorderedColNames)",
        "params": "`table` an in-memory table that is not shared. ",
        "exp": "Change the order of columns of an in-memory table. It modifies the original table instead of creating a new table. ",
        "eg": "\n    $ sym = `C`MS`MS`MS`IBM`IBM`C`C`C\n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\n    $ timestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\n    $ t = table(timestamp, sym, qty, price);\n    $ t;\n"
    },
    {
        "title": "repartitionDS",
        "cal": "repartitionDS(query, [column], [partitionType], [partitionScheme], [local=true])",
        "params": "`query` is metacode of SQL statements or a tuple of metacode of SQL statements. ",
        "exp": "Generate a tuple of data sources from a table with a new partitioning design. ",
        "eg": "\n    $ n=1000000\n    $ ID=rand(100, n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(10.0, n)\n    $ t=table(ID, date, x)\n\n    $ $ dbDate = database(, VALUE, 2017.08.07..2017.08.11)\n    dbID = database(, RANGE, 0 50 100)\n    $ db = database(\"dfs://compoDB\", COMPO, [dbDate, dbID])\n    $ pt = db.createPartitionedTable(t, `pt, `date`ID)\n    $ pt.append!(t);\n"
    },
    {
        "title": "repeat",
        "cal": "repeat(X, n)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Repeats each item in string X n times to form a new string. The size of the result is the same as the size of X. ",
        "eg": ""
    },
    {
        "title": "replace",
        "cal": "replace(X, oldValue, newValue)",
        "params": "`X` is a vector/matrix.",
        "exp": "Replace oldValue with newValue in X. ``replace!`` is the in-place change version of ``replace`` . ",
        "eg": "\n    $ x=1 1 3;\n    $ x=x.replace(1,2);  \n    $ x\n    [2,2,3];\n\n    $ m=1..4$2:2;\n    $ m\n"
    },
    {
        "title": "replace!",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "replaceColumn!",
        "cal": "replaceColumn!(table, colName, newCol)",
        "params": "`table` is an in-memory table or a DFS table. ",
        "exp": "Replace a table column with the specified vector. The data type of the new column is the same as the data type of the specified vector. The original column name is not changed. ",
        "eg": "\n    $ sym = `C`MS`MS`MS`IBM`IBM`C`C`C\n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800\n    $ timestamp = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12]\n    $ t = table(timestamp, sym, qty, price)\n    $ schema(t).colDefs;\n"
    },
    {
        "title": "replayDS",
        "cal": "replayDS(sqlObj, [dateColumn], [timeColumn], [timeRepartitionSchema])",
        "params": "`sqlObj` is metacode with SQL statements. The table object in the SQL statement is a DFS table and must use a DATE type column as one of the partitioning columns. ",
        "exp": "- Currently, parameters *dateColumn* and *timeColumn* do not support DATEHOUR type.",
        "eg": "Generates a tuple of data sources from a DFS table (queried by a SQL statement) based on its time columns. It can be further divided by the parameters *timeColumn* and *timeRepartitionSchema*.\n\nIt is used as the inputs of function `replay`. To replay a DFS table, the `replay`` function must be conjuncted with the `replayDS`` function."
    },
    {
        "title": "repmat",
        "cal": "repmat(X, rowRep, colRep)",
        "params": "`X` is a matrix.",
        "exp": "Create a large matrix consisting of a rowRep-by-colRep tiling of copies of X. ",
        "eg": "\n    $ x=matrix(1 2 3, 4 5 6);\n"
    },
    {
        "title": "resample",
        "cal": "resample(X, rule, func, [closed], [label], [origin='start_day'])",
        "params": "`X` is a matrix or series with row labels. The row labels must be non-NULL values of temporal type, and must be increasing.",
        "exp": "Apply func to X based on the frenquency (or the trading calendar) as specified in *rule*. Note that when *rule* is specified as the identifier of the trading calendar, data generated on a non-trading day will be calculated in the previous trading day.",
        "eg": ""
    },
    {
        "title": "resetDBDirMeta",
        "cal": "resetDBDirMeta(dbDir)",
        "params": "`dbDir` is a string in the format of \"volumeB/DATABASE\", indicating the destination directory to which the database will be moved.",
        "exp": "When transferring metadata across disk volumes, please call ``resetDBDirMeta`` to change the DATABASE storage path in the metadata to the destination path before transferring the metadata. This command can only be executed on the data node.",
        "eg": "2.00.4"
    },
    {
        "title": "resetPwd",
        "cal": "resetPwd(userId, newPwd)",
        "params": "`userId` a string indicating a user name.",
        "exp": "Reset a user's password. This can only be executed by an administrator on the controller.",
        "eg": "\n    $ resetPwd(`AlexEdwards, `T51pm363);"
    },
    {
        "title": "resetRecoveryWorkerNum",
        "cal": "`newWokerNum` is a positive integer that specifies the number of worker threads used for chunk recovery.",
        "params": "Modify the number of worker threads used by the current node for chunk recovery online. This command can only be executed by the administrator on the data node.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "reshape",
        "cal": "reshape(obj, [dim])",
        "params": "`obj` is a vector/matrix. ",
        "exp": "Change the dimensions of a matrix and return a new matrix. If `dim` is not specified, reshape `obj` to a vector. ",
        "eg": "\n    $ x=1..6;\n    $ x=x.reshape(3:2);  \n    $ x\n"
    },
    {
        "title": "residual",
        "cal": "residual(Y,X,params,[intercept=true])",
        "params": "`Y` is the dependent variable. It is a vector.",
        "exp": "Return the residuals from the least squares regression of *Y* on *X*.",
        "eg": "\n    $ x1=1 3 5 7 11 16 23\n    $ x2=2 8 11 34 56 54 100\n    $ y=0.1 4.2 5.6 8.8 22.1 35.6 77.2\n\n    $ params=ols(y, x1);\n    $ residual(y,x1,params)\n    [6.634188034188036,3.976923076923078,-1.380341880341881,-4.937606837606838,-5.152136752136756,-8.545299145299146,9.404273504273504]\n\n    $ params1=ols(y, (x1,x2),false);\n    $ residual(y,(x1,x2),params1,false)\n    [-1.941530853763632,-2.556479729553295,-4.923597852949359,-11.809587658969416,-11.098921251860737,-4.0152525111045,13.183836820351686]\n\n    $ x=matrix(1 4 8 2 3, 1 4 2 3 8, 1 5 1 1 5);\n    $ p1=ols(1..5, x);\n    $ residual(1..5, x,p1);\n    [-0.474770642201834,0.268348623853214,-0.123853211009174,0.598623853211011,-0.268348623853205]"
    },
    {
        "title": "restore",
        "cal": "restore(backupDir, dbPath, tableName, partition, [force=false], [outputTable], [parallel=false], [snapshot=true])",
        "params": "`backupDir` is a string indicating the directory where the backup is kept.",
        "exp": "Restore the specified partitions from the most recent backup. Return a string vector indicating the path of restored partitions. The function must be executed by a logged-in user.",
        "eg": "Create a DFS database dfs://compoDB\n"
    },
    {
        "title": "restoreDB",
        "cal": "restoreDB(backupDir, dbPath, [newDBPath])",
        "params": "`backupDir` is a string indicating the directory to save the backup.",
        "exp": "Restore the backup database. Return a table where each row is the restored database and table name.",
        "eg": "    "
    },
    {
        "title": "restoreDislocatedTablet",
        "cal": "restoreDislocatedTablet()",
        "params": "None",
        "exp": "When enableChunkGranularityConfig=false (see details in :doc:`/DatabaseandDistributedComputing/Configuration/StandaloneMode` *enableChunkGranularityConfig*) all tables in the same partition are distributed in the same node. ",
        "eg": "\n    $ restoreDislocatedTablet()\n"
    },
    {
        "title": "restoreTable",
        "cal": "restoreTable(backupDir, dbPath, tableName, [newDBPath], [newTableName])",
        "params": "`backupDir` is a string indicating the directory to save the backup.",
        "exp": "Restore the backup database. Return a table where each row is the restored database and table name. The function is equivalent to ``restore(backupDir, dbPath, tableName, force=false, parallel=true, snapshot=true)``.",
        "eg": "    "
    },
    {
        "title": "resumeRecovery",
        "cal": "resumeRecovery()",
        "params": "None",
        "exp": "Resume suspended recovery processes in \"Waiting\" status. This command can only be executed by the administrator on the controller.",
        "eg": "1.30.162.00.4\n\nRelated command: :doc:`../s/suspendRecovery`"
    },
    {
        "title": "reverse",
        "cal": "reverse(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "Return a new vector or matrix with reverse order of the original vector or matrix.",
        "eg": ""
    },
    {
        "title": "revoke",
        "cal": "revoke(userId|groupId, accessType, [objs])",
        "params": "`userId` | `groupId` a string indicating a user name or a group name. ",
        "exp": "- Revokes specified access privileges to a user or a group of users that were previously granted or denied. ",
        "eg": "Revoke the privilege of the members of the group \"production\" to read all tables in all databases:\n"
    },
    {
        "title": "ridge",
        "cal": "ridge(ds, yColName, xColNames, [alpha=1.0], [intercept=true], [normalize=false], [maxIter=1000], [tolerance=0.0001], [solver='svd'], [swColName])",
        "params": "`ds` is an in-memory table, or a data source, or a list of data sources. ",
        "exp": "Linear least squares with l2 regularization.",
        "eg": ""
    },
    {
        "title": "right",
        "cal": "right(X, n)",
        "params": "`X` is a string scalar or vector.",
        "exp": "Return the last n characters of string X. ",
        "eg": ""
    },
    {
        "title": "rm",
        "cal": "rm(filename)",
        "params": "`filename` is the path and name of the file to be deleted.",
        "exp": "Delete a file specified by path and name. It must be executed by a logged-in user.",
        "eg": "\n    $ files(\"d:/test\");\n"
    },
    {
        "title": "rmdir",
        "cal": "rmdir(directory, [recursive=false])",
        "params": "`directory` is the the path of the directory to be deleted.",
        "exp": "rmdir(directory): delete an empty directory.",
        "eg": "\n    $ files(\"d:/test\");\n"
    },
    {
        "title": "rolling",
        "cal": "rolling(func, funcArgs, window, [step=1])",
        "params": "`func` is an aggregate or vectorized function.",
        "exp": "Apply the function/operator to a sliding window of the given objects. It is a tumbling window when step = window.",
        "eg": "When *func* is the vectorized function:\n"
    },
    {
        "title": "rollingPanel",
        "cal": "rollingPanel(X, window, [groupingCol])",
        "params": "`X` is a table.",
        "exp": "Extract a fixed number of rows from a table with a rolling window to generate a new table. The rolling window moves by 1 row each time until it reaches the bottom of the table. ",
        "eg": ""
    },
    {
        "title": "round",
        "cal": "round(X, [percision])",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "round a number to the specified number of digits after the decimal point with the round half up rule.",
        "eg": ""
    },
    {
        "title": "row",
        "cal": "row(obj, index)",
        "params": "`obj` is a vector/matrix/table.",
        "exp": "Return a row of a vector/matrix/table.",
        "eg": ""
    },
    {
        "title": "rowAnd",
        "cal": "rowAnd(args...)",
        "params": "For each row (a vector is viewed as a one-column matrix here), return 1 if all columns of all input variables are true; otherwise return 0.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowAt",
        "cal": "rowAt(X, [Y])",
        "params": "`X` is a matrix or an array vector.",
        "exp": "- If *Y* is not specified, *X* must be a Boolean matrix or Boolean array vector. The ``rowAt`` function retrieves the row indices for each \"true\" element in *X* by row and returns an array vector of integers. The returned array vector has the same number of rows as *X*. If X contains a row with only Null or \"false\" elements, ``rowAt`` returns null for that row.",
        "eg": "\n    $ m = matrix(3.1 4.5 2.2, 4.2 4.3 5.1, 6.2 7.1 2.2, 1.8 6.1 5.3, 7.1 8.4 3.5)\n    $ index = 4 0 2\n    $ rowAt(m, index)\n    [7.1,4.5,2.2]\n\n    $ index = array(INT[], 0, 10).append!([0 1, 2 4, 3 4 5])\n    $ rowAt(m, index)\n    [[3.1,4.2],[7.1,8.4],[5.3,3.5,]]\n\n    $ x = array(DOUBLE[], 0, 10).append!([3.3 3.6 3.8, 3.7 3.4 3.5, 3.4 3.4 3.5])\n    $ index = array(INT[], 0, 10).append!([0 1, 2, 0 2])\n    $ rowAt(x, index)\n    [[3.3,3.6],[3.5],[3.4,3.5]]\n    "
    },
    {
        "title": "rowAvg",
        "cal": "rowAvg(args...)",
        "params": "Calculate the average of each row of the arguments. A vector is viewed as a one-column matrix here.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowBeta",
        "cal": "rowBeta(Y, X)",
        "params": "Calculate the coefficient estimate of the ordinary-least-squares regression of *Y* on *X* by row and return a vector with the same number of rows of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCorr",
        "cal": "rowCorr(X, Y)",
        "params": "Calculate the correlation between *X* and *Y* by row and return a vector with the same number of rows of *X*. NULL values are ignored in calculation.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCount",
        "cal": "rowCount(args...)",
        "params": "Return the number of non-null elements in each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCovar",
        "cal": "rowCovar(X, Y)",
        "params": "Calculate the covariance between *X* and *Y* by row and return a vector with the same number of rows of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCummax",
        "cal": "rowCummax(X)",
        "params": "``rowCummax`` calculates the cumulative maximum values in each row of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCummin",
        "cal": "rowCummax(X)",
        "params": "``rowCummin`` calculates the cumulative minimum values in each row of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCumprod",
        "cal": "rowCumprod(X)",
        "params": "``rowCumprod`` calculates the cumulative products of the elements in each row of X.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCumsum",
        "cal": "rowCumsum(X)",
        "params": "``rowCumsum`` calculates the cumulative sum of each row of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowCumwsum",
        "cal": "rowCumwsum(X, Y)",
        "params": "``rowCumwsum`` calculates the cumulative weighted sum in each row of X with Y as the weights.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowDenseRank",
        "cal": "rowDenseRank(X, [ascending=true], [ignoreNA=true], [percent=false])",
        "params": "`X` is a matrix.",
        "exp": "``rowDenseRank`` can be viewed as function :doc:`../d/denseRank` applied on rows instead of columns. It returns the consecutive rank of each element in each row.",
        "eg": ""
    },
    {
        "title": "rowDot",
        "cal": "rowDot(X, Y)",
        "params": "`X` and `Y` are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.",
        "exp": "If both *X* and *Y* are vectors/matrices, calculate the inner product between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the inner product between rows with the same label. For other rows, return NULL.",
        "eg": "\n    $ rowDot(13.5 15.2 6.3, 18.6 14.8 15.5)\n    [251.1,224.96,97.65]\n\n    $ s1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\n    $ s2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\n    $ rowDot(s1,s2) \n    [244.4,349.44,234]\n\n    $ m=matrix(23 56 47, 112 94 59)\n    $ m1=matrix(11 15 89, 52 41 63)\n    $ rowDot(m,m1)    \n    [6077,4694,7900]\n\n    $ m.rename!(2020.01.01..2020.01.03, `A`B)\n    $ m.setIndexedMatrix!()\n    $ m1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\n    $ m1.setIndexedMatrix!()\n    $ rowDot(m,m1)    \n    [6077,NULL,3124,NULL]\n\n    $ a=array(DOUBLE[],0,10)\n    $ a.append!([[10.5, 11.8, 9],[15, NULL], [2.5, 2.2, 1.3, 1.5]])\n    $ b=array(DOUBLE[],0,10)\n    $ b.append!([[1.1, 1.8, 6],[5, 6.9], [3.5, 2, 3, 2.8]])\n    $ rowDot(a,b)\n    [86.79,75,21.25]\n"
    },
    {
        "title": "rowEuclidean",
        "cal": "rowEuclidean(X, Y)",
        "params": "`X` and `Y` are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.",
        "exp": "If both *X* and *Y* are vectors/matrices, calculate the Euclidean distance between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the Euclidean distance between rows with the same label. For other rows, return NULL.",
        "eg": "\n    $ rowEuclidean(3.6 5.2 6.3, 8.6 4.8 5.5)  \n    [5,0.4,0.8]\n\n    $ m=matrix(23 56 47, 112 94 59)\n    $ m1=matrix(11 15 89, 52 41 63)\n    $ rowEuclidean(m,m1)\n    [61.1882,67.0075,42.19]\n\n    $ m.rename!(2020.01.01..2020.01.03, `A`B)\n    $ m.setIndexedMatrix!()\n    $ m1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\n    $ m1.setIndexedMatrix!()\n    $ rowEuclidean(m,m1)\n    [61.1882,NULL,36.7151,NULL]\n\n    $ a=array(INT[],0,10)\n    $ a.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\n    $ b=array(INT[],0,10)\n    $ b.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\n    $ rowEuclidean(a,b)\n    [14.4568,10,33.1059]\n"
    },
    {
        "title": "rowImax",
        "cal": "rowImax(args...)",
        "params": "Return the index of the maximum in each row. If there are multiple maxima, return the index of the first maximum from the left. The result is a vector with the same length as the number of input rows.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowImin",
        "cal": "rowImin(args...)",
        "params": "Return the index of the minimum in each row. If there are multiple minima, return the index of the first minimum from the left. The result is a vector with the same length as the number of input rows.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowKurtosis",
        "cal": "rowKurtosis(X, [biased=true])",
        "params": "`biased` is a Boolean value, indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Return the kurtosis of each row in *X*. ",
        "eg": "      \n   $ m = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2, 2.1 3.4 4.2 5.5 2.3]\n   $ rowKurtosis(m);\n   [1.336589711715856,1.839333299961742,2.248755164221374,1.437834622248661,1.341044189891083]\n   \n   $ m=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\n   $ rowKurtosis(m);\n   [2.270290894661423,1.499999999999941,1.499999999999972]\n\n   $ t1=table(1..5 as x, 10..6 as y, 15..19 as z, take(3,5) as t);\n   $ rowKurtosis(t1);\n   [1.417974225003112,1.676864,1.951167883478534,2.158698670898631,2.262015004030008]\n\n\n"
    },
    {
        "title": "rowMax",
        "cal": "rowMax(args...)",
        "params": "Calculate the maximum value of each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowMin",
        "cal": "rowMin(args...)",
        "params": "Calculate the minimum value of each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowMove",
        "cal": "rowMove(X, steps)",
        "params": "`steps` is an integer indicating the length to shift the row elements of *X*.",
        "exp": "The ``rowMove`` function shifts the elements in each row of *X* left or right by a specified number of steps.",
        "eg": "\n    $ m=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL])\n    $ rowMove(m, 2)\n    col1\tcol2\tcol3"
    },
    {
        "title": "rowNames",
        "cal": "rowNames(X)",
        "params": "`X` is a matrix.  ",
        "exp": "Return the row names of matrix X. Please check related function: :doc:`../c/columnNames`.",
        "eg": ""
    },
    {
        "title": "rowNext",
        "cal": "rowNext(X)",
        "params": "For each row in *X*, ``rowNext`` shifts the elements to the left for one position.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowNo",
        "cal": "rowNo(X)",
        "params": "`X` is a vector.  ",
        "exp": "Return the index position of each row in a table.",
        "eg": ""
    },
    {
        "title": "rowOr",
        "cal": "rowOr(args...)",
        "params": "For each row (a vector is viewed as a one-column matrix here), return 1 if all columns of all input variables are true; otherwise return 0.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowPrev",
        "cal": "rowPrev(X)",
        "params": "For each row in *X*, ``rowPrev`` shifts the elements to the right for one position.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowProd",
        "cal": "rowProd(args...)",
        "params": "Calculate the product of each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowRank",
        "cal": "rowRank(X, [ascending=true], [groupNum], [ignoreNA=true], [tiesMethod='min'], [percent=false])",
        "params": "`X` is a matrix. ",
        "exp": "Conduct the following operation within each row of matrix *X*:",
        "eg": ""
    },
    {
        "title": "rowSize",
        "cal": "rowSize(args...)",
        "params": "Calculate the number of elements (NULL values included) of each row.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowSkew",
        "cal": "rowSkew(X, [biased=true])",
        "params": "`biased` is a Boolean value, indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Return the skewness of each row in *X*. ",
        "eg": "      \n   $ m = [4.5 2.6 1.5 1.5 4.8, 5.9 4.9 2.0 4.0 6.3, 2 2 2 2 2]\n   $ rowSkew(m);\n   [-0.329206341655613,0.586870565935934,-0.707106781186563,0.595170064139497,-0.350377619697706]\n   \n   $ m=matrix([4.5 2.6 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL, 4.3 NULL 3.5]);\n   $ rowSkew(m);\n   [-1.064430070205901,0.577633692366209,0.110780117654846]\n\n   $ t1=table(1..5 as x, 10..6 as y, take(3, 5) as z);\n   $ rowSkew(t1);\n   [0.567316577993729,0.652012117044047,0.707106781186548,0.528004979218188,-0.381801774160629]\n\n"
    },
    {
        "title": "rowStd",
        "cal": "rowStd(args...)",
        "params": "Calculate the (sample) standard deviation of each row of the arguments. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowStdp",
        "cal": "rowStdp(args...)",
        "params": "Calculate the population standard deviation of each row.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowSum",
        "cal": "rowSum(args...)",
        "params": "Calculate the sum of each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowSum2",
        "cal": "rowSum2(args...)",
        "params": "Calculate the sum of square of all elements in each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowTanimoto",
        "cal": "rowTanimoto(X, Y)",
        "params": "`X` and `Y` are numeric vectors/array vectors of the same length or matrices with the same dimension. If *X* and *Y* are array vectors, the vectors at the same position in *X* and *Y* must have the same length.",
        "exp": "If both *X* and *Y* are vectors/matrices, calculate the tanimoto distance between *X* and *Y* by row. If both *X* and *Y* are indexed matrices, calculate the tanimoto distance between rows with the same label. For other rows, return NULL.",
        "eg": "\n    $ rowTanimoto(3.6 5.2 6.3, 8.6 4.8 5.5)\n    [0.4467,0.0064,0.0181]\n\n    $ a=array(INT[],0,10)\n    $ a.append!([[1, 8, 9],[15, NULL], [25, 22, 13, 15]])\n    $ b=array(INT[],0,10)\n    $ b.append!([[11, 18, 6],[5, 9], [5, 2, 3, 1]])\n    $ rowTanimoto(a,b)\n    [0.5,0.5714,0.8309]\n\n    $ s1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\n    $ s2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\n    $ rowTanimoto(s1,s2)  \n    [0.4125,0.5337,0.5526]\n\n    $ m=matrix(23 56 47, 112 94 59)\n    $ m1=matrix(11 15 89, 52 41 63)\n    $ rowTanimoto(m,m1)    \n    [0.3812,0.4889,0.1839]\n\n    $ m.rename!(2020.01.01..2020.01.03, `A`B)\n    $ m.setIndexedMatrix!()\n    $ m1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\n    $ m1.setIndexedMatrix!()\n    $ rowTanimoto(m,m1)\n    [0.3812,NULL,0.3014,NULL]\n"
    },
    {
        "title": "rowVar",
        "cal": "rowVar(args...)",
        "params": "Calculate the (sample) variance of each row of the arguments.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowVarp",
        "cal": "rowVarp(args...)",
        "params": "Calculate the population variance of each row.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowWavg",
        "cal": "rowWavg(X, Y)",
        "params": "Calculate the weighted average of *X* by row with *Y* as the weights and return a vector with the same number of rows of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowWsum",
        "cal": "rowWsum(X, Y)",
        "params": "Calculate the cumulative weighted sum of *X* by row with *Y* as the weights and return a vector with the same number of rows of *X*.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rowXor",
        "cal": "rowXor(args...)",
        "params": "For each row, return 1 if odd number of columns are true; otherwise return 0.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "rows",
        "cal": "rows(X)",
        "params": "`X` is a vector/matrix/table.  ",
        "exp": "Return the number of rows in X. Please check related function: :doc:`../c/cols`.",
        "eg": ""
    },
    {
        "title": "rpad",
        "cal": "rpad(str, length, [pattern])",
        "params": "`str` is a string scalar or vector. It is the string to pad characters to (the right-hand side).",
        "exp": "Pad the right-side of a string with a specific set of characters.",
        "eg": ""
    },
    {
        "title": "rpc",
        "cal": "rpc(nodeAlias, func, args, ...)",
        "params": "`nodeAlias` is the alias of a remote node.",
        "exp": "Call a local function on the specified remote node and return the result to the local node. The function can be either a built-in function or a user defined function on the local node. The system automatically serializes the function definition and the definitions of all dependent functions together with necessary local data to remote node. ",
        "eg": "* Remote call a user defined function:\n"
    },
    {
        "title": "rshift",
        "cal": "rshift(X, a) or X>>a",
        "params": "`X` is an integral scalar/pair/vector/matrix. ",
        "exp": "Shift bits to the right.",
        "eg": ""
    },
    {
        "title": "rtrim",
        "cal": "rtrim(X)",
        "params": "`X` is a string scalar or vector.",
        "exp": "Take a string of characters that has spaces at the end, and return the text without the spaces at the end.",
        "eg": ""
    },
    {
        "title": "run",
        "cal": "run(scriptFile, [newSession=false], [clean=true])",
        "params": "`scriptFile` is the path of the script file.",
        "exp": "Execute a saved program. It must be executed by a logged-in user.",
        "eg": "\n    $ run \"c:/test.script\";\n    $ d = dict(STRING, ANY)\n    $ d[\"TradePrice\"] = 1..1000\n    //The variable d defined in the current session is not cleaned as the parameter clean is set to false.\n    $ run(\"c:/test.script\", clean=false)    \n    $ parseExpr(\"avg(TradePrice)\",d).eval()\n    500.5"
    },
    {
        "title": "runScript",
        "cal": "runScript(script)",
        "params": "`Script` is a string indicating the script to be executed.",
        "exp": "Locally execute a script. It must be executed by a logged-in user.",
        "eg": "\n    $ t = table(1..100 as id,201..300 as val1)\n    $ script1 = 'dn = \"dfs://test\";if(existsDatabase(dn)){dropDatabase(dn)};db = database(dn,VALUE,1..10);pt = db.createPartitionedTable(t,`pt,`id).append!(t)'\n    $ script2 = 'select * from loadTable(\"dfs://test\",`pt)'\n    $ runScript(script1)\n    $ runScript(script2)"
    },
    {
        "title": "saveAsNpy",
        "cal": "saveAsNpy(obj, fileName)",
        "params": "`obj` is a numeric vector/matrix.",
        "exp": "Save a vector/matrix in DolphinDB as an npy file. It must be executed by a logged-in user.",
        "eg": "\n    $ v = 1..1000\n    $ v.saveAsNpy(\"C:/DolphinDB/intVec.npy\")\n\n    $ m = (1..1000 + 0.5)$20:50\n    $ m.saveAsNpy(\"C:/DolphinDB/doubleMat.npy\")\n"
    },
    {
        "title": "saveDatabase",
        "cal": "saveDatabase(dbHandle)",
        "params": "`dbHandle` is a DolphinDB database handle. ",
        "exp": "Save a database handle. It must be executed by a logged-in user. It is used with the :doc:`../../FunctionReferences/d/database` function.",
        "eg": "\n    $ db=database(\"C:/DolphinDB/\")\n    $ saveDatabase(db);"
    },
    {
        "title": "saveDualPartition",
        "cal": "saveDualPartition(dbHandle1, dbHandle2, table, tableName, partitionColumn1, partitionColumn2, [compression=false])",
        "params": "`dbHandle1` is the database handle of the first level partition. ",
        "exp": "Save a table in the local node before sharing it to other nodes to form a dual partition database. It must be executed by a logged-in user.",
        "eg": "\n    $ n=1000000\n    $ ID=rand(10, n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(1.0, n)\n    $ t=table(ID, date, x);\n\n    $ hdb = database(\"C:/DolphinDB/Data/dualDB\", RANGE,  0 5 10)\n    $ vdb = database(, VALUE, dates)\n    $ saveDualPartition(hdb, vdb, t, `tDualPartition, `ID, `date)"
    },
    {
        "title": "saveModel",
        "cal": "saveModel(model, location)",
        "params": "`model` is a dictionary of the specifications of a prediction model. It is generated by functions such as :doc:`../../FunctionReferences/r/randomForestClassifier` and :doc:`../../FunctionReferences/r/randomForestRegressor`.",
        "exp": "Save the specifications of a trained model to a file on disk. ",
        "eg": "\n    $ x1 = rand(100.0, 100)\n    $ x2 = rand(100.0, 100)\n    $ b0 = 6\n    $ b1 = 1\n    $ b2 = -2\n    $ err = norm(0, 10, 100)\n    $ y = b0 + b1 * x1 + b2 * x2 + err\n    $ t = table(x1, x2, y)\n    $ model = randomForestRegressor(sqlDS(<select * from t>), `y, `x1`x2)\n    $ saveModel(model, \"C:/DolphinDB/Data/regressionModel.txt\");"
    },
    {
        "title": "saveModule",
        "cal": "saveModule(name, [moduleDir], [overwrite=false])",
        "params": "`name` is a string indicating the name of the module.",
        "exp": "Serialize a module (\".dos\" file) to a binary file with a file name extension of \".dom\". It must be executed by a logged-in user.",
        "eg": "Assuming the directory \"modules\" under the node's home directory contains the module files \"ta.dos\" and  \"system/log/fileLog.dos\", the following example serializes the module files to binary files.\n"
    },
    {
        "title": "savePartition",
        "cal": "savePartition(dbHandle, table, tableName, [compression=true])",
        "params": "`dbHandle` is a DolphinDB database handle. ",
        "exp": "Save a table as a partitioned DFS table. It must be executed by a logged-in user.",
        "eg": "\n    $ n=1000000\n    $ ID=rand(10, n)\n    $ value=rand(1.0, n)\n    $ t=table(ID, value);\n\n    $ db=database(\"dfs://rangedb_Trades\", RANGE,  0 5 10)\n    $ Trades = db.createPartitionedTable(t, \"Trades\", \"ID\");\n    $ savePartition(db, t, `Trades)\n\n    $ Trades=loadTable(db, `Trades)\n    $ select count(value) from Trades;\n    1,000,000\n"
    },
    {
        "title": "saveTable",
        "cal": "saveTable(dbHandle, table, [tableName], [append=false], [compression=false])",
        "params": "`dbHandle` is a DolphinDB database handle.",
        "exp": "Save a table to an unpartitioned disk table. It must be executed by a logged-in user.",
        "eg": "\n    $ db=database(\"C:/DolphinDB/Data/db1\")\n    $ t=table(take(1..10,10000000) as id, rand(10,10000000) as x, rand(10.0,10000000) as y);\n"
    },
    {
        "title": "saveText",
        "cal": "saveText(obj, filename, [delimiter], [append=false], [header=true])",
        "params": "`obj` can be a table/matrix/vector/metacode of SQL statements. When *obj* is the metacode of SQL statements, multiple workers are allocated to read the data concurrently, and the data is written to the file with another worker. In other cases, data queries and writes are handled by the current worker.",
        "exp": "Save DolphinDB variables or data queried by SQL statement as a text file on disk. Compared with :doc:`saveTable`, saveText requires more disk space and time.",
        "eg": "*Example 1*\n"
    },
    {
        "title": "saveTextFile",
        "cal": "saveTextFile(content, filename, [append=false], [lastModified])",
        "params": "`content` is the contents to be written into the file.",
        "exp": "Save strings to a file by appending or overwriting. It must be executed by a logged-in user.",
        "eg": "\n    $ saveTextFile(\"1234567890\\n0987654321\\nabcdefghijk\\n\", \"D:/test/abc.txt\", false, 1495762562671l);\n\n    [content of file \"d:/test/abc.txt\"]\n    1234567890\n    0987654321\n    abcdefghijk\n"
    },
    {
        "title": "scheduleJob",
        "cal": "scheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, [days], [onComplete])",
        "params": "`jobId` a string indicating the job ID.",
        "exp": "Execute a job at specified time and with specified frequency. Return the job ID of the scheduled job. If jobId is different from the job IDs of all the existing scheduled jobs, the system returns jobId. Otherwise, append suffix of the current date, or \"000\", \"001\", ..... or both to jobId until a unique scheduled job ID is found. Please use  :doc:`../g/getRecentJobs` to view the recently finished scheduled jobs. ",
        "eg": "Schedule to run a function:\n"
    },
    {
        "title": "schema",
        "cal": "schema(table|dbHandle)",
        "params": "`X` is a table or a database.",
        "exp": "Display information about the schema of a table or a database.",
        "eg": ""
    },
    {
        "title": "schur",
        "cal": "schur(obj, [sort])",
        "params": "`obj` is a square matrix.",
        "exp": "Compute the Schur decomposition of a square matrix.",
        "eg": ""
    },
    {
        "title": "scs",
        "cal": "scs(f, [P], [A], [b], [Aeq], [beq], [lb], [ub], [x0], [c], [eps], [alpha])",
        "params": "Solve the following optimization problem for the objective function with given constraints:",
        "exp": "Note: Among the following parameters, only *lb* and *ub* can be empty, while all other parameters must not contain NULL values.",
        "eg": "Find x and y that satisfy the following constraints and minimize the objective function x^2 + y^2:\n\n.. image::  ../../../images/scs03.png\n"
    },
    {
        "title": "searchK",
        "cal": "searchK(X, k)",
        "params": "`X` is a vector.",
        "exp": "Return the k-th smallest item ignoring NULL values. ",
        "eg": ""
    },
    {
        "title": "seasonalEsd",
        "cal": "seasonalEsd(data, period, [hybrid], [maxAnomalies], [alpha])",
        "params": "`data`  is a numeric vector.",
        "exp": "Conduct anomaly detection with the Seasoned Extreme Studentized Deviate test (S-ESD).",
        "eg": ""
    },
    {
        "title": "second",
        "cal": "second(X)",
        "params": "`X` is an integer or temporal scalar/vector.",
        "exp": "Return the corresponding second(s).",
        "eg": "\n   $ second 2012.12.03 01:22:01;\n   01:22:01\n\n   $ second(61);\n   00:01:01"
    },
    {
        "title": "secondOfMinute",
        "cal": "secondOfMinute(X)",
        "params": "`X` is a scalar/vector of type TIME, SECOND, DATETIME, TIMESTAMP, NANOTIME or NANOTIMESTAMP.",
        "exp": "For each element in `X`, return a number from 0 to 59 indicating which second of the minute it falls in.  ",
        "eg": "\n   $ secondOfMinute(12:32:00);\n   0\n\n   $ secondOfMinute([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n   [0,0,47,14]\n\n"
    },
    {
        "title": "seek",
        "cal": "seek(handle, offset, [mode])",
        "params": "`handle` must be a file handle.",
        "exp": "Return the final position of the internal cursor if no exception is raised.",
        "eg": "\n   //  write a function to show the length of a file\n   $ def fileLength(f): file(f).seek(0, TAIL) \n   $ fileLength(\"test.txt\");\n   14\n\n   // move the internal cursor to the beginning of the file\n   $ fin=file(\"test.txt\")\n   $ fin.readLine();\n   Hello World!\n\n   $ fin.seek(0, HEAD);\n   0\n\n   $ fin.readLine();\n   Hello World!"
    },
    {
        "title": "segment",
        "cal": "segment(X, [segmentOffset=true])",
        "params": "`X` is a vector.",
        "exp": "divide a vector into groups. Each group is composed of identical values next to each other. For example, [1,1,2,2,1,1,1] is divided into 3 groups: [1,1], [2,2] and [1,1,1].",
        "eg": "Ex 1.\n"
    },
    {
        "title": "segmentby",
        "cal": "segmentby(func, funcArgs, segment)",
        "params": "`func`  is a function.",
        "exp": "``segmentby`` is very similar to :doc:`contextby <contextby>` except for how groups are determined. With ``contextby``, a group includes all elements with the same value. With ``segmentby``, only a block of equal value elements counts as a group. 2 blocks of equal value elements separated by different values are treated as 2 groups.",
        "eg": "\n    $ ret = 0.01 -0.02 0.03 -0.04 0.03 -0.02 0.05 -0.01 0.03 -0.04 0.05 -0.04    \n    $ position = 1 1 1 1 -1 -1 -1 -1 1 1 1 1                        \n    $ t = table(ret, position);\n    $ t;\n"
    },
    {
        "title": "sem",
        "cal": "sem(X)",
        "params": "`X` is a numeric vector.",
        "exp": "Return unbiased (normalized by N-1) standard error of the mean over  `X` .",
        "eg": "\n   $ [1,4,9,10,20,32].sem();\n   4.688046\n\n   $ [1,4,9,10,NULL,20,32].sem();\n   4.688046"
    },
    {
        "title": "semiMonthBegin",
        "cal": "semiMonthBegin(X, [dayOfMonth=15], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first day of the semi-month that `X` belongs to. Suppose `X`  is the d-th day of the month:",
        "eg": "\n   $ semiMonthBegin(2012.06.12);\n   2012.06.01\n\n   $ semiMonthBegin(2012.06.24);\n   2012.06.15\n\n   $ semiMonthBegin(2012.06.15);\n   2012.06.15\n\n   $ semiMonthBegin(2012.06.16, 16);\n   2012.06.16\n\n\n   $ date=2016.04.07+(1..10)*7\n   $ time = take(09:30:00, 10);\n   $ sym = take(`MSFT,10)        \n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n   $ t1;\n"
    },
    {
        "title": "semiMonthEnd",
        "cal": "semiMonthEnd(X, [dayOfMonth=15], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Suppose X is the d-th day of the month:",
        "eg": "\n    $ semiMonthEnd(2012.06.12);\n    2012.05.31\n\n    $ semiMonthEnd(2012.06.24);\n    2012.06.15\n\n    $ semiMonthEnd(2012.06.15);\n    2012.06.15\n\n    $ semiMonthEnd(2012.06.16, 16);\n    2012.06.16\n\n\n   $ date=2016.04.07+(1..10)*7\n   $ time = take(09:30:00, 10);\n   $ sym = take(`MSFT,10)        \n   $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n   $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n   $ t1 = table(date, time, sym, qty, price);\n   $ t1;\n"
    },
    {
        "title": "seq",
        "cal": "seq(start, end) or start..end",
        "params": "`start` and `end` must be integers.",
        "exp": "Return a sequence with start at beginning and end in the end. The step between two consecutive items is 1.",
        "eg": ""
    },
    {
        "title": "set",
        "cal": "set(X)",
        "params": "`X` is a vector",
        "exp": "Return the corresponding set object of vector  `X` .",
        "eg": "Function `set` returns a set  \n"
    },
    {
        "title": "setAtomicLevel",
        "cal": "setAtomicLevel(dbHandle, atomic)",
        "params": "`dbHandle`  is a distributed database handle returned by function :doc:`/FunctionsandCommands/FunctionReferences/d/database`.",
        "exp": "To manually specify at which level concurrent writes are allowed in a distributed database.",
        "eg": ""
    },
    {
        "title": "setColumnComment",
        "cal": "setColumnComment(table, columnComments)",
        "params": "`table` is a DFS table or MVCC table.",
        "exp": "Add comments to columns of a DFS table or an MVCC table. Use function :doc:`../../FunctionReferences/s/schema` to view column comments.",
        "eg": "\n    $ n=1000000\n    $ sym=rand(`A`B`C`D`E`F,n)\n    $ date=rand(2019.06.01..2019.06.10,n)\n    $ open=rand(100.0,n)\n    $ high=rand(200.0,n)\n    $ close=rand(200.0,n)\n    $ pre_close=rand(200.0,n)\n    $ change=rand(100.0,n)\n    $ vol=rand(10000,n)\n    $ amount=rand(100000.0,n)\n    $ t=table(sym,date,open,high,close,pre_close,change,vol,amount);\n\n    $ db1=database(\"\",VALUE,2019.06.01..2019.06.10)\n    $ db2=database(\"\",VALUE,`A`B`C`D`E`F)\n    $ db=database(\"dfs://db1\",COMPO,[db1,db2])\n    $ pt=db.createPartitionedTable(t,`pt,`date`sym).append!(t);\n\n    $ setColumnComment(pt,{sym:\"stock ticker\", date:\"trading date\", open:\"open price\", high:\"highest price\", low:\"lowest price\", close:\"close price\", vol:\"trading volume (shares)\", amount:\"trading volume (dollar)\"})\n    $ schema(pt).colDefs;\n\n"
    },
    {
        "title": "setIndexedMatrix!",
        "cal": "setIndexedMatrix!(X, [on=true])",
        "params": "`X`  is a matrix with row labels and column labels. Row labels and column labels must be monotonically increasing with no duplicate values.",
        "exp": "Set the labels of the rows and columns of a matrix as the indexes.",
        "eg": "\n    $ m=matrix(1..5, 11..15)\n    $ m.rename!(2020.01.01..2020.01.05, `A`B)\n    $ m.setIndexedMatrix!();\n"
    },
    {
        "title": "setIndexedSeries!",
        "cal": "setIndexedSeries!(X, [on=true])",
        "params": "`X` is a matrix with row labels and only one column. The row labels must be monotonically increasing with no duplicate values.",
        "exp": "Convert a single column matrix with row labels into an indexed series.",
        "eg": "\n    $ s = matrix(1..10).rename!(2012.01.01..2012.01.10, ).setIndexedSeries!();\n\n    $ s;\n"
    },
    {
        "title": "setLogLevel",
        "cal": "setLogLevel(logLevel)",
        "params": "`logLevel` the log level. The optional values from low to high are: DEBUG, INFO, WARNING, and ERROR.",
        "exp": "Set the log level on the current node online. After setting the log level, only logs at and above the specified *logLevel* are printed.",
        "eg": ""
    },
    {
        "title": "setMaxBlockSizeForReservedMemory",
        "cal": "setMaxBlockSizeForReservedMemory(blockSizeKB)",
        "params": "`blockSizeKB` is a positive integer or floating-point number (in KB).",
        "exp": "Modify the maximum reserved memory allocated to a DolphinDB block online. This command can only be executed by the admin on the data node.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "setMaxJobParallelism",
        "cal": "setMaxJobParallelism(userId, maxParallelism)",
        "params": "`userId` is a string indicating a user name. ",
        "exp": "Specify the maximum number of subjobs that can be concurrently executed for the jobs submitted by the user. It must be executed by a logged-in user.",
        "eg": "\n    $ login(`admin,`123456)\n    $ createUser(`ElonMusk, `superman)\n    $ setMaxJobParallelism(`ElonMusk, 64);\n"
    },
    {
        "title": "setMaxJobPriority",
        "cal": "setMaxJobPriority(userId, maxPriority)",
        "params": "`userId` is a string indicating a user name.",
        "exp": "Specify the highest priority of the jobs submitted by the user. It must be executed by a logged-in user.",
        "eg": "\n    $ login(`admin,`123456)\n    $ createUser(`KyleMurray, `Cardinals2020QB)\n    $ setMaxJobPriority(`KyleMurray, 7);\n"
    },
    {
        "title": "setMaxMemSize",
        "cal": "setMaxMemSize(memSizeGB)",
        "params": "`memSizeGB` is a numeric scalar (in GB). It is greater than 0 but no greater than *maxMemoryPerNode* (specified by DolphinDB license), which can be checked with function ``license``. Otherwise an error will be raised.",
        "exp": "Modify the maximum memory (in GB) allocated to DolphinDB online. This command can only be executed by the administrator. Call ``getClusterPerf().maxMemSize`` to check if the modification has taken effect.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "setMemLimitOfQueryResult",
        "cal": "setMemLimitOfQueryResult(memLimit)",
        "params": "`memLimit` is a numeric scalar, indicating the memory limit (in GB). It must be smaller than smaller than 80% * maxMemSize.",
        "exp": "Set the memory limit for the result of each query online. This command can only be executed by an administrator on a data node or compute node.",
        "eg": ""
    },
    {
        "title": "setMemLimitOfTaskGroupResult",
        "cal": "setMemLimitOfTaskGroupResult(memLimit)",
        "params": "`memLimit` is a numeric scalar, indicating the memory limit (in GB).",
        "exp": "Set the memory limit of a task group sent from the current node online. This command can only be executed by an administrator on a data node or compute node.",
        "eg": ""
    },
    {
        "title": "setMemLimitOfTempResult",
        "cal": "setMemLimitOfTempResult(X)",
        "params": "`X` is a positive number that is no greater than *maxMemSize*.",
        "exp": "Modifies the upper limit of memory usage (in GB) for each temporary result generated during a table join operation. It can only be executed by an administrator on a data node or compute node.",
        "eg": ""
    },
    {
        "title": "setOLAPCacheEngineSize",
        "cal": "setOLAPCacheEngineSize(memSize)",
        "params": "`memSize` is a numeric scalar (in GB). It must be greater than 0 and less than *maxMemSize* * 0.75",
        "exp": "Modify the capacity of the OLAP cache engine online. In a cluster, this command can only be executed by the admin on a data node or compute node. Please make sure the cache engine is enabled by specifying configuration parameter *chunkCacheEngineMemSize* before execution.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "setRaftElectionTick",
        "cal": "setRaftElectionTick(groupId, tickCount) ",
        "params": "`groupId` is a positive integer indicating the raft group ID. Currently it can only be 1, referring to the ID of the raft group composed of controllers.",
        "exp": "Use this command to dynamically set the configuration parameter *raftElectionTick*. *tickCount* specifies a time interval: [tickCount, 2*tickCount]. After receiving the last heartbeat from the leader, if a follower does not receive the next heartbeat after a random waiting time within the specified interval, it will send a request for leader election. ",
        "eg": "\\1.The command must be executed by the admin on all controllers within a raft group, please make sure that they all share the same *raftElectionTick* value.\n\n\\2.The command will not modify the configuration parameter *raftElectionTick*. It will restore to the default or specified value after the server restarts. "
    },
    {
        "title": "setRandomSeed",
        "cal": "setRandomSeed(seed)",
        "params": "`seed` is an integer indicating the random seed.",
        "exp": "Set the random seed. ",
        "eg": "\n    $ setRandomSeed(5);\n    $ rand(10, 10);\n    [2,0,8,8,2,3,9,9,4,0]\n"
    },
    {
        "title": "setReservedMemSize",
        "cal": "setReservedMemSize(memSizeGB)",
        "params": "`memSizeGB` is a numeric scalar (in GB). It is greater than 0 and less than *maxMemSize* * 0.5",
        "exp": "Modify the reserved memory allocated to DolphinDB online. This command can only be executed by the admin.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "setRetentionPolicy",
        "cal": "setRetentionPolicy(dbHandle, retentionHours, [retentionDimension], [hoursToColdVolume])",
        "params": "`dbHandle` is a database handle. The data type of at least one of the partitioning columns of the database must be DATE or DATEHOUR. ",
        "exp": "Set the policy of data retention and tiered storage. The parameter retentionHours should be specified as large as possible for tiered storage to avoid deleting any data.",
        "eg": "\n    $ db=database(\"dfs://db1\",VALUE,2019.06.01..date(now()))\n    $ retentionHour=9*24\n    $ hoursToColdVolume=1*24\n    $ setRetentionPolicy(db,retentionHour,0, hoursToColdVolume);\n\n    $ schema(db);\n    partitionSchema->[2022.05.05,2022.05.04,2022.05.03,2022.05.02,2022.05.01,2022.04.30,2022.04.29,2022.04.28,2022.04.27,2022.04.26,...]\n    partitionSites->\n    partitionTypeName->VALUE\n    hoursToColdVolume->24\n    atomic->TRANS\n    databaseDir->dfs://db1\n    engineType->OLAP\n    chunkGranularity->TABLE\n    retentionDimension->0\n    partitionType->1\n    retentionHours->216\n"
    },
    {
        "title": "setStreamTableFilterColumn",
        "cal": "setStreamTableFilterColumn(streamTable, columnName)",
        "params": "`streamTable` is a stream table object.",
        "exp": "Specify the filtering column of a stream table. It is related to parameter filter in function :doc:`../../FunctionReferences/s/subscribeTable` The value of parameter `filter` is a vector. Only the rows with values of the filtering column in `filter` are published to the subscriber. A stream table can have only one filtering column. ",
        "eg": ".. tradessymboltrades_slavetradesfilter[\"IBM\", \"GOOG\"]tradessymbol\"IBM\"\"GOOG\"\n\n\nIn the following example, the filter column of the stream table \"trades\" is \"symbol\". The table \"trades_slave\" on the same node subscribes to \"trades\" and the filter is set to [\"IBM\", \"GOOG\"]. Only when the column \"symbol\" is \"IBM\" or \"GOOG\", the corresponding data will be published.\n"
    },
    {
        "title": "setSystem",
        "cal": "setSystem(paramName, paramValue)",
        "params": "`paramName` is a string indicating the parameter name.",
        "exp": "Set the following system-wide parameters:",
        "eg": "\n    $ setSystem(\"rows\", 30);\n    $ setSystem(\"width\", 200);\n"
    },
    {
        "title": "setTSDBCacheEngineSize",
        "cal": "`memSize` is a numeric scalar (in GB). It is greater than 0  and less than *maxMemSize* * 0.75.",
        "params": "Modify the capacity of the TSDB cache engine online. In a cluster, this command can only be executed by the admin on the data node or compute node. Please make sure the cache engine is enabled by specifying configuration parameter *TSDBCacheEngineSize* before execution. You can obtain the real-time status of the TSDB cache engine with function ``getTSDBCacheEngineSize`` to check if the modification takes effect online.",
        "exp": "2.00.4",
        "eg": ""
    },
    {
        "title": "setTimeoutTick",
        "cal": "setTimeoutTick(tick)",
        "params": "`tick` is a positive integer (in seconds) that indicates the timeout period.",
        "exp": "Dynamically modify the timeout period for the controller to receive a data node's heartbeat. If the heartbeat is not received within the specified period, the node is considered as offline. This command can only be executed by the admin on the controller. For a high availability cluster, it must be executed on all controllers within the raft group.",
        "eg": "1.30.16/2.00.4"
    },
    {
        "title": "shape",
        "cal": "shape(X)",
        "params": "`X`  is a scalar/vector/matrix/table.",
        "exp": "Return the dimension of a scalar/vector/matrix as a PAIR.",
        "eg": "Dimension of a scalar is 1 by 1:\n"
    },
    {
        "title": "shapiroTest",
        "cal": "shapiroTest(X)",
        "params": "`X` is a numeric vector indicating the sample for the test.",
        "exp": "Conduct a Shapiro-Wilk test on `X`. Return a dictionary with the following keys:",
        "eg": "\n    $ x = norm(0.0, 1.0, 50)\n    $ shapiroTest(x);\n\n    method->Shapiro-Wilk normality test\n    pValue->0.621668\n    W->0.981612"
    },
    {
        "title": "share",
        "cal": "share(table, sharedName, [database], [dbName], [partitionColumn], [readonly=false])",
        "params": "`table` the table or engine to be shared across all sessions.",
        "exp": "If only `table` and `sharedName` are specified:",
        "eg": "\n    $ share(t, `sharedT);\n    $ share(t, `quotes, tickDB, `tickDB, `date);\n"
    },
    {
        "title": "shell",
        "cal": "shell(cmd)",
        "params": "`cmd` is a string indicating an operating system command.",
        "exp": "Execute an operating system command. Only system administrators can execute it.",
        "eg": "\n    $ cmd=\"rm -rf /home/user1/test.txt\"\n    $ shell(cmd);"
    },
    {
        "title": "short",
        "cal": "short(X)",
        "params": "`x` can be of any data type.",
        "exp": "Convert the input to the data type of SHORT.",
        "eg": "\n    $ x=short();        \n    $ x;              \n    00h                \n    \n    $ typestr x;      \n    SHORT              \n\n    $ short(`12.3);\n    12\n\n    $ short(`120.9c);\n    120\n\n    $ short(32767);\n    32767\n\n    $ short(32768);        \n    00h\n    // maximum value for a SHORT is 2^15-1=32767"
    },
    {
        "title": "shuffle",
        "cal": "shuffle(X)",
        "params": "`x` is a vector/matrix.",
        "exp": "Return a new vector/matrix after taking a shuffle on the data.",
        "eg": "\n    $ x=(1..6).shuffle();        \n    $ x;\n    [1,6,3,5,4,2]\n    \n    $ x.shuffle!();\n    [5,4,1,3,2,6]\n\n\n    $ x=(1..6).reshape(3:2);\n    $ x;\n"
    },
    {
        "title": "shuffle!",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "signum",
        "cal": "signum(X)",
        "params": "`x` is a scalar/vector/matrix of numeric or Boolean value.",
        "exp": "Return 1 if `X`  is positive; 0 if  `X`  is 0; -1 if  `X`  is negative; Null if  `X`  is Null.",
        "eg": "\n\n    $ signum 1 0 -1 NULL;\n    [1,0,-1, ]"
    },
    {
        "title": "sin",
        "cal": "sin(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The sine function.",
        "eg": "\n   $ sin(1 2 3);\n   [0.841471,0.909297,0.141120]\n"
    },
    {
        "title": "sinh",
        "cal": "sinh(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The hyperbolic sine function.",
        "eg": "\n   $ sinh 1 2 3;\n   [1.175201,3.62686,10.017875]"
    },
    {
        "title": "size",
        "cal": "size(X)",
        "params": "`X` is a scalar/vector/matrix/table.",
        "exp": "For a vector/matrix, `size` returns the number of elements. In comparison, count returns the number of non-null elements.",
        "eg": "\n   $ size(3 NULL 5 6);\n   4\n   $ count(3 NULL 5 6);\n   3\n\n   $ m=1 2 3 NULL 4 5$2:3;\n   $ m;\n\n"
    },
    {
        "title": "skew",
        "cal": "skew(X, [biased=true])",
        "params": "`X` is a vector/matrix.",
        "exp": "Return the skewness of  `X`. The calculation skips NULL values.",
        "eg": "Please note that as the example below uses a random number generator, the result is slightly different each time it is executed.\n"
    },
    {
        "title": "sleep",
        "cal": "sleep(X)",
        "params": "`X` is a nonnegative scalar. ",
        "exp": "Pause the application for `X` milliseconds. ",
        "eg": "\n   $ for(s in 1:10){\n   $    sleep(1000)\n   $    print(s+\" seconds passed.\")\n   $ };\n\n   1 seconds passed.\n   2 seconds passed.\n   3 seconds passed.\n   4 seconds passed.\n   5 seconds passed.\n   6 seconds passed.\n   7 seconds passed.\n   8 seconds passed.\n   9 seconds passed."
    },
    {
        "title": "sliceByKey",
        "cal": "sliceByKey(table, rowKeys, [colNames])",
        "params": "`table` is a keyed table or indexed table.",
        "exp": "Get the rows containing the specified values of the key columns from a keyed table or an indexed table. It is faster than the corresponding SQL statement. ",
        "eg": "\n    $ t = indexedTable(`sym`side, 10000:0, `sym`side`price`qty, [SYMBOL,CHAR,DOUBLE,INT])\n    $ insert into t values(`IBM`MSFT`IBM, ['B','S','S'], 125.27 208.9 125.29, 1000 800 200)\n    $ a=sliceByKey(t,\"IBM\", 'price');\n\n    $ a;\n    [125.27,125.29]\n\n    $ typestr(a);\n    FAST DOUBLE VECTOR\n\n    $ a=sliceByKey(t,(\"IBM\",'S'));\n    $ a;\n"
    },
    {
        "title": "sma",
        "cal": "sma(X, window)",
        "params": "Calculate the Simple Moving Average (sma) for *X* in a sliding window of the given length.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "solve",
        "cal": "solve(X, Y)",
        "params": "`X` is a square matrix;  ",
        "exp": "It generates the vector b that solves X*b=Y.",
        "eg": "\n    $ m=1..4$2:2;\n    $ m;\n"
    },
    {
        "title": "sort",
        "cal": "sort(X, [ascending=true])",
        "params": "`X`  is a vector.",
        "exp": "Return a sorted vector in ascending/descending order.",
        "eg": "\n    $ x=9 1 5;   \n    $ x; \n    [9,1,5]\n    \n    $ y=sort(x);              \n    $ y;                   \n    [1,5,9]            \n    \n    $ sort(x, false);\n    [9,5,1]    \n\n    $ x=1 4 2 5 6 3$2:3;\n    $ x;\n"
    },
    {
        "title": "sort!",
        "cal": "sort!(X, [ascending=true])",
        "params": "`X` is a vector.",
        "exp": "Sort `X` in-place in ascending/descending order.",
        "eg": "\n    $ x=9 1 5;\n    $ sort!(x);\n    $ x;              \n    [1 5 9]\n\n    $ x.sort!(0);\n    $ x;\n    [9,5,1]"
    },
    {
        "title": "sortBy!",
        "cal": "sortBy!(table, sortColumns, [sortDirections])",
        "params": "`table` is a table object. It can be a partitioned or unpartitioned in-memory table.",
        "exp": "Sort a table in-place based on the specified columns and directions. If the table is a partitioned table, the sorting is conducted within each partition, not on the entire table.",
        "eg": "Sort an unpartitioned table:\n"
    },
    {
        "title": "spearmanr",
        "cal": "spearmanr(X, Y)",
        "params": "`X` is a vector/ matrix.",
        "exp": "Calculate the Spearman rank correlation coefficient of `X` and `Y`. Null values are ignored in the calculation. Spearman correlation is a non-parametric measure of the monotonicity of the relationship between two data sets. The coefficient varies between -1 and +1, where 0 means no correlation. -1 or +1 means an exact monotonic relationship. ",
        "eg": "\n    $ x=[2013.06.13, 2013.06.14, 2013.06.15]\n    $ y=1 5 3\n    $ spearmanr(x, y)\n    0.5\n\n    $ x = [33,21,46,-11,78,47,18,20,-5,66]\n    $ y = [1,NULL,10,6,10,3,NULL,NULL,5,3]\n    $ spearmanr(x, y)\n    0.109109\n"
    },
    {
        "title": "spline",
        "cal": "spline(X, Y, resampleRule, [closed='left'], [origin='start_day'], [outputX=false])",
        "params": "`X` is a strictly increasing vector of temporal type.",
        "exp": "Resample *X* based on the specified *resampleRule*, *closed* and *origin*. Perform cubic spline interpolation on *Y* based on the resampled *X*.",
        "eg": "\n    $ spline([2016.02.14 00:00:00, 2016.02.15 00:00:00, 2016.02.16 00:00:00], [1.0, 2.0, 4.0], resampleRule=`60min);\n\n    [1,1.0313,1.0626,1.0942,1.1262,1.1585,1.1914,1.225,1.2593,1.2944,1.3306,1.3678,1.4062,1.446,1.4871,1.5298,1.5741,1.6201,1.668,1.7178\n    ,1.7697,1.8237,1.8801,1.9388,2,2.0638,2.1301,2.1987,2.2697,2.3428,2.418,2.4951,2.5741,2.6548,2.7371,2.821,2.9062,2.9928,3.0806,3.1694\n    ,3.2593,3.35,3.4414,3.5335,3.6262,3.7192,3.8126,3.9063,4]"
    },
    {
        "title": "split",
        "cal": "split(str, [delimiter])",
        "params": "`str` is a STRING scalar or vector.",
        "exp": "* *str* is a scalar:",
        "eg": "\n    $ split(\"xyz 1\");\n    ['x','y','z',' ','1']\n\n    $ split(\"xyz 1\",\" \");\n    [\"xyz\",\"1\"]\n\n    $ split(`xyz1,`xyz);\n    [,\"1\"]\n\n    $ split(`xyz1,`xyz)[1];\n    1\n\n    $ a = split(\"20220101 09:00:00\" \"20220101 09:12:20\" \"20220101 10:00:00\", \" \")\n    ([\"20220101\",\"09:00:00\"],[\"20220101\",\"09:12:20\"],[\"20220101\",\"10:00:00\"])\n\n    // access by column\n    $ a[0];\n    [\"20220101\",\"20220101\",\"20220101\"]\n\n    $ a[1];\n    [\"09:00:00\",\"09:12:20\",\"10:00:00\"]\n\n    //access by row\n    $ a.row(0)\n    [\"20220101\",\"09:00:00\"]"
    },
    {
        "title": "sql",
        "cal": "sql(select, from, [where], [groupBy], [groupFlag], [csort], [ascSort], [having], [orderBy], [ascOrder], [limit], [hint], [exec=false])",
        "params": "`select` metacode indicating the columns to be selected. Each column is generated by either function :doc:`sqlCol` or  :doc:`sqlColAlias` . Use a tuple to select multiple columns.",
        "exp": "Create a SQL statement dynamically. To execute the generated SQL statement, use function  :doc:`../e/eval`.",
        "eg": "\n    $ symbol = take(`GE,6) join take(`MSFT,6) join take(`F,6)\n    $ date=take(take(2017.01.03,2) join take(2017.01.04,4), 18)\n    $ price=31.82 31.69 31.92 31.8  31.75 31.76 63.12 62.58 63.12 62.77 61.86 62.3 12.46 12.59 13.24 13.41 13.36 13.17\n    $ volume=2300 3500 3700 2100 1200 4600 1800 3800 6400 4200 2300 6800 4200 5600 8900 2300 6300 9600\n    $ t1 = table(symbol, date, price, volume);\n    \n    $ t1;\n"
    },
    {
        "title": "sqlCol",
        "cal": "sqlCol(colName, [func], [alias], [qualifier])",
        "params": "`colName` is a string scalar/vector indicating column name(s).",
        "exp": "Generate metacode for selecting one or multiple columns with or without calculations. It is generally used together with function :doc:`sql` and :doc:`../e/eval` to generate SQL statements dynamically.",
        "eg": "\n    $ t = table(`GME`AMC`KOSS as symbol, 325 13.26 64 as price);\n    $ colName=\"symbol\";\n    $ sql(select=sqlCol(colName), from=t).eval();\n"
    },
    {
        "title": "sqlColAlias",
        "cal": "sqlColAlias(colDefs, [colNames])",
        "params": "`colDefs` is metacode.",
        "exp": "Use metacode and an optional alias name to define a column. It is often used to name calculated columns.",
        "eg": "\n    $ sqlColAlias(<x>, `y);\n    < x as y >\n\n    $ sqlColAlias(<avg(PRC)>, `avgPRC);\n    < avg(PRC) as avgPRC >\n\n    $ sqlColAlias(<avg(PRC)>);\n    < avg(PRC) as avg_PRC >\n"
    },
    {
        "title": "sqlDS",
        "cal": "sqlDS(sqlObj, [forcePartition=false])",
        "params": "`sqlObj`  is SQL metacode. For more details about metacode please refer to the section of  :doc:`/Objects/Metaprogramming`.",
        "exp": "Create a list of data sources based on the input SQL metacode. If the table in the SQL metacode has n partitions, `sqlDS` generates n data sources. If the SQL metacode doesn't contain any partitioned table, `sqlDS`  returns a tuple containing one data source.",
        "eg": "\n    $ n=1000000\n    $ date=take(2019.01.01..2019.01.03,n)\n    $ sym = take(`C`MS`MS`MS`IBM`IBM`IBM`C`C$SYMBOL,n)                \n    $ price= take(49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29,n)\n    $ qty = take(2200 1900 2100 3200 6800 5400 1300 2500 8800,n)\n    $ t=table(date, sym, price, qty)\n\n    $ db1=database(\"\",VALUE,2019.01.01..2019.01.03)\n    $ db2=database(\"\",VALUE,`C`MS`IBM)\n    $ db=database(\"dfs://stock\",COMPO,[db1,db2])\n    $ trades=db.createPartitionedTable(t,`trades,`date`sym).append!(t)\n\n    $ ds=sqlDS(<select * from trades where date=2019.01.02>);\n    \n    $ typestr ds;\n    ANY VECTOR\n\n    $ size ds;\n    3\n\n    $ ds[0];\n    DataSource< select [7] * from trades [partition = /stock/20190102/C] >\n\n    $ ds[1];\n    DataSource< select [7] * from trades [partition = /stock/20190102/IBM] >\n\n    $ ds[2];\n    DataSource< select [7] * from trades [partition = /stock/20190102/MS] >"
    },
    {
        "title": "sqlDelete",
        "cal": "sqlDelete(table, [where])",
        "params": "`table` can be an in-memory table or a distributed table.",
        "exp": "Dynamically generate a metacode of the SQL delete statement. To execute the generated metacode, please use function :doc:`/FunctionsandCommands/FunctionReferences/e/eval`.",
        "eg": "Example 1. Delete the records in an in-memory table\n"
    },
    {
        "title": "sqlUpdate",
        "cal": "sqlUpdate(table, updates, [from], [where], [contextBy])",
        "params": "Each parameter refers to the corresponding part of the SQL update statement:",
        "exp": "Dynamically generate a metacode of the SQL update statement. To execute the generated metacode, please use function :doc:`/FunctionsandCommands/FunctionReferences/e/eval`.",
        "eg": "Example 1. Update the records in an in-memory table\n"
    },
    {
        "title": "sqrt",
        "cal": "sqrt(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the square root of each element in `X`. The data type of the result is always DOUBLE.",
        "eg": "\n    $ sqrt(4 16 -4 NULL);\n    [2,4, , ]\n\n    $ typestr(sqrt(4));\n    DOUBLE"
    },
    {
        "title": "square",
        "cal": "square(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "Return the square of `X`. The data type of the result is always DOUBLE.",
        "eg": "\n    $ square(3);\n    9\n\n    $ square(2 4 NULL 6);\n    [4,16,,36]\n\n    $ square(1..4$2:2);\n"
    },
    {
        "title": "startDataNode",
        "cal": "startDataNode(X)",
        "params": "`X` is a vector, which contains information about the data nodes to be started.",
        "exp": "Start data nodes on a cluster controller. ",
        "eg": "\n    $ x = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\n    $ startDataNode(x);\n"
    },
    {
        "title": "startsWith",
        "cal": "startsWith(X, str)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Check if `X` starts with str. If yes, return true; otherwise return false.",
        "eg": "\n    $ startsWith('ABCDEF!', \"ABC\");\n    1\n\n    $ startsWith('ABCDEF!', \"ABD\");\n    0"
    },
    {
        "title": "stat",
        "cal": "stat(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "Return a dictionary about the descriptive statistics of X including avg(mean), max, min, count, median, and stdev.",
        "eg": "\n    $ x=5 7 4 3 2 1 7 8 9 NULL;\n\n    $ stat(x);\n    Median->5\n    Avg->5.111111\n    Min->1\n    Stdev->2.803767\n    Count->9\n    Size->10\n    Name->x\n    Max->9\n\n    $ stats = stat(x);\n    $ stats[`Avg];\n    5.111111"
    },
    {
        "title": "stateIterate",
        "cal": "stateIterate(X, initial, initialWindow, iterateFunc, combineCoeff)",
        "params": "`X` is a vector. It can be a column from the engine's input table, or the result of a vectorized function with the column as its input argument. ",
        "exp": "- As the iterations are performed based on the historical data, the output for the current record is calculated based on the historical results in the output table and X.",
        "eg": "Supposing the iteration is based only on the previous result, for the k-th (k  N+) record, the calculation logic is (where the column factor holds the results):\n\n- k < initialWindow: factor[k] = initial[k]\n- k >= initialWindow:factor[k] = combineCoeff[0] * X[k] + combineCoeff[1] * iterateFunc(factor)[k-1]\n\nNote: If *iterateFunc* is a window function, the iteration is based on multiple previous results."
    },
    {
        "title": "std",
        "cal": "std(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If `X` is a vector, return the the (unbiased) sample standard deviation of `X`.",
        "eg": "\n    $ std(1 2 3);\n    1\n\n    $ m=matrix(1 3 5 7 9, 1 4 7 10 13);\n    $ m;\n"
    },
    {
        "title": "stdp",
        "cal": "stdp(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "If `X` is a vector, return the population standard deviation of `X`.",
        "eg": "\n    $ stdp(1 2 3);\n    0.816497\n\n    $ m=matrix(1 3 5 7 9, 1 4 7 10 13);\n    $ m;\n"
    },
    {
        "title": "stl",
        "cal": "stl(data, period, sWindow, [sDegree], [sJump], [tWindow], [tDegree], [tJump], [lWindow], [lDegree], [lJump], [robust], [inner], [outer])",
        "params": "`data` is a numeric vector.",
        "exp": "Use Loess method to decompose a time series into trend, seasonality and randomness. The result is a dictionary with the following keys: trend, seasonal, and residual. Each key corresponds to a vector with the same length as data.",
        "eg": "\n    $ n = 100\n    $ trend = 6 * sin(1..n \\ 200)\n    $ seasonal = sin(pi / 6 * 1..n)\n    $ residual = rand(1.0, n) - 0.5\n    $ data = trend + seasonal + residual\n    $ res = stl(data, 12, \"periodic\");\n\n    $ plot([trend, res.trend]);\n"
    },
    {
        "title": "stopDataNode",
        "cal": "stopDataNode(X)",
        "params": "`X` is a vector, which contains information about the data nodes to be stopped.",
        "exp": "Stop data nodes on a cluster controller.",
        "eg": "\n    $ x = [\"192.168.1.27:8506\",\"192.168.1.27:8502\",\"192.168.1.27:8527\"]\n    $ stopDataNode(x);"
    },
    {
        "title": "strReplace",
        "cal": "strReplace(str, pattern, replacement)",
        "params": "`str` is a string scalar/vector.",
        "exp": "Return a copy of str and replace all occurrences of pattern with replacement.",
        "eg": "\n\n    $ strReplace(\"The ball is red.\", \"red\", \"green\");\n    The ball is green.\n\n    $ strReplace([\"The ball is red.\", \"The car is red too.\"], \"red\", \"yellow\");\n    [\"The ball is yellow.\",\"The car is yellow too.\"]"
    },
    {
        "title": "streamFilter",
        "cal": "Create an engine that splits the ingested stream for different handlers. Return a table object.",
        "params": "streamFilter(name, dummyTable, filter, [msgSchema], [timeColumn], [conditionColumn])",
        "exp": "`name` is a STRING scalar indicating the name of the stream filter engine. It must begin with a letter and may contain letters, numbers and underscores.",
        "eg": "\\(1) Processing a heterogeneous stream table:\n\nReplay the DFS tables \"orders\" and \"trades\" to simulate an asof join of the two streams. \n\nIf we simply perform an N-to-N replay on the two tables, it is not guaranteed that the records will be ingested to the left and right tables of the asof join engine in chronological order: It may happen that a record with a larger timestamp arrives in the left table before a record with a smaller timestamp arrives in the right table. For more information, see :doc:`../r/replay`.\n\nTherefore, we replay the two tables into one heterogeneous stream table to make sure all records are ordered by timestamp. The stream filter subscribes to the heterogenous stream table, splits the ingested data into two streams and distributes them to the left and right tables of the asof join engine (:doc:`../c/createAsofJoinEngine`). In this way, we can make sure that the data is ingested to the left and right tables of the asof join engine in the order of the timestamps.\n"
    },
    {
        "title": "streamTable",
        "cal": "streamTable(X, [X1], [X2], .....) ",
        "params": "For the first usage, X, X1, X2, .... are vectors.",
        "exp": "Create a table in real-time mode to be used in streaming (also called a stream table). A table in real-time mode can handle concurrent reading and writing.",
        "eg": "\n    $ id=`XOM`GS`AAPL\n    $ x=102.1 33.4 73.6\n    $ rt = streamTable(id, x);\n    $ rt=streamTable(`XOM`GS`AAPL as id, 102.1 33.4 73.6 as x);\n    $ colName=[\"Name\",\"Age\"]\n    $ colType=[\"string\",\"int\"]\n    $ rt = streamTable(100:10, colName, colType);"
    },
    {
        "title": "stretch",
        "cal": "stretch(X, n)",
        "params": "`X` is a vector/tuple/matrix/table.",
        "exp": "- If *X* is a vector or tuple, stretches *X* evenly to a new vector or tuple with the length of *n*.",
        "eg": "\n    $ X = 1 NULL 2 3\n    $ print stretch(X, 11)\n    [1,1,1,,,,2,2,3,3]\n\n    $ print stretch(X, 11)\n    [1,1,1,,,,2,2,2,3,3]\n\n    $ print stretch(X, 12)\n    [1,1,1,,,,2,2,2,3,3,3]\n\n    $ print take(X, 10)\n    [1,,2,3,1,,2,3,1,]\n\n    $ Y=array(INT[], 0, 10).append!([1 NULL 3, 4 5, 6 NULL 8, 9 10]);\n    $ print stretch(Y,7)\n    [[1,,3],[1,,3],[4,5],[4,5],[6,,8],[6,,8],[9,10]]\n    \n    $ s=[1 2 3, 4 5 6]\n    $ stretch(s, 5)\n    ([1,2,3],[1,2,3],[1,2,3],[4,5,6],[4,5,6])\n\n    $ m=matrix(1 2 3, 4 5 6)\n    $ stretch(m,5)\n    col1\tcol2\n    1\t4\n    1\t4\n    2\t5\n    2\t5\n    3\t6\n\n    $ t=table(1 2 3 as a, 4 5 6 as b)\n    $ stretch(t,5)\n    a\tb\n    1\t4\n    1\t4\n    2\t5\n    2\t5\n    3\t6"
    },
    {
        "title": "string",
        "cal": "string(X)",
        "params": "`X` can be of any data type.",
        "exp": "Convert X to a string.",
        "eg": "\n    $ string()==\"\";\n    1            \n    $ string(10);\n    10            \n\n    $ typestr string(108.5);\n    STRING\n\n    $ string(now());\n    2016.03.02T20:55:31.287"
    },
    {
        "title": "strip",
        "cal": "strip(X)",
        "params": "`X` is a literal scalar/vector.",
        "exp": "Remove all space, tab, new line, and carriage characters in both head and tail of a string.",
        "eg": "\n\n    $ x=\"\\nhello world\\t\\n\";    \n    $ x;                        \n\n    hello world                \n\n    $ strip x;\n    hello world\n"
    },
    {
        "title": "strlen",
        "cal": "strlen(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Return the length of each string in X.",
        "eg": "\n    $ strlen(`XOM);\n    3\n\n    $ strlen(`XOM`MSFT`F`GM);\n    [3,4,1,2]\n\n    $ strlen(\"Hello World!\");\n    12\n\n"
    },
    {
        "title": "strlenu",
        "cal": "strlenu(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Get the length of a string encoded by Unicode.",
        "eg": "\n    $ strlenu(\"database\")\n    8\n\n    $ strlenu([\"database\",\"DolphinDB\"])\n    [8,9]"
    },
    {
        "title": "strpos",
        "cal": "strpos(X, str)",
        "params": "`X` is a string scalar/vector.",
        "exp": "If `X` contains str, return the index in `X` where the first occurrence of str starts; otherwise, return -1.",
        "eg": "\n    $ strpos(\"abcdefg\",\"cd\");\n    2\n\n    $ strpos(\"abcdefg\",\"d\");\n    3\n\n    $ strpos(\"abcdefg\",\"ah\");\n    -1"
    },
    {
        "title": "sub",
        "cal": "sub(X, Y) or X-Y",
        "params": "X/Y is a scalar/pair/vector/matrix/set. If one of `X` and `Y` is a pair/vector/matrix, the other is a scalar or a pair/vector/matrix of the same size.",
        "exp": "Return the result of element-by-element subtracting Y from X. If both X and Y are sets, sub returns a set by eliminating the common elements of X and Y from X.",
        "eg": "\n    $ 4:5-2;\n    2 : 3\n\n    $ 4:5-1:2;\n    3 : 3\n\n    $ x=1 2 3;\n    $ x-1;\n    [0,1,2]\n\n    $ 1 sub x;\n    [0,-1,-2]\n\n    $ y=4 5 6;        \n    $ sub(x,y);        \n    [-3,-3,-3]\n\n    $ m1=1..6$2:3;                        \n    $ m1;     \n"
    },
    {
        "title": "subarray",
        "cal": "subarray(X, range)",
        "params": "`X` is a vector/matrix.",
        "exp": "When a subset of the elements of a vector are needed in calculation, if we use script such as close[10:].avg(), a new vector close[10:] is generated with replicated data from the original vector close before the calculation is conducted. This not only consumes more memory but also takes time.",
        "eg": "Example 1\n"
    },
    {
        "title": "submitJob",
        "cal": "submitJob(jobId, jobDesc, jobDef, args...)",
        "params": "`jobId` is a string indicating the job ID.",
        "exp": "Submit a batch job to the local node and return the job ID for future reference. To submit a batch job to a remote node, please use submitJob together with  :doc:`../r/rpc` or :doc:`../r/remoteRun`. For details please refer to the section of :doc:`/SystemManagement/BatchJobManagement`.",
        "eg": "\n    $ def jobDemo(n){\n    $     s = 0\n    $     for (x in 1 : n) {\n    $         s += sum(sin rand(1.0, 100000000)-0.5)\n    $         print(\"iteration \" + x + \" \" + s)\n    $     }\n    $     return s\n    $ };\n\n    $ submitJob(\"jobDemo1\",\"job demo\", jobDemo, 100);\n    jobDemo1\n\n    $ getJobStatus(\"jobDemo1\");\n"
    },
    {
        "title": "submitJobEx",
        "cal": "submitJobEx(jobId, jobDesc, priority, parallelism, jobDef, args...)",
        "params": "`jobId` is a string indicating the job ID.",
        "exp": "Submit a batch job to the local node and return the job ID for future reference. The only difference between `submitJobEx` and :doc:`submitJob` is that we can specify parameters priority and parallelism in `submitJobEx`.",
        "eg": "\n    $ def jobDemo(n){\n    $     s = 0\n    $     for (x in 1 : n) {\n    $         s += sum(sin rand(1.0, 100000000)-0.5)\n    $         print(\"iteration \" + x + \" \" + s)\n    $     }\n    $     return s\n    $ };\n\n    $ submitJobEx(\"jobDemo1\",\"job demo\", 8, 12, jobDemo, 100);\n    jobDemo1\n"
    },
    {
        "title": "subscribeTable",
        "cal": "Subscribe to a stream table on a local or remote server from a client node. We can also specify a function to process the subscribed data.",
        "params": "subscribeTable([server],tableName,[actionName],[offset=-1],handler,[msgAsTable=false],[batchSize=0],[throttle=1],[hash=-1],[reconnect=false],[filter],[persistOffset=false],[timeTrigger=false],[handlerNeedMsgId=false], [raftGroup])",
        "exp": "Only `tableName` and `handler` are required. All the other parameters are optional.",
        "eg": "The following is an example about streaming. A cluster has 2 nodes: DFS_NODE1 and DFS_NODE2. We need to specify maxPubConnections and subPort in cluster.cfg to enable the publish/subscribe functionality. For example:\n"
    },
    {
        "title": "substr",
        "cal": "substr(X, offset, [length])",
        "params": "`X` is a string scalar/vector.",
        "exp": "Return a substring of `X` with the specified starting position (offset) and length (length). The first character of `X` corresponds to position 0. If length exceeds the length of X, stop at the end of X.",
        "eg": "\n    $ substr(\"This is a test\", 0, 4);\n    This\n\n    $ substr(\"This is a test\", 5, 2);\n    is\n\n    $ substr(\"This is a test\", 5);\n    is a test\n\n    $ substr(\"This is a test\", 8, 100);\n    a test\n"
    },
    {
        "title": "substru",
        "cal": "substru(X, offset, [length])",
        "params": "`X` is a string scalar/vector.",
        "exp": "The only differerence between `substru` and :doc: `substr` is that substru can process Unicode strings.",
        "eg": "\n    $ substr(\"This is a test\", 0, 4);\n    This\n\n    $ substr(\"This is a test\", 5, 2);\n    is\n\n    $ substr(\"This is a test\", 5);\n    is a test\n\n    $ substr(\"This is a test\", 8, 100);\n    a test\n"
    },
    {
        "title": "subtuple",
        "cal": "subtuple(X, range)",
        "params": "`X` is a tuple of vectors with the same length.",
        "exp": "Create a read-only view of a subarray of each vector in `X` almost instantly. In contrast, it takes time to create a new tuple of vectors.",
        "eg": "Example 1:\n"
    },
    {
        "title": "sum",
        "cal": "sum(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If `X` is a vector, return the sum of all the elements in `X`.",
        "eg": "\n    $ sum(1 2 3 NULL 4);\n    10\n\n    $ m=matrix(1 2 3, 4 5 6);\n    $ m;\n"
    },
    {
        "title": "sum2",
        "cal": "sum2(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If X is a vector, return the sum of squares of all the elements in X.",
        "eg": "\n    $ sum2(1 2 3);\n    14\n\n    $ sum2(1 NULL NULL);  \n    1\n\n    $ sum2(1.5 4.6 7.8);\n    84.25\n\n    $ m=matrix(1 2 3, 4 5 6);\n    $ m;\n"
    },
    {
        "title": "sum3",
        "cal": "sum3(X)",
        "params": "`X`  is a scalar/vector/matrix.",
        "exp": "If X is a vector, return the sum of cubes of all the elements in X.",
        "eg": "\n\n    $ sum3(1 2 3);\n    36\n\n    $ sum3(1 NULL NULL);  \n    1\n\n    $ sum3(1.5 4.6 7.8);\n    575.263\n\n    $ m=matrix(1 2 3, 4 5 6);\n    $ m;\n"
    },
    {
        "title": "sum4",
        "cal": "sum4(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If X is a vector, return the sum of the fourth powers of all the elements in X.",
        "eg": "\n    $ sum4(1 2 3);\n    98\n\n    $ sum4(1 NULL NULL);  \n    1\n\n    $ sum4(1.5 4.6 7.8);\n    4154.3137\n\n    $ m=matrix(1 2 3, 4 5 6);\n    $ m;\n"
    },
    {
        "title": "sumbars",
        "cal": "sumbars(X, Y)",
        "params": "`X` is a vector/tuple/matrix/table whose elements must be non-negative numbers.",
        "exp": "For each element X :sub:`i` in *X*, calculate the cumulative sum of X :sub:`i` in the backward direction, i.e., (X :sub:`i` + X :sub:`i-1` + X :sub:`i-2` ), until the value is no smaller than *Y*.",
        "eg": "\n    $ sumbars(1 2 3.3 2 5, 3)\n    [0,2,1,2,1]\n\n    $ sumbars(matrix(5 3 6 2 3, 2 6 1 5 4), [5, 8])\n"
    },
    {
        "title": "suspendRecovery",
        "cal": "suspendRecovery()",
        "params": "None",
        "exp": "Suspend online node recovery processes. When this command is executed, tasks in \"In-Progress\" status will continue to recover and processes in \"Waiting\" status will be suspended. Once suspended, the source node can continue to receive new data. This command can only be executed by the administrator on the controller.",
        "eg": "1.30.162.00.4\n\nRelated command: :doc:`../r/resumeRecovery`"
    },
    {
        "title": "svd",
        "cal": "svd(obj, [fullMatrices=true], [computeUV=true])",
        "params": "`obj` is a matrix.",
        "exp": "Perform the singular decomposition of a matrix.",
        "eg": "\n    $ m=matrix([[2,1,0],[1,3,1],[0,1,4],[1,2,3]]);\n    $ U,s,V=svd(m);\n    $ U;\n"
    },
    {
        "title": "symbol",
        "cal": "symbol(X)",
        "params": "`X` is a string/symbol vector.",
        "exp": "Convert `X` to a symbol vector.",
        "eg": "\n\n    $ x=`XOM`y;\n    $ typestr(x);\n    STRING VECTOR\n\n    $ y=symbol(x);\n    $ y;\n    [\"XOM\",\"y\"]\n\n    $ typestr(y);\n    FAST SYMBOL VECTOR"
    },
    {
        "title": "symmetricDifference",
        "cal": "symmetricDifference(X, Y) or X^Y ",
        "params": "`X` and `Y` are sets.",
        "exp": "Return the union of two sets minus the intersection of the two sets.",
        "eg": "\n\n    $ x=set([5,3,4])\n    $ y=set(8 9 4 6);\n\n    $ y^x;\n    set(5,8,3,9,6)\n\n    $ x^y;\n    set(8,5,3,6,9)"
    },
    {
        "title": "syncDict",
        "cal": "syncDict(keyObj, valueObj, [sharedName], [ordered=false])",
        "params": "`keyObj` a vector indicating dictionary keys.",
        "exp": "Return a thread-safe dictionary that allows concurrent read and write by multiple threads.",
        "eg": "\n    $ x=1 2 3     \n    $ y=4.5 7.8 4.3\n    $ z=syncDict(x,y);\n    3->4.3\n    1->4.5\n    2->7.8\n\n    $ z=syncDict(INT,DOUBLE)\n    $ z[5]=7.9\n    $ z;\n    5->7.9\n\n    $ syncDict(INT,DOUBLE, `sn)\n    $ sn[5 6]=10.99 2.33\n    $ sn[5];\n    10.99\n"
    },
    {
        "title": "syntax",
        "cal": "syntax(X)",
        "params": "`X` is a DolphinDB function/command.",
        "exp": "Return the syntax of function/command `X`.",
        "eg": "\n    $ syntax(createPartitionedTable);\n    createPartitionedTable(dbHandle, table, tableName, [partitionColumns], [compressMethods])\n"
    },
    {
        "title": "t3",
        "cal": "t3(X, window, [vfactor=1.0])",
        "params": "`vfactor` is a floating-point number in [0,1]. The default value is 1.0.",
        "exp": "Calculate the Triple Exponential Moving Average (t3) for *X* in a sliding window of the given length.",
        "eg": "  \n   $ x=12.1 12.2 12.6 12.8 11.9 11.6 11.2 16.9 55.6 5.6 3.3 66 6 57\n   $ t3(x, 3, 0.5);\n   [,,,,,,,,,,,,27.652790217144499,33.482904095904814]\n\n   $ x=matrix(12.1 12.2 12.6 12.8 11.9 11.6 11.2 15.7 18.6 13.2 19.6 20.3 22.4 11, 14 15 18 19 21 12 10 6 5.5 7 11 16 15 9.9)\n   $ t3(x, 3, 0.8);\n"
    },
    {
        "title": "tTest",
        "cal": "tTest(X, [Y], [mu=0.0], [confLevel=0.95], [equalVar=false])",
        "params": "`X`  is a numeric vector indicating the sample for the t-test.",
        "exp": "If `Y` is not specified, conduct a one-sample t-test on `X`. If `Y` is specified, conduct a paired-sample t-test on `X` and `Y`.  ",
        "eg": "One-sample t-test:\n"
    },
    {
        "title": "table",
        "cal": "table(X, [X1], [X2], .....)",
        "params": "For the first scenario:  ",
        "exp": "* For the first scenario: ",
        "eg": "Examples of table(X, [X1], [X2], .....):\n"
    },
    {
        "title": "tableInsert",
        "cal": "tableInsert(table, args...)",
        "params": "`table` is a table object or a table name. The table can be either an in-memory table or a DFS table. In remote call, it must be a table name as we don't have the reference of a table object.",
        "exp": "Insert `args`... into table. Return the number of rows inserted from the operation.",
        "eg": "\n    $ colName=[\"Name\",\"Age\"]\n    $ colType=[\"string\",\"int\"]\n    $ t1=table(100:0,colName, colType);\n\n    $ name=`Tom`Jerry`John\n    $ age=24 25 26\n    $ t2=table(name, age)\n\n    $ tableInsert(t1, t2);\n    3\n\n    $ t1;\n"
    },
    {
        "title": "tail",
        "cal": "tail(obj, [n=1])",
        "params": "`obj` is a vector/matrix/table.",
        "exp": "Return the last n element(s) of a vector, or the last n columns of a matrix, or the last n rows of a table.",
        "eg": "\n    $ x=1..10;\n    $ tail(x);\n    10\n\n    $ tail(x,2);\n    [9,10]\n\n    $ x=1..10$2:5;\n    $ x;\n"
    },
    {
        "title": "take",
        "cal": "take(X, n)",
        "params": "`X` is a scalar/vector/tuple/matrix/table.",
        "exp": "- If *X* is a scalar (*n* must also be a scalar): Generates a vector containing *n* identical values of *X*.  ",
        "eg": "\n    $ take(10,5);\n    [10,10,10,10,10]\n\n    $ x=`IBM`C`AAPL`BABA;\n    $ take(x,10);\n    [\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\",\"AAPL\",\"BABA\",\"IBM\",\"C\"]\n    // sequentially and iteratively take 10 elements from vector x\n\n    $ x=3 5 4 6 9; \n    $ take(x,3); \n    [3,5,4]        \n\n\n    $ x=1..3;\n    $ x.take(10);\n    [1,2,3,1,2,3,1,2,3,1]\n\n    $ take(1 2 3, 10);\n    [1,2,3,1,2,3,1,2,3,1]\n\n\n    $ take(1,10);\n    [1,1,1,1,1,1,1,1,1,1]\n    // an efficient way to generate a vector with default values.\n\n\n    $ x=take(1,0);\n    // return an empty INT VECTOR\n\n    $ x;\n    []\n\n    $ typestr x;\n    FAST INT VECTOR\n\n\n    $ x=1..12$3:4;\n    $ take(x,2);\n    [1,2]\n\n    $ take(x,-2);\n    [11,12]\n\n    $ take(1..3,2 0 2)\n    [1,1,3,3]\n\n    $ m=matrix(1 2 3, 4 5 6)\n    $ take(m,5)\n    col1\tcol2\n    1\t4\n    2\t5\n    3\t6\n    1\t4\n    2\t5\n\n    $ take(m, 0 2 1)\n    col1\tcol2\n    2\t5\n    2\t5\n    3\t6\n\n    $ t=table(1 2 3 as a, 4 5 6 as b)\n    $ take(t,-4)\n    a\tb\n    3\t6\n    1\t4\n    2\t5\n    3\t6\n\n    $ take(t, -2 2 1)\n    a\tb\n    2\t5\n    2\t5\n    3\t6"
    },
    {
        "title": "talib",
        "cal": "talib(func, args...)",
        "params": "`func` is a function.",
        "exp": "Regarding the NULL value handling, the differences between DolphinDB's built-in moving functions and Python TA-lib lie in:",
        "eg": "See the differences of function ``talib`` and DolphinDB built-in functions with the following example:\n"
    },
    {
        "title": "talibNull",
        "cal": "talibNull(args...)",
        "params": "`args...` consist of two or more vectors. All vectors must have the same length.",
        "exp": "Traverse each vector (v1, v2, , vn) based on the index starting from 0 and return a tuple. ",
        "eg": "The values at index 2 of all vectors are non-NULL. Therefore, return NULL values for all elements before index 2.\n"
    },
    {
        "title": "tan",
        "cal": "tan(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The tangent function.",
        "eg": "\n   $ tan(0 1 2);\n   [0,1.557408,-2.185040]\n"
    },
    {
        "title": "tanh",
        "cal": "tanh(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "The hyperbolic tangent function.",
        "eg": "\n   $ tanh(0 1 2);\n   [0,0.761594,0.964028]\n"
    },
    {
        "title": "tanimoto",
        "cal": "tanimoto(X, Y)",
        "params": "`X` and `Y` are numeric scalars, or vectors/matrices of the same size.",
        "exp": "If *X* and *Y* are scalars or vectors, return the result of their tanimoto distance.",
        "eg": "  \n   $ a=[10.5, 11.8, 9]\n   $ b=[11.3, 15.1, 8.9]\n   $ tanimoto(a,b)  \n   0.029706\n\n   $ s1=indexedSeries(2020.01.01..2020.01.03, 10.4 11.2 9)\n   $ s2=indexedSeries(2020.01.01 2020.01.03 2020.01.04, 23.5 31.2 26)\n   $ tanimoto(s1,s2)\n   0.5585\n\n   $ m=matrix(23 56 47, 112 94 59)\n   $ m1=matrix(11 15 89, 52 41 63)\n   $ tanimoto(m,m1)   \n   [0.40490.3242]\n\n   $ m.rename!(2020.01.01..2020.01.03, `A`B)\n   $ m.setIndexedMatrix!()\n   $ m1.rename!(2020.01.01 2020.01.03 2020.01.04, `A`B)\n   $ m1.setIndexedMatrix!()\n   $ tanimoto(m,m1)\n   [0.5494,0.3225]\n"
    },
    {
        "title": "tema",
        "cal": "tema(X, window)",
        "params": "Calculate the Triple Exponential Moving Average (tema) for *X* in a sliding window of the given length.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "temporalAdd",
        "cal": "temporalAdd(obj, duration, unit)",
        "params": "`obj` is a temporal scalar/pair/vector.",
        "exp": "Add a value to a temporal variable.",
        "eg": "\n    $ temporalAdd(2017.01.16,1,\"d\");\n    2017.01.17\n\n    $ temporalAdd(2017.01.16,1,\"w\");\n    2017.01.23\n\n    $ temporalAdd(2016.12M,2,\"M\");\n    2017.02M\n\n    $ temporalAdd(2012.07.31T13:30:10.008,-1,'M');\n    2012.06.30T13:30:10.008\n\n    $ temporalAdd(2012.07.31T13:30:10.008,1,'y');\n    2013.07.31T13:30:10.008\n\n    $ temporalAdd(13:30:10.008007006,100,\"ns\");\n    13:30:10.008007106\n\n    $ x=[12:23:34, 23:34:45];\n    $ temporalAdd(x, 10m);\n    [12:33:34,23:44:45]\n"
    },
    {
        "title": "temporalFormat",
        "cal": "temporalFormat(X, format)",
        "params": "`X` is a scalar/vector of temporal data types.",
        "exp": "Convert a DolphinDB temporal variable to a string with specified format. For details about DolphinDB temporal formats, please check the section :doc:`/DataManipulation/TemporalObjects/ParsingandFormatofTemporalVariables`.",
        "eg": "\n    $ temporalFormat(2018.02.14,\"dd-MM-yyyy\");\n    14-02-2018\n\n    $ temporalFormat(2018.02.14,\"dd-MMM-yy\");\n    14-FEB-18\n\n    $ temporalFormat(02:19:06,\"HH.mm.ss\");\n    02.19.06\n\n    $ temporalFormat(2018.02.06T13:30:10.001, \"y-M-d-H-m-s-SSS\");\n    2018-2-6-13-30-10-001\n\n    $ temporalFormat(14:19:06,\"hhmmssaa\");\n    021906PM\n"
    },
    {
        "title": "temporalParse",
        "cal": "temporalParse(X, format)",
        "params": "`X` is a string scalar/vector to be converted to temporal data types.",
        "exp": "Convert a string with specified format to a DolphinDB temporal data type. Return NULL if it cannot decide on the data type.",
        "eg": ""
    },
    {
        "title": "test",
        "cal": "test(scriptFile, [outputFile], [testMemLeaking=false])",
        "params": "`scriptFile` is a string indicating the path of a testing script file or a folder. ",
        "exp": "A system command for unit testing. It must be executed by a logged-in user.",
        "eg": "\n    $ test(\"C:/DolphinDB/test/test1.txt\", \"C:/DolphinDB/testResult/test1.txt\");\n    $ test(\"C:/DolphinDB/test\");\n"
    },
    {
        "title": "textChunkDS",
        "cal": "(filename, chunkSize, [delimiter], [schema], [skipRows=0], [arrayDelimiter], [containHeader])",
        "params": "`filename` the input text file name with its absolute path.",
        "exp": "To load an extremely large text file into DolphinDB database, we can first use function ``textChunkDS`` to divide the text file into multiple data sources with the size of each data source specified by chunkSize, then use function :doc:`../m/mr` to load data.",
        "eg": "Use the following script to generate the data file of about 3.2GB:\n"
    },
    {
        "title": "til",
        "cal": "til(n)",
        "params": "`n` is a non-negative integer.",
        "exp": "Return a vector of integral type from 0 to n-1. If n=0, return an empty vector.",
        "eg": "\n    $ til(0);\n    []\n\n    $ til(5);\n    [0,1,2,3,4]\n\n    $ n = 10;\n    $ t = table(2022.01.01 + til(n) as date, rand(10.0, n) as val);\n    $ t;\n    date\tval\n    2022.01.01\t8.403\n    2022.01.02\t9.424\n    2022.01.03\t0.4779\n    2022.01.04\t1.8934\n    2022.01.05\t9.6637\n    2022.01.06\t1.7993\n    2022.01.07\t7.1143\n    2022.01.08\t8.3044\n    2022.01.09\t2.6919\n    2022.01.10\t1.9294\n"
    },
    {
        "title": "time",
        "cal": "time(X)",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return the corresponding time(s) with millisecond precision. The data type of the result is TIME, a temporal.",
        "eg": "\n    $ time();\n    00t\n\n    $ time(\"12:32:56.356\");\n    12:32:56.356\n\n    $ time(now());\n    20:49:12.564\n"
    },
    {
        "title": "timestamp",
        "cal": "timestamp(X)",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return the corresponding timestamp(s). The return value type is TIMESTAMP, a temporal.",
        "eg": "\n    $ timestamp(2016.10.12);\n    2016.10.12T00:00:00.000\n\n    $ timestamp(2016.10.12)+1;\n    2016.10.12T00:00:00.001\n\n    $ timestamp(now());\n\n    2016.10.13T20:28:45.104\n"
    },
    {
        "title": "tmavg",
        "cal": "tmavg(T, X, window)",
        "params": "Calculate the moving average of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmavgTopN",
        "cal": "tmavgTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the moving average of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmbeta",
        "cal": "tmbeta(T, Y, X, window)",
        "params": "Calculate the coefficient estimate of an ordinary-least-squares regression of *Y* on *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmbetaTopN",
        "cal": "tmbetaTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function obtains the first top pairs of elements in X and Y in a sliding window and calculates the coefficient estimate ordinary-least-squares regressions of Y on X.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmcorr",
        "cal": "tmcorr(T, X, Y, window)",
        "params": "Calculate the correlation of *X* and *Y* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmcorrTopN",
        "cal": "tmcorrTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the correlation of X and Y in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmcount",
        "cal": "tmcount(T, X, window)",
        "params": "Return the number of non-NULL values of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmcovar",
        "cal": "tmcovar(T, X, Y, window)",
        "params": "Calculate the moving covariance of *X* and *Y* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmcovarTopN",
        "cal": "tmcovarTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the covariance of X and Y in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmfirst",
        "cal": "tmfirst(T, X, window)",
        "params": "Return the first element of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmkurtosis",
        "cal": "tmkurtosis(T, X, window, [biased=true])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Calculate the moving kurtosis of *X* in a sliding window.",
        "eg": ""
    },
    {
        "title": "tmkurtosisTopN",
        "cal": "tmkurtosisTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the kurtosis of the first top elements of X in a sliding window.",
        "eg": "    \n    $ T=2023.01.03+1..10\n    $ X = [2, 1, 4, 3, 4, 3, 1, 5, 8, 2]\n    $ S = [5, 8, 1, , 1, 1, 3, 2, 5 ,1] \n    // The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\n    $ tmkurtosisTopN(T,X,S,6,4)\n    [,,1.5,1.5,1.2798,1.628,2,2,1.8457,1.64]\n    \n    $ T=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12 2023.01.13 2023.01.14 2023.01.15 2023.01.16\n    $ X=8 3 1 2 5 2 5 4 2 6\n    $ S=1 5 2 3 1 1 2 4 5 3 \n    $ t=table(T as time, X as val, S as id)\n    $ select tmkurtosisTopN(time,val,id,6,4) as topN from t\n    "
    },
    {
        "title": "tmlast",
        "cal": "tmlast(T, X, window)",
        "params": "Return the last element of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmmax",
        "cal": "tmmax(T, X, window)",
        "params": "Calculate the moving maximum of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmmed",
        "cal": "tmmed(T, X, window)",
        "params": "Calculate the moving median of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmmin",
        "cal": "tmmin(T, X, window)",
        "params": "Calculate the moving minimum of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmove",
        "cal": "tmove(T, X, window)",
        "params": "`T` is a non-strictly increasing vector of temporal or integral type. It cannot contain NULL values.",
        "exp": "For each element T :sub:`i` in *T*, return the element in *X* which is at the same position as (T :sub:`i`-window) in *T*. If there is no match of (T :sub:`i` - window) in *T*, return the corresponding element in *X* at the previous adjacent time of (T :sub:`i` - window).",
        "eg": ""
    },
    {
        "title": "tmoving",
        "cal": "tmoving(func, T, funcArgs, window)",
        "params": "`func` is a function.",
        "exp": "Apply the function/operator to a sliding window of the given objects.",
        "eg": ""
    },
    {
        "title": "tmpercentile",
        "cal": "tmpercentile(T, X, percent, window, [interpolation='linear'])",
        "params": "`percent` is an integer or floating number between 0 and 100.",
        "exp": "Return the percentile rank of each element of X in a sliding window.",
        "eg": ""
    },
    {
        "title": "tmprod",
        "cal": "tmprod(T, X, window)",
        "params": "Calculate the moving product of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmrank",
        "cal": "tmrank(T, X, ascending, window, [ignoreNA=true], [tiesMethod='min'], [percent=false])",
        "params": "`ascending` is a Boolean value. The default value is true indicating the sorting direction is ascending.",
        "exp": "Return the rank of each element of *X* in a sliding window.",
        "eg": "\n    $ tmrank(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, ascending=true, window=3)\n    [0,0,1,0,0,0,1,0] \n\n    $ index = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.14 13:30:10)+1..6)\n    $ data = 1 NULL 3 4 5 NULL 3 NULL 5 3\n    \n    $ tmrank(index, data, ascending=true, window=4h)\n    [0,,1,2,0,,0,,1,0]\n\n    $ tmrank(index, data, ascending=true, window=2d)\n    [0,,1,2,3,,1,,4,1]\n"
    },
    {
        "title": "tmskew",
        "cal": "tmskew(T, X, window, [biased=true])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "Calculate the moving skewness of *X* in a sliding window.",
        "eg": "\n    $ tmskew(1 1 3 5 8 15 15 20, 5 2 4 1 2 8 9 10, 3)\n    [,0,-0.381801774160607,0,,,0,]\n    $ index = take(datehour(2019.06.13 13:30:10),4) join (datehour(2019.06.13 13:30:10)+1..6)\n    $ data = 1 NULL 3 4 5 NULL 3 NULL 5 3\n    $ tmskew(index, data, 4h)\n    [,,,-0.3818,,,0,0,0,0.7071]\n    $ tmskew(index, data, 2d)\n    [,,0,-0.3818,-0.4347,-0.4347,-0.37,-0.37,-0.5653,-0.4363]\n"
    },
    {
        "title": "tmskewTopN",
        "cal": "tmskewTopN(T, X, S, window, top, [biased=true], [ascending=true], [tiesMethod='latest'])",
        "params": "`biased` is a Boolean value indicating whether the result is biased. The default value is true, meaning the bias is not corrected.",
        "exp": "After stably sorting S in the specified ascending order, the function calculates the skewness of the first top elements of X in a sliding window.",
        "eg": "    \n    $ T=2023.01.03+1..7\n    $ X = [2, 1, 4, 3, 4, 3, 1]\n    $ S = [5, 8, 1, , 1, 1, 3]  \n    // The NULL values in S are ignored in data sorting, and the corresponding elements in X do not participate in calculation\n    $ tmskewTopN(T,X,S,6,4)\n    [,0,0.3818,0.3818,-0.2138,-0.4933,-0.8164]\n    \n    $ T=2023.01.03 2023.01.07 2023.01.08 2023.01.10 2023.01.11 2023.01.12\n    $ X=8 3 1 2 5 2\n    $ S=1 5 2 3 1 1   \n    $ t=table(T as time, X as val, S as id)\n    $ select tmskewTopN(time,val,id,4,3) as topN from t\n    "
    },
    {
        "title": "tmstd",
        "cal": "tmstd(T, X, window)",
        "params": "Calculate the standard deviation of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmstdTopN",
        "cal": "tmstdTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the standard deviation of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmstdp",
        "cal": "tmstdp(T, X, window)",
        "params": "Calculate the population standard deviation of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmstdpTopN",
        "cal": "tmstdpTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the population standard deviation of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmsum",
        "cal": "tmsum(T, X, window)",
        "params": "Calculate the moving sum of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmsum2",
        "cal": "tmsum2(T, X, window)",
        "params": "Calculate the moving sum of squares of all elements of *X* in a sliding window. Please note that the return is always of DOUBLE type.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmsumTopN",
        "cal": "tmsumTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the moving sum of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmvar",
        "cal": "tmvar(T, X, window)",
        "params": "Calculate the moving variance of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmvarTopN",
        "cal": "tmvarTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the variance of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmvarp",
        "cal": "tmvarp(T, X, window)",
        "params": "Calculate the moving population variance of *X* in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmvarpTopN",
        "cal": "tmvarpTopN(T, X, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function calculates the population variance of the first top elements of X in a sliding window.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "tmwavg",
        "cal": "tmwavg(T, X, Y, window)",
        "params": "Calculate the moving average of *X* with *Y* as weights in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmwsum",
        "cal": "tmwsum(T, X, Y, window)",
        "params": "Calculate the moving sum of *X* with *Y* as weights in a sliding window.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "tmwsumTopN",
        "cal": "tmwsumTopN(T, X, Y, S, window, top, [ascending=true], [tiesMethod='latest'])",
        "params": "After stably sorting S in the specified ascending order, the function obtains the first top pairs of elements in X and Y in a sliding window and calculates the cumulative weighted sum of X with Y as the weights.",
        "exp": "    ",
        "eg": ""
    },
    {
        "title": "toCharArray",
        "cal": "toCharArray(X)",
        "params": "`X` a scalar/vector of the STRING/BLOB/SYMBOL data type.",
        "exp": "Split a string into a vector of the CHAR data type.",
        "eg": "\n    $ str = \"It is great!\\n\"\n    $ print str.toCharArray()\n    ['I','t',' ','i','s',' ','g','r','e','a','t','!',10]\n\n    $ str1 = [\"A#\", \"B C\", \"D\\t\"]\n    $ print str1.toCharArray()\n    [['A','#'],['B',' ','C'],['D',9]]\n\n"
    },
    {
        "title": "toJson",
        "cal": "toJson(X)",
        "params": "`X` can be any data type.",
        "exp": "Convert a DolphinDB object to JSON format. The result includes 5 key-value pairs: name, form, type, size and value.",
        "eg": "\n    $ x=1 2 3\n    $ y=toJson(x)\n    $ y;\n    {\"name\":\"x\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]}\n\n    $ t=table(1 2 3 as id, 10 20 30 as val)\n    $ toJson(t);\n    {\"name\":\"t\",\"form\":\"table\",\"size\":\"3\",\"value\":[{\"name\":\"id\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[1,2,3]},{\"name\":\"val\",\"form\":\"vector\",\"type\":\"int\",\"size\":\"3\",\"value\":[10,20,30]}]}\n\n    // The length of set exceeds 30000, and toJson can only convert the first 30000 elements\n    $ x=set(1..400001)\n    $ y=toJson(x)\n    $ size(fromJson(y))\n    300000\n"
    },
    {
        "title": "toStdJson",
        "cal": "toStdJson(obj)",
        "params": "`obj` cannot be of data form matrix or pair, nor can it be of data type UUID, IPADDR, INT128, COMPRESS, or .",
        "exp": "Convert a DolphinDB object to JSON format.  ",
        "eg": "\n    $ x=1 2 3\n    $ toStdJson(x);\n    [1, 2, 3]\n\n    $ t=table(1 2 3 as id, 10 20 30 as val)\n    $ toStdJson(t);\n    [{\"id\": 1,\"val\": 10},{\"id\": 2,\"val\": 20},{\"id\": 3,\"val\": 30}]\n\n    $ b = set(2012.06.13T13:30:10 2017.07.10T14:10:12)\n    $ toStdJson(b);\n    [\"2017.07.10 14:10:12\",\"2012.06.13 13:30:10\"]\n\n    $ b = dict(int,datetime)\n    $ b[0] = 2012.06.13 13:30:10\n    $ b[1] = 2017.07.10 14:10:12\n    $ toStdJson(b);\n    {\"1\": \"2017.07.10 14:10:12\",\"0\": \"2012.06.13 13:30:10\"}\n\n    $ t1=table(`x`y`z as b, 2012.06.13 13:30:10 2012.06.13 13:30:10 2012.06.13 13:30:10 as c,10.8 7.6 3.5 as F)\n    $ toStdJson(t1);\n    [{\"b\": \"x\",\"c\": \"2012.06.13 13:30:10\",\"F\": 10.8},{\"b\": \"y\",\"c\": \"2012.06.13 13:30:10\",\"F\": 7.6},{\"b\": \"z\",\"c\": \"2012.06.13 13:30:10\",\"F\": 3.5}]\n\n"
    },
    {
        "title": "toUTF8",
        "cal": "toUTF8(str, encode)",
        "params": "`str` is a string scalar/vector.",
        "exp": "Change the encoding of strings to UTF-8.",
        "eg": "\n    $ toUTF8(\"DolphinDB\",\"gbk\");\n    DolphinDB\n\n    $ toUTF8([\"hello\",\"world\"],\"euc-cn\");\n    [\"hello\",\"world\"]\n"
    },
    {
        "title": "today",
        "cal": "today()",
        "params": "None",
        "exp": "Return the current date.",
        "eg": "\n    $ today();\n    2019.03.30"
    },
    {
        "title": "toggleAsyncReplicationTaskSkipFlag",
        "cal": "toggleAsyncReplicationTaskSkipFlag(cid)",
        "params": "`cid` The commit ID of the associated transaction.",
        "exp": "After enabling the cross-cluster asynchronous replication mode, execute this function on a data node of the master cluster to toggle the skip flag of a task. You can use function ``getAsyncReplicationTasks`` to check the status of the skip flag of a task. ",
        "eg": "  \n   $ toggleAsyncReplicationTaskSkipFlag(cid);\n"
    },
    {
        "title": "topRange",
        "cal": "topRange(X)",
        "params": "`X` is a vector/tuple/matrix/table",
        "exp": "For each element *Xi* in *X*, count the continuous nearest neighbors to its left that are larger than *Xi*.",
        "eg": "\n    $ topRange([13.5, 13.6, 13.4, 13.3, 13.5, 13.9, 13.1, 20.1, 20.2, 20.3])\n    [0,1,0,0,2,5,0,7,8,9]\n\n    $ m = matrix(1.5 2.6 3.2 1.4 2.5 2.2 3.7 2.0, 1.6 2.3 4.2 5.6 4.1 3.2 4.4 6.9)\n    $ topRange(m)\n"
    },
    {
        "title": "transDS!",
        "cal": "transDS!(ds, tranFunc)",
        "params": "`ds` is a data source or a list of data sources. It is the sole argument of all the functions in `transFunc`.",
        "exp": "Apply data transforming functions to a data source or a list of data sources.",
        "eg": "In the following example, the data type of column `trade_time` from the DFS table `trades1` is converted into NANOTIMESTAMP and inserted into the DFS table `trades2`.\n"
    },
    {
        "title": "transFreq",
        "cal": "transFreq(X, rule, [closed], [label], [origin='start_day'])",
        "params": "`X` is a scalar/vector of temporal type.",
        "exp": "For each element of `X`, conduct a transformation as specified with parameter `rule`. The result has the same length as `X`.",
        "eg": "\n    $ transFreq(2020.11.08 2020.11.09 2020.11.18, \"SM\");\n    [2020.10.31,2020.10.31,2020.11.15]\n\n    $ transFreq(2020.08.08 2020.11.18, \"Q\");\n    [2020.09.30,2020.12.31]\n\n    $ transFreq(2020.08.08 2020.11.18, \"2Q\");\n    [2020.09.30,2021.03.31]\n"
    },
    {
        "title": "transpose",
        "cal": "transpose(X)",
        "params": "`X` is a tuple, matrix, table, or dictionary.",
        "exp": "If `X` is a tuple: all elements of the tuple must have the same length. Return a tuple of the same length as each element of `X`. The n-th element of the result is a vector composed of the n-th element of each element of `X`.",
        "eg": "Example 1: transpose of a tuple:\n"
    },
    {
        "title": "triggerNodeReport",
        "cal": "triggerNodeReport(nodeAlias)",
        "params": "`nodeAlias` is a STRING scalar indicating the node alias.",
        "exp": "Force the specified data node to report the chunk information to the controller to update the metadata maintained on the controller.",
        "eg": "This command is used to solve the problem when the chunk information is not reported after a data node is restarted.\n\n1. Check whether the node is alive with field \"state\" returned by function ``getClusterPerf``;\n\n2. Check the chunk information with fields \"replicas\" and \"replicaCount\" by calling ``getClusterChunksStatus``;\n\n3. If the node is alive but the numbers of replicas do not match, you can search the corresponding chunk ID in the log of the controller. Find out the data node that has not reported and call this command on the node to trigger its report. \n\n4. If the command does not take effect, please restart the data node."
    },
    {
        "title": "triggerTSDBCompaction",
        "cal": "triggerTSDBCompaction(chunkId)",
        "params": "`chunkId` a STRING scalar indicating the chunk ID.",
        "exp": "In the TSDB engine, use this command to manually trigger the compaction of all level files stored at level 0 for optimal reading performance.",
        "eg": "There are 2 file types in a chunk, the file chunk containing information about the database and table schema, and the tablet chunk storing data. Compaction of level files can only be conducted within a tablet chunk. Set \"type=1\" to filter the IDs of tablet chunks.\n"
    },
    {
        "title": "tril",
        "cal": "tril(X, [k=0])",
        "params": "`X` is a matrix.",
        "exp": "If `k` is not specified: return the lower triangular portion of matrix `X`.",
        "eg": ""
    },
    {
        "title": "trim",
        "cal": "trim(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Trim all white spaces around the string.",
        "eg": ""
    },
    {
        "title": "trima",
        "cal": "trima(X, window)",
        "params": "Calculate the Triangular Moving Average (trima) for *X* in a sliding window of the given length.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "triu",
        "cal": "triu(X, [k=0])",
        "params": "`X` is a matrix.",
        "exp": "If `k` is not specified: return the upper triangular portion of matrix `X`.",
        "eg": ""
    },
    {
        "title": "trueRange",
        "cal": "trueRange(high, low, close)",
        "params": "The 3 parameters are numeric vectors of equal length.",
        "exp": "Return a vector of the same length as each of the input vectors.",
        "eg": ""
    },
    {
        "title": "truncate",
        "cal": "truncate(dbUrl, tableName)",
        "params": "`dbUrl` is a string indicating the DFS path of a database.",
        "exp": "Remove all rows from a DFS table but keep its schema. Command ``truncate`` is faster than the :doc:`/SQLStatements/delete` statement and the :doc:`/FunctionsandCommands/CommandsReferences/d/dropPartition` function.",
        "eg": "\n    $ n=1000000\n    $ ID=rand(150, n)\n    $ dates=2017.08.07..2017.08.11\n    $ date=rand(dates, n)\n    $ x=rand(10.0, n)\n    $ t=table(ID, date, x)\n    $ dbDate = database(, VALUE, 2017.08.07..2017.08.11)\n    $ dbID = database(, RANGE, 0 50 100 150)\n\n    $ dbName=\"dfs://compoDB\"\n    $ if(existsDatabase(dbName)){\n            dropDatabase(dbName)\n    $ }\n    $ db = database(dbName, COMPO, [dbDate, dbID])\n    $ pt = db.createPartitionedTable(t, `pt, `date`ID)\n    $ pt.append!(t);\n\n    $ truncate(dbName, `pt)\n"
    },
    {
        "title": "tupleSum",
        "cal": "tupleSum(X)",
        "params": "`X` is a tuple.",
        "exp": "Summarize individual results from multiple `map` calls. If each `map` call returns a tuple with `N` non-tuple objects, the input for ``tupleSum`` function would be a tuple of `N` tuples. Each child tuple contains `m` objects with identical data form and data type, where `m` is the number of `map` calls. If there is a single `map` call, however, ``tupleSum`` accepts the results of the `map` call as the input, and simply returns the input as the output.",
        "eg": ""
    },
    {
        "title": "twindow",
        "cal": "twindow(func, funcArgs, T, range, [prevailing=false])",
        "params": "`func` is an aggregate function.",
        "exp": "1.30.16/2.00.4",
        "eg": "Apply *func* over a sliding window of *funcArgs*. Each element in *funcArgs* corresponds to a window that is determined by *T* and *range*. The result has the same dimension as that of *funcArgs* (If *funcArgs* is a tuple, the result has the same dimension as that of each element in the tuple).\n\nSuppose *range* = [d1:d2], the windows are determined based on the following rules:\n\n\\1. When *range* is an integral pair:\n\n    * *T* is a vector of integral type: For element Ti in *T*, the window range is [Ti+d1, Ti+d2].\n\n    * *T* is a vector of temporal type: *range* has the precision of *T* by default. For element Ti in *T*, the window range is [temporalAdd(Ti, d1, unit), temporalAdd(Ti, d2, unit)], where unit indicates the precision of *T*.\n\n\\2. When *range* is a duration pair, *T* can only be a vector of temporal type. For element Ti in *T*, the window range is [temporalAdd(Ti, d1), temporalAdd(Ti, d2)].\n\nCompared with the `tmoving` function, ``twindow`` has more flexible windows. ``tmoving`` can be considered roughly as a special case of ``twindow``, where the right boundary of the *range* parameter is 0. However, when the window is measured by time, note the following differences regarding how to determine window boundaries:\n\n\\1. With ``twindow``, when the right boundary of the window matches multiple identical values, all records with the identical value participate in the calculation. When the left boundary of the window matches multiple identical values, if *prevailing* = true, only the last record with the identical value participates in the calculation; if *prevailing* = false, all records with the identical value participate in the calculation.\n\n\\2. With the ``tm`` functions, the range of the window is (*Ti* - window, *Ti* ] or (temporalAdd(*Ti*, -window), *Ti*] where the left boundary is exclusive. The current record is included as the last element in the corresponding window, regardless of whether the following records have identical values.\n"
    },
    {
        "title": "type",
        "cal": "type(X)",
        "params": "`X` can be any data type that the system supports.",
        "exp": "Return an integer indicating the data type of X. Please refer to :doc:`/DataTypesandStructures/DataTypes/index` for details.",
        "eg": ""
    },
    {
        "title": "typestr",
        "cal": "typestr(X)",
        "params": "`X`  can be any data type that the system supports.",
        "exp": "Return a string indicating the data type of X. Please refer to :doc:`/DataTypesandStructures/DataTypes/index` for details.",
        "eg": ""
    },
    {
        "title": "undef",
        "cal": "undef(obj, [objType=VAR])",
        "params": "`obj` a string or a string vector indicating the names of objects to be undefined. To undefine all the variables in a category, use the unquoted \"all\" for `obj`.  ",
        "exp": "Release variables or function definitions from the memory. You can also release a local variable (VAR) from the memory using \"= NULL\".",
        "eg": "\n    $ undef all;\n    $ x=1\n    $ undef(`x);\n    $ x=1\n    $ y=2\n    $ undef(`x`y);\n    $ share table(1..3 as x, 4..6 as y) as t\n    $ undef(`t, SHARED);\n"
    },
    {
        "title": "unifiedCall",
        "cal": "unifiedCall(func, args)",
        "params": "`func` is a function. ",
        "exp": "Call a function with the specified parameters. Similar to :doc:`/Functionalprogramming/TemplateFunctions/call`, ",
        "eg": ""
    },
    {
        "title": "unifiedExpr",
        "cal": "unifiedExpr(objs, optrs)",
        "params": "`objs` is a tuple with no less than 2 elements.",
        "exp": "Connect the operands in *objs* with the binary operators in *optrs* to generate metacode of a multivariate expression. You can execute the metacode with function :doc:`../e/eval`.",
        "eg": "\n    $ unifiedExpr((1, 2), add)\n    <1 + 2>\n\n    $ t=table(1..3 as price1, 4..6 as price2, 5..7 as price3)\n    $ a=sqlColAlias(unifiedExpr((sqlCol(\"price1\"), sqlCol(\"price2\"), sqlCol(\"price3\")), take(add, 2)))\n    $ sql(select=(sqlCol(`price1),sqlCol(`price2),sqlCol(`price3),a), from=t).eval()\n"
    },
    {
        "title": "union",
        "cal": "union(X, Y) or X|Y",
        "params": "`X` and `Y` are sets.",
        "exp": "Return the union of two sets.",
        "eg": ""
    },
    {
        "title": "unionAll",
        "cal": "unionAll(tableA, tableB, [byColName=false])",
        "params": "* For the first scenario, ",
        "exp": "For the first scenario, combine 2 tables into a single table. The result is an unpartitioned in-memory table.",
        "eg": "Scenario 1. Combine two in-memory tables.\n"
    },
    {
        "title": "unpack",
        "cal": "unpack(format, buf)",
        "params": "`format` is a format string. See appendix 1.1 Format Characters.",
        "exp": "Unpack from the *buffer* according to the format string *format*. The result is a tuple with the unpacked data even if it contains exactly one item.",
        "eg": "\n    $ res = pack(\"N\",1);\n    $ res1 = unpack(\"N\", res);\n    $ print(res1)\n    (1)\n\n\n    $ res = pack(\"3s i\", `123, 3)\n    $ res1 = unpack(\"3s i\",  res);\n    $ print(res1)  \n    (\"123\",3)"
    },
    {
        "title": "unpivot",
        "cal": "unpivot(obj, keyColNames, valueColNames, [func])",
        "params": "`obj` is a table.",
        "exp": "Convert the columns specified by *valueColNames* into a single column.",
        "eg": ""
    },
    {
        "title": "unregisterSnapshotEngine",
        "cal": "unregisterSnapshotEngine(dbName, tableName)",
        "params": "`dbName` is a string indicating the name of a distributed database. ",
        "exp": "Unregister a snapshot engine for a distributed table.  ",
        "eg": "\n    $ unregisterSnapshotEngine(\"dfs://compoDB\",\"pt\")"
    },
    {
        "title": "unsubscribeTable",
        "cal": "unsubscribeTable([server], tableName, [actionName], [removeOffset=true], [raftGroup])",
        "params": "`server` a string indicating the alias of a server or the xdb connection to a server where the stream table is located. If it is unspecified or an empty string (\"\"), it means the local instance.",
        "exp": "Stop subscribing to data from the publisher. All messages of the topic in the message queue of the execution thread will be deleted.",
        "eg": "Create table trades2 on the subscriber to stream data from table trades from the publisher:\n"
    },
    {
        "title": "update!",
        "cal": "update!(table, colNames, newValues, [filter])",
        "params": "`table` is a DolphinDB table. It can be a partitioned in-memory table.",
        "exp": "Update columns of a table in place. If a column in `colNames` doesn't exist, create a new column; otherwise update the existing column. If a filter is specified, only rows satisfying the filtering condition will be updated.",
        "eg": ""
    },
    {
        "title": "updateLicense",
        "cal": "updateLicense()",
        "params": "None",
        "exp": "Update the license without restarting the node.",
        "eg": ""
    },
    {
        "title": "upper",
        "cal": "upper(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Convert all characters in a string or a list of strings into upper cases.",
        "eg": ""
    },
    {
        "title": "upsert!",
        "cal": "upsert!(obj, newData, [ignoreNull=false], [keyColNames], [sortColumns])",
        "params": "`obj` is a keyed table, indexed table, or a DFS table.",
        "exp": "Insert rows into a keyed table or indexed table if the values of the primary key do not already exist, or update them if they do. ",
        "eg": "``upsert!`` a keyed table:\n"
    },
    {
        "title": "uuid",
        "cal": "uuid(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Convert STRING into UUID data type.",
        "eg": "\n   $ uuid(\"\");\n   00000000-0000-0000-0000-000000000000\n\n   $ a=uuid(\"9d457e79-1bed-d6c2-3612-b0d31c1881f6\");\n   $ a;\n   9d457e79-1bed-d6c2-3612-b0d31c1881f6\n\n   $ typeStr(a);\n   UUID"
    },
    {
        "title": "valueChanged",
        "cal": "valueChanged(X, [mode=prev])",
        "params": "`X` is a vector/matrix/table/tuple of STRING, BOOL, temporal or numeric type.",
        "exp": "Compare each element in *X* with the element specified by mode. Return true if the value is changed, otherwise false. Return false if the compared object does not exist.",
        "eg": "\n    $ x= 1 2 2 2 2 3 NULL 3 4 8\n    $ valueChanged(x)\n    [false,true,false,false,false,true,true,true,true,true]\n    \n    $ valueChanged(x,\"next\")\n    [true,false,false,false,true,true,true,true,true,false]\n    \n    $ valueChanged(x,\"any\")\n    [true,true,false,false,true,true,true,true,true,true]\n    \n    $ valueChanged(x,\"all\")\n    [false,false,false,false,false,true,true,true,true,false]\n\n    $ tup=(1 2 3, `A`A`B`C, 2021.10.12+1 2 2)\n    $ valueChanged(tup)\n    ([false,true,true],[false,false,true,true],[false,true,false])\n\n    $ m=matrix(1 2 3, 1 2 3, 1 3 3)\n    $ valueChanged(m)\n"
    },
    {
        "title": "values",
        "cal": "values(X)",
        "params": "`X` is a dictionary/table.",
        "exp": "Return all values of a dictionary, or all the columns of a table in a tuple.",
        "eg": ""
    },
    {
        "title": "var",
        "cal": "var(X)",
        "params": "`X` is a scalar/vector/matrix.",
        "exp": "If `X` is a vector, return the the (unbiased) sample standard variance of `X`.",
        "eg": "\n    $ var(1 1 1);\n    0\n    $ var(1 2 3);\n    1\n\n    $ m=matrix(1 3 5 7 9, 1 4 7 10 13);\n    $ m;\n"
    },
    {
        "title": "varp",
        "cal": "varp(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "If `X` is a vector, return the population variance of `X`.",
        "eg": "\n    $ varp(1 1 1);\n    0\n    $ varp(1 2 3);\n    0.666667\n\n    $ m=matrix(1 3 5 7 9, 1 4 7 10 13);\n    $ m;\n    #0\t#1\n    1\t1\n    3\t4\n    5\t7\n    7\t10\n    9\t13\n    $ varp(m);\n    [8,18]"
    },
    {
        "title": "version",
        "cal": "version()",
        "params": "None",
        "exp": "Return the version number and release date of the DolphinDB server.",
        "eg": "\n   $ version();\n   1.00.17 2020.04.24\n\n\n"
    },
    {
        "title": "warmupStreamEngine",
        "cal": "warmupStreamEngine(engine, msgs)",
        "params": "`engine` is the table object returned from creating a stream engine. ",
        "exp": "Ingest data into a stream engine without outputing results. When the next batch of data is ingested, the calculation can be sped up with the results that have already been generated.",
        "eg": "\n    $ trade=table(1000:0, `date`sym`price`volume, [DATE, SYMBOL, DOUBLE, INT])\n    $ n=3000*100\n    $ date=take(2021.03.08, n)\n    $ sym=take(\"A\"+string(1..3000), n)\n    $ price=round(rand(100.0, n), 2)\n    $ volume=rand(100, n)\n    $ table1 = table(date, sym, price, volume)\n    $ outputTable = table(n:0, `sym`factor1, [STRING,DOUBLE])\n    $ engine = createReactiveStateEngine(\"test\", <ema(volume, 40)>, table1, outputTable, \"sym\")\n    $ warmupStreamEngine(engine, table1)\n    $ date=take(2021.03.09, n)\n    $ sym=take(\"A\"+string(1..3000), n)\n    $ price=round(rand(100.0, n), 2)\n    $ volume=rand(100, n)\n    $ table2 = table(date, sym, price, volume)\n    $ engine.append!(table2)"
    },
    {
        "title": "wavg",
        "cal": "wavg(value, weight)",
        "params": "`value` and `weight` is the value vector.",
        "exp": "Calculate the weighted average of `X` with the weight vector `Y`. Please note that the weight vector `Y` is automatically scaled such that the sum of the weights is 1.",
        "eg": "\n    $ wavg(2.2 1.1 3.3, 4 5 6);\n    2.273333\n    //  (2.2*4+1.1*5+3.3*6)/(4+5+6)\n\n    $ wavg(1 NULL 1, 1 1 1);\n    1\n"
    },
    {
        "title": "wc",
        "cal": "wc(X)",
        "params": "`X` is a string scalar/vector.",
        "exp": "Count the words in `X`.",
        "eg": "\n   $ wc(`apple);\n   1\n\n   $ wc(\"This is a 7th generation iphone!\");\n   6\n\n   $ wc(\"This is a 7th generation iphone!\" \"I wonder what the 8th generation looks like\");\n   [6,8]"
    },
    {
        "title": "wcovar",
        "cal": "wcovar(X, Y, weights)",
        "params": "`X`, `Y` and `weights` are vectors of the same size.",
        "exp": "Calculate the weighted covariance of `X` and `Y` with weights as the weight vector.",
        "eg": ""
    },
    {
        "title": "weekBegin",
        "cal": "weekBegin(X, [weekday=0], [offset], [n=1])",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "For each element of `X`, return the first date of the week that it belongs to and that starts on the day as specified by parameter `weekday`.",
        "eg": "Example 1\n"
    },
    {
        "title": "weekEnd",
        "cal": "weekEnd(X, [weekday=6], [offset], [n=1])",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, DATEHOUR, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "For each element of `X`, return the last date of the week that it belongs to and that ends on the day as specified by parameter `weekday`.",
        "eg": "Example 1\n"
    },
    {
        "title": "weekOfMonth",
        "cal": "weekOfMonth(X, [week=0], [weekday=0], [offset], [n=1])",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "In the calendar month of `X`, suppose the \"week\"-th \"weekday\" is d. ",
        "eg": "\n    $ weekOfMonth(2019.11.01,2,4);\n    2019.10.18\n\n    $ weekOfMonth(2019.11.20,2,4);\n    $ 2019.11.15\n\n    $ date=2012.01.02 2012.02.03 2012.03.07 2012.04.08 2012.05.12 2012.06.16 2012.07.18 2012.08.20 2012.09.25 2012.10.28\n    $ time = [09:34:07,09:36:42,09:36:51,09:36:59,09:32:47,09:35:26,09:34:16,09:34:26,09:38:12,09:38:13]\n    $ sym = take(`MSFT,10)\n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ select avg(price),sum(qty) from t1 group by weekOfMonth(date,3,4,2012.01.01,2);\n"
    },
    {
        "title": "weekOfYear",
        "cal": "weekOfYear(X)",
        "params": "`X` is a scalar/vector of type DATE, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "For each element in `X`, return a number indicating which week of the year it falls in. Each week starts on Monday.",
        "eg": "\n    $ weekOfYear(2012.01.07);\n    1\n\n    $ weekOfYear(2013.01.07);\n    2\n\n    $ weekOfYear(2012.07.02);\n    27\n\n    $ weekOfYear([2012.06.12T12:30:00,2012.10.28T12:35:00,2013.01.06T12:36:47,2013.04.06T08:02:14]);\n    [24,43,1,14]\n"
    },
    {
        "title": "weekday",
        "cal": "weekday(X, [startFromSunday=true])",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return integer(s) to represent of the corresponding weekday(s) of `X`.",
        "eg": "\n   $ weekday 2012.12.05;\n   3\n\n   $ weekday(2012.12.05, false);\n   2\n\n   $ weekday 2013.05.23T12:00:00;\n   4\n\n   $ weekday(2014.01.11T23:04:28.113);\n   6\n\n   $ weekday 2012.12.05 2012.12.06 2013.01.05;\n   [3,4,6]"
    },
    {
        "title": "wilder",
        "cal": "wilder(X, window)",
        "params": "Calculate the Exponential Moving Average (ema) for *X* in a sliding window of the given length.",
        "exp": "  ",
        "eg": ""
    },
    {
        "title": "window",
        "cal": "window(func, funcArgs, range)",
        "params": "`func` is an aggregate function.",
        "exp": "1.30.16/2.00.4",
        "eg": "Apply *func*  over a sliding window of *funcArgs*. Each element in *funcArgs* corresponds to a window that is determined by *range*. The result has the same dimension as that of *funcArgs* (If funcArgs is a tuple, the result has the same dimension as that of each element in the tuple).\n\nSuppose *range* = [d1:d2], the windows are determined based on the following rules:\n\n\\1. When funcArgs is a vector, range must be a pair of integers. For the ith element in funcArgs, the corresponding window contains elements at position [i+d1, i+d2].\n\n\\2. When funcArgs is an indexed series or indexed matrix:\n\n- If funcArgs is indexed by time, for fi (the i-th element in the index of funcArgs), the corresponding window contains elements at index [temporalAdd(fi, d1), temporalAdd(fi, d2)]. \n- If funcArgs is indexed by integral values, *range* must also be integral. For fi (the i-th element in the index of funcArgs), the corresponding window contains elements at index [fi + d1, fi + d2].\n\nCompared with the `moving` function, the `window` function has a more flexible window. `moving` can be roughly considered as a special case of window, where the right boundary of the *range* parameter is 0. However, please note the following differences:\n\n\\1. When the window is based on element counts, `moving` returns null when the number of windowed elements does not satisfy the *minPeriods*, whereas window does not have a minimum count requirement.\n\n\\2. When the window is based on time, the left boundary of the window of `moving` is exclusive and the right boundary is inclusive; whereas both boundaries of the window of window are inclusive. In this example:  \n\nSuppose a window with the size of \"3d\" slides over an index of DATETIME type to apply calculation. For the point 2022.01.05T09:00:00\" in the index, the range of the corresponding window in moving is (2022.01.02T09:00:00,2022.01.05T09:00:00], whereas it's [2022.01.03T09:00:00,2022.01.05T09:00:00] in `window` (with the *range* parameter specified as \"-2d:0d\").\n\n"
    },
    {
        "title": "winsorize",
        "cal": "winsorize(X, limit, [inclusive=true], [nanPolicy='upper'])",
        "params": "`X` is a vector.",
        "exp": "Return a winsorized version of the input array.",
        "eg": ""
    },
    {
        "title": "winsorize!",
        "cal": "",
        "params": "",
        "exp": "",
        "eg": ""
    },
    {
        "title": "withNullFill",
        "cal": "withNullFill(func, x, y, fillValue)",
        "params": "`func` is a DolphinDB built-in function with two inputs, such as +, -, \\*, /, \\, %, pow, and, or, etc.",
        "exp": "If only 1 of the elements at the same location of x and y is NULL, replace the NULL value with fillValue in the calculation.  If both elements at the same location of x and y are NULL, return NULL.",
        "eg": "\n    $ x = 0 1 NULL NULL 2\n    $ y = 1 NULL 2 NULL 3;\n    $ add(x,y);\n    [1,,,,5]\n\n    $ withNullFill(add, x, y, 0);\n    [1,1,2,,5]\n\n    $ m=matrix(1..5, y);\n    $ m;\n"
    },
    {
        "title": "wls",
        "cal": "wls(Y, X, W, [intercept=true], [mode=0])",
        "params": "`Y` is a dependent variable. ",
        "exp": "Return the result of an weighted-least-squares regression of Y on X.",
        "eg": "\n    $ x1=1 3 5 7 11 16 23\n    $ x2=2 8 11 34 56 54 100\n    $ y=0.1 4.2 5.6 8.8 22.1 35.6 77.2;\n    $ w=rand(10,7)\n    $ wls(y, x1, w)\n\n    [-17.6177  4.0016]\n\n    $ wls(y, (x1,x2), w);\n\n    [-17.4168  3.0481 0.2214]\n"
    },
    {
        "title": "wma",
        "cal": "wma(X, window)",
        "params": "Calculate the Weighted Moving Average (wma) for *X* in a sliding window of the given length.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "write",
        "cal": "write(handle, object, [offset=0], [length])",
        "params": "Convert the specified buffer to a stream of bytes and then save to the file. The buffer could be a scalar or a vector with various data types. If an error occurs, an IOException is raised. Otherwise, the function returns the number of elements (not the number of bytes) written.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "writeBytes",
        "cal": "writeBytes(handle, bytes)",
        "params": "Write the entire buffer to the file. The buffer must be a char scalar or char vector. If the operation succeeds, it returns the actual number of bytes written; otherwise, an IOException will be raised.",
        "exp": "",
        "eg": ""
    },
    {
        "title": "writeLine",
        "cal": "writeLine(handle, string, [windowsLineEnding])",
        "params": "The optional Boolean parameter windowsLineEnding is the line ending character. If the parameter is not specified, the line ending character would be:",
        "exp": "Write a line to the given handle. The function will automatically append a line delimiter to the string. Thus the string shouldn't end with a line delimiter. If the operation succeeds, it returns 1; otherwise, an IOException will be raised.",
        "eg": "\n   $ x=`IBM`MSFT`GOOG`YHOO`ORCL\n   $ eachRight(writeLine, file(\"test.txt\",\"w\"), x);\n   [1,1,1,1,1]\n\n   $ fin = file(\"test.txt\")\n   $ do{\n   $    x=fin.readLine()\n   $    if(x.isVoid()) break\n   $    print x\n   $ }\n   $ while(true);\n\n   IBM\n   MSFT\n   GOOG\n   YHOO\n   ORCL"
    },
    {
        "title": "writeLines",
        "cal": "writeLines(handle, object, [offset=0], [length], [windowsLineEnding])",
        "params": "`length` is the number of lines from the handle to read.",
        "exp": "Write a given number of lines to the handle.",
        "eg": ""
    },
    {
        "title": "writeLog",
        "cal": "writeLog(X1, [X2, X3....Xn])",
        "params": "`X1`, `X2`, `X3` ... `Xn` are the strings to be written into the log file. Each string is a line in the log file.",
        "exp": "Write a message into the log file. It must be executed by a logged-in user.",
        "eg": "\n    $ writeLog(\"This is a message written into the log file.\")\n    $ writeLog(\"line1.\",\"line2.\",\"line3\");\n    \n    // Check the log file.\n    Sun Aug 06 16:41:05 2017 <INFO> :This is a message written into the log file.\n    Sun Aug 06 16:50:35 2017 <INFO> :line1.\n    Sun Aug 06 16:50:35 2017 <INFO> :line2.\n    Sun Aug 06 16:50:35 2017 <INFO> :line3\n"
    },
    {
        "title": "writeObject",
        "cal": "writeObject(handle, object)",
        "params": "Can write all data structures including scalar, vector, matrix, set, dictionary and table to the handle. It must be executed by a logged-in user. ",
        "exp": "",
        "eg": ""
    },
    {
        "title": "writeRecord",
        "cal": "writeRecord(handle, object, [offset=0], [length])",
        "params": "`handle` is a binary file handle.",
        "exp": "Convert DolphinDB objects such as tables or tuples to binary files. The function returns with the number of rows written to `handle`.",
        "eg": "\n   $ t=table(1..10000 as id, 1..10000+100 as value);\n\n   $ f1=file(\"C:/DolphinDB/a.bin\", \"w\"); \n   $ f1.writeRecord(t);\n   10000\n\n   $ f2=file(\"C:/DolphinDB/b.bin\", \"w\");\n   $ f2.writeRecord(t, 100, 1000);\n   1000\n\n   $ f3=file(\"C:/DolphinDB/c.bin\", \"w\");\n   $ f3.writeRecord(t, 100, 10000);\n   The optional argument length is invalid.\n"
    },
    {
        "title": "wsum",
        "cal": "wsum(X, Y)",
        "params": "`X` and `Y` are scalar/vector.",
        "exp": "Return the inner product of two vectors with the same length.",
        "eg": "\n    $ wsum(7 8 9, 1 2 3);\n    50\n    // 7*1 + 8*2 + 9*3 = 50\n"
    },
    {
        "title": "wsum2",
        "cal": "wsum2(X, Y)",
        "params": "`X` and `Y` are scalar/vector/matrix/table.",
        "exp": "``wsum2`` returns the weighted sum of squares of *X* and *Y*.",
        "eg": "\n    $ wsum2(3 4 1, 1 2 3);\n    44\n    // 9*1 + 16*2 + 1*3 = 44\n"
    },
    {
        "title": "xdb",
        "cal": "xdb(siteAlias, [userId], [password])",
        "params": "`siteAlias` is the alias of the remote node. It needs to be defined in configuration.",
        "exp": "Connect to a remote site. This remote site must be on. If the connection is successful, it returns the handle of the remote connection.",
        "eg": "\n   $ h2=xdb(\"local8081\");\n   $ h2;\n   \"Conn[localhost:8081:1166953221]\"\n\n   $ h21=xdb(\"localhost\",8081);\n   $ h21;\n   \"Conn[localhost:8081:1441295757]\"\n\n   $ h4=xdb(\"local8083\",\"userAdm\",\"passAdm\");\n   $ h4;\n   \"Conn[localhost:8083:1166953221]\"\n\n   $ h41=xdb(\"localhost\",8083, \"user001\",\"pass001\");\n   $ h41;\n   \"Conn[localhost:8083:597793698]\""
    },
    {
        "title": "xor",
        "cal": "xor(X, Y)",
        "params": "`X` and `Y` can be a scalar, pair, vector or matrix.",
        "exp": "Pair each elements in *X* and *Y* to perform the exclusive or operation. ",
        "eg": "\t"
    },
    {
        "title": "year",
        "cal": "year(X)",
        "params": "`X` is a temporal scalar/vector.",
        "exp": "Return the corresponding year(s). The data type of the result is INTEGER.",
        "eg": "\n   $ year(2012.12.03);\n   2012\n\n   $ year(2012.12.03 2011.11.05);\n   [2012,2011]\n\n   $ (2012.12.03).year();\n   2012\n"
    },
    {
        "title": "yearBegin",
        "cal": "yearBegin(X, [startingMonth=1], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the first day of the year that `X` belongs to and that starts in the month of `startingMonth`.",
        "eg": "\n    $ yearBegin(2012.06.12, 10);\n    2011.10.01\n\n    $ yearBegin(2012.06.12, 4);\n    2012.04.01\n\n    $ yearBegin(2012.06.12);\n    2012.01.01\n\n    $ yearBegin(2012.06.12, 1, 2009.04.03, 2);\n    2011.01.01\n\n    $ date=2011.04.25+(1..10)*365\n    $ time = take(09:30:00, 10);\n    $ sym = take(`MSFT,10)\n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ t1;\n"
    },
    {
        "title": "yearEnd",
        "cal": "yearEnd(X, [endingMonth=12], [offset], [n=1])",
        "params": "`X` is a scalar/vector of data type DATE, DATEHOUR, DATETIME, TIMESTAMP or NANOTIMESTAMP.",
        "exp": "Return the last day of the year that `X` belongs to and that ends in the month of `endingMonth`.",
        "eg": "\n    $ yearEnd(2012.06.12, 3);\n    2013.03.31\n\n    $ yearEnd(2012.06.12, 9);\n    2012.09.30\n\n    $ yearEnd(2012.06.12);\n    2012.12.31\n\n    $ yearEnd(2012.06.12, 12, 2009.04.03, 2);\n    2013.12.31\n\n    $ date=2011.04.25+(1..10)*365\n    $ time = take(09:30:00, 10);\n    $ sym = take(`MSFT,10)\n    $ price= 49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29 52.38\n    $ qty = 2200 1900 2100 3200 6800 5400 1300 2500 8800 4500\n    $ t1 = table(date, time, sym, qty, price);\n\n    $ t1;\n"
    },
    {
        "title": "zTest",
        "cal": "zTest(X, [Y], [mu=0.0], [sigmaX=1.0], [sigmaY=1.0], [confLevel=0.95])",
        "params": "`X` is a numeric vector indicating the sample for the Z-test.",
        "exp": "If `Y` is not specified, conduct a one-sample Z-test on `X`. If `Y` is specified, conduct a paired-sample Z-test on `X` and `Y`.  ",
        "eg": "One-sample Z-test:\n"
    },
    {
        "title": "zigzag",
        "cal": "zigzag(HL, [change=10], [percent=true], [retrace=false], [lastExtreme=true])",
        "params": "`HL` is a numeric vector or a numeric matrix with two columns.",
        "exp": "``zigzag`` is mainly used to filter values with smaller movements in *HL*. Only extreme points that satisfy the conditions will be output.",
        "eg": "\n    $ t = table(1.1 2.3 4.45 3.67 4.9 as `low, 1.3 2.8 4.9 3.73 6.28 as `high)\n    $ HL = matrix(t[`low], t[`high])\n    $ zz = zigzag(HL, change=10, percent=true, retrace=false, lastExtreme=true)\n"
    },
    {
        "title": "zscore",
        "cal": "zscore(X)",
        "params": "`X` is a vector/matrix.",
        "exp": "If `X` is a vector, return the the zscore for all elements of `X`.",
        "eg": "\n    $ zscore(1 2 3 4 5);\n    [-1.264911,-0.632456,0,0.632456,1.264911]\n\n    $ m=matrix(1 2 3, 4 5 6);\n    $ m;\n"
    }
]